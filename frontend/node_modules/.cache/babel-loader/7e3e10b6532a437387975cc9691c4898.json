{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createClass = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamReader = exports.EndOfStreamError = void 0;\n\nvar EndOfFileStream_1 = require(\"./EndOfFileStream\");\n\nvar EndOfFileStream_2 = require(\"./EndOfFileStream\");\n\nObject.defineProperty(exports, \"EndOfStreamError\", {\n  enumerable: true,\n  get: function get() {\n    return EndOfFileStream_2.EndOfStreamError;\n  }\n});\n\nvar Deferred = function Deferred() {\n  var _this = this;\n\n  _classCallCheck(this, Deferred);\n\n  this.promise = new Promise(function (resolve, reject) {\n    _this.reject = reject;\n    _this.resolve = resolve;\n  });\n};\n\nvar maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\n\nvar StreamReader = /*#__PURE__*/function () {\n  function StreamReader(s) {\n    var _this2 = this;\n\n    _classCallCheck(this, StreamReader);\n\n    this.s = s;\n    this.endOfStream = false;\n    /**\n     * Store peeked data\n     * @type {Array}\n     */\n\n    this.peekQueue = [];\n\n    if (!s.read || !s.once) {\n      throw new Error('Expected an instance of stream.Readable');\n    }\n\n    this.s.once('end', function () {\n      return _this2.reject(new EndOfFileStream_1.EndOfStreamError());\n    });\n    this.s.once('error', function (err) {\n      return _this2.reject(err);\n    });\n    this.s.once('close', function () {\n      return _this2.reject(new Error('Stream closed'));\n    });\n  }\n  /**\n   * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\n   * @param buffer - Buffer to store data read from stream in\n   * @param offset - Offset buffer\n   * @param length - Number of bytes to read\n   * @returns Number of bytes peeked\n   */\n\n\n  _createClass(StreamReader, [{\n    key: \"peek\",\n    value: function () {\n      var _peek = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(buffer, offset, length) {\n        var bytesRead;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.read(buffer, offset, length);\n\n              case 2:\n                bytesRead = _context.sent;\n                this.peekQueue.push(buffer.slice(offset, offset + bytesRead)); // Put read data back to peek buffer\n\n                return _context.abrupt(\"return\", bytesRead);\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function peek(_x, _x2, _x3) {\n        return _peek.apply(this, arguments);\n      }\n\n      return peek;\n    }()\n    /**\n     * Read chunk from stream\n     * @param buffer - Target buffer to store data read from stream in\n     * @param offset - Offset of target buffer\n     * @param length - Number of bytes to read\n     * @returns Number of bytes read\n     */\n\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(buffer, offset, length) {\n        var remaining, bytesRead, peekData, lenCopy, reqLen, chunkLen;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(length === 0)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", 0);\n\n              case 2:\n                if (!(this.peekQueue.length === 0 && this.endOfStream)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                throw new EndOfFileStream_1.EndOfStreamError();\n\n              case 4:\n                remaining = length;\n                bytesRead = 0; // consume peeked data first\n\n                while (this.peekQueue.length > 0 && remaining > 0) {\n                  peekData = this.peekQueue.pop(); // Front of queue\n\n                  lenCopy = Math.min(peekData.length, remaining);\n                  peekData.copy(buffer, offset + bytesRead, 0, lenCopy);\n                  bytesRead += lenCopy;\n                  remaining -= lenCopy;\n\n                  if (lenCopy < peekData.length) {\n                    // remainder back to queue\n                    this.peekQueue.push(peekData.slice(lenCopy));\n                  }\n                } // continue reading from stream if required\n\n\n              case 7:\n                if (!(remaining > 0 && !this.endOfStream)) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                reqLen = Math.min(remaining, maxStreamReadSize);\n                _context2.next = 11;\n                return this._read(buffer, offset + bytesRead, reqLen);\n\n              case 11:\n                chunkLen = _context2.sent;\n                bytesRead += chunkLen;\n\n                if (!(chunkLen < reqLen)) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                return _context2.abrupt(\"break\", 18);\n\n              case 15:\n                remaining -= chunkLen;\n                _context2.next = 7;\n                break;\n\n              case 18:\n                return _context2.abrupt(\"return\", bytesRead);\n\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function read(_x4, _x5, _x6) {\n        return _read2.apply(this, arguments);\n      }\n\n      return read;\n    }()\n    /**\n     * Read chunk from stream\n     * @param buffer Buffer to store data read from stream in\n     * @param offset Offset buffer\n     * @param length Number of bytes to read\n     * @returns Number of bytes read\n     */\n\n  }, {\n    key: \"_read\",\n    value: function () {\n      var _read3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(buffer, offset, length) {\n        var _this3 = this;\n\n        var readBuffer;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this.request) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new Error('Concurrent read operation?');\n\n              case 2:\n                readBuffer = this.s.read(length);\n\n                if (!readBuffer) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                readBuffer.copy(buffer, offset);\n                return _context3.abrupt(\"return\", readBuffer.length);\n\n              case 8:\n                this.request = {\n                  buffer: buffer,\n                  offset: offset,\n                  length: length,\n                  deferred: new Deferred()\n                };\n                this.s.once('readable', function () {\n                  _this3.tryRead();\n                });\n                return _context3.abrupt(\"return\", this.request.deferred.promise.then(function (n) {\n                  _this3.request = null;\n                  return n;\n                }, function (err) {\n                  _this3.request = null;\n                  throw err;\n                }));\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _read(_x7, _x8, _x9) {\n        return _read3.apply(this, arguments);\n      }\n\n      return _read;\n    }()\n  }, {\n    key: \"tryRead\",\n    value: function tryRead() {\n      var _this4 = this;\n\n      var readBuffer = this.s.read(this.request.length);\n\n      if (readBuffer) {\n        readBuffer.copy(this.request.buffer, this.request.offset);\n        this.request.deferred.resolve(readBuffer.length);\n      } else {\n        this.s.once('readable', function () {\n          _this4.tryRead();\n        });\n      }\n    }\n  }, {\n    key: \"reject\",\n    value: function reject(err) {\n      this.endOfStream = true;\n\n      if (this.request) {\n        this.request.deferred.reject(err);\n        this.request = null;\n      }\n    }\n  }]);\n\n  return StreamReader;\n}();\n\nexports.StreamReader = StreamReader;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/peek-readable/lib/index.js"],"names":["Object","defineProperty","exports","value","StreamReader","EndOfStreamError","EndOfFileStream_1","require","EndOfFileStream_2","enumerable","get","Deferred","promise","Promise","resolve","reject","maxStreamReadSize","s","endOfStream","peekQueue","read","once","Error","err","buffer","offset","length","bytesRead","push","slice","remaining","peekData","pop","lenCopy","Math","min","copy","reqLen","_read","chunkLen","request","readBuffer","deferred","tryRead","then","n"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StreamReader = exports.EndOfStreamError = void 0;\nconst EndOfFileStream_1 = require(\"./EndOfFileStream\");\nvar EndOfFileStream_2 = require(\"./EndOfFileStream\");\nObject.defineProperty(exports, \"EndOfStreamError\", { enumerable: true, get: function () { return EndOfFileStream_2.EndOfStreamError; } });\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\nclass StreamReader {\n    constructor(s) {\n        this.s = s;\n        this.endOfStream = false;\n        /**\n         * Store peeked data\n         * @type {Array}\n         */\n        this.peekQueue = [];\n        if (!s.read || !s.once) {\n            throw new Error('Expected an instance of stream.Readable');\n        }\n        this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));\n        this.s.once('error', err => this.reject(err));\n        this.s.once('close', () => this.reject(new Error('Stream closed')));\n    }\n    /**\n     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\n     * @param buffer - Buffer to store data read from stream in\n     * @param offset - Offset buffer\n     * @param length - Number of bytes to read\n     * @returns Number of bytes peeked\n     */\n    async peek(buffer, offset, length) {\n        const bytesRead = await this.read(buffer, offset, length);\n        this.peekQueue.push(buffer.slice(offset, offset + bytesRead)); // Put read data back to peek buffer\n        return bytesRead;\n    }\n    /**\n     * Read chunk from stream\n     * @param buffer - Target buffer to store data read from stream in\n     * @param offset - Offset of target buffer\n     * @param length - Number of bytes to read\n     * @returns Number of bytes read\n     */\n    async read(buffer, offset, length) {\n        if (length === 0) {\n            return 0;\n        }\n        if (this.peekQueue.length === 0 && this.endOfStream) {\n            throw new EndOfFileStream_1.EndOfStreamError();\n        }\n        let remaining = length;\n        let bytesRead = 0;\n        // consume peeked data first\n        while (this.peekQueue.length > 0 && remaining > 0) {\n            const peekData = this.peekQueue.pop(); // Front of queue\n            const lenCopy = Math.min(peekData.length, remaining);\n            peekData.copy(buffer, offset + bytesRead, 0, lenCopy);\n            bytesRead += lenCopy;\n            remaining -= lenCopy;\n            if (lenCopy < peekData.length) {\n                // remainder back to queue\n                this.peekQueue.push(peekData.slice(lenCopy));\n            }\n        }\n        // continue reading from stream if required\n        while (remaining > 0 && !this.endOfStream) {\n            const reqLen = Math.min(remaining, maxStreamReadSize);\n            const chunkLen = await this._read(buffer, offset + bytesRead, reqLen);\n            bytesRead += chunkLen;\n            if (chunkLen < reqLen)\n                break;\n            remaining -= chunkLen;\n        }\n        return bytesRead;\n    }\n    /**\n     * Read chunk from stream\n     * @param buffer Buffer to store data read from stream in\n     * @param offset Offset buffer\n     * @param length Number of bytes to read\n     * @returns Number of bytes read\n     */\n    async _read(buffer, offset, length) {\n        if (this.request)\n            throw new Error('Concurrent read operation?');\n        const readBuffer = this.s.read(length);\n        if (readBuffer) {\n            readBuffer.copy(buffer, offset);\n            return readBuffer.length;\n        }\n        else {\n            this.request = {\n                buffer,\n                offset,\n                length,\n                deferred: new Deferred()\n            };\n            this.s.once('readable', () => {\n                this.tryRead();\n            });\n            return this.request.deferred.promise.then(n => {\n                this.request = null;\n                return n;\n            }, err => {\n                this.request = null;\n                throw err;\n            });\n        }\n    }\n    tryRead() {\n        const readBuffer = this.s.read(this.request.length);\n        if (readBuffer) {\n            readBuffer.copy(this.request.buffer, this.request.offset);\n            this.request.deferred.resolve(readBuffer.length);\n        }\n        else {\n            this.s.once('readable', () => {\n                this.tryRead();\n            });\n        }\n    }\n    reject(err) {\n        this.endOfStream = true;\n        if (this.request) {\n            this.request.deferred.reject(err);\n            this.request = null;\n        }\n    }\n}\nexports.StreamReader = StreamReader;\n"]},"metadata":{},"sourceType":"script"}