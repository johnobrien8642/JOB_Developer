{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MP4Parser = void 0;\n\nconst initDebug = require(\"debug\");\n\nconst Token = require(\"token-types\");\n\nconst BasicParser_1 = require(\"../common/BasicParser\");\n\nconst Atom_1 = require(\"./Atom\");\n\nconst AtomToken = require(\"./AtomToken\");\n\nconst ID3v1Parser_1 = require(\"../id3v1/ID3v1Parser\");\n\nconst type_1 = require(\"../type\");\n\nconst debug = initDebug('music-metadata:parser:MP4');\nconst tagFormat = 'iTunes';\nconst encoderDict = {\n  raw: {\n    lossy: false,\n    format: 'raw'\n  },\n  MAC3: {\n    lossy: true,\n    format: 'MACE 3:1'\n  },\n  MAC6: {\n    lossy: true,\n    format: 'MACE 6:1'\n  },\n  ima4: {\n    lossy: true,\n    format: 'IMA 4:1'\n  },\n  ulaw: {\n    lossy: true,\n    format: 'uLaw 2:1'\n  },\n  alaw: {\n    lossy: true,\n    format: 'uLaw 2:1'\n  },\n  Qclp: {\n    lossy: true,\n    format: 'QUALCOMM PureVoice'\n  },\n  '.mp3': {\n    lossy: true,\n    format: 'MPEG-1 layer 3'\n  },\n  alac: {\n    lossy: false,\n    format: 'ALAC'\n  },\n  'ac-3': {\n    lossy: true,\n    format: 'AC-3'\n  },\n  mp4a: {\n    lossy: true,\n    format: 'MPEG-4/AAC'\n  },\n  mp4s: {\n    lossy: true,\n    format: 'MP4S'\n  },\n  // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\n  c608: {\n    lossy: true,\n    format: 'CEA-608'\n  },\n  c708: {\n    lossy: true,\n    format: 'CEA-708'\n  }\n};\n\nfunction distinct(value, index, self) {\n  return self.indexOf(value) === index;\n}\n/*\r\n * Parser for the MP4 (MPEG-4 Part 14) container format\r\n * Standard: ISO/IEC 14496-14\r\n * supporting:\r\n * - QuickTime container\r\n * - MP4 File Format\r\n * - 3GPP file format\r\n * - 3GPP2 file format\r\n *\r\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\r\n * Support for Apple iTunes tags as found in a M4A/M4V files.\r\n * Ref:\r\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\r\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\r\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\r\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\r\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\r\n */\n\n\nclass MP4Parser extends BasicParser_1.BasicParser {\n  constructor() {\n    super(...arguments);\n    this.atomParsers = {\n      /**\r\n       * Parse movie header (mvhd) atom\r\n       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\r\n       */\n      mvhd: async len => {\n        const _mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));\n\n        this.metadata.setFormat('creationTime', _mvhd.creationTime);\n        this.metadata.setFormat('modificationTime', _mvhd.modificationTime);\n      },\n\n      /**\r\n       * Parse media header (mdhd) atom\r\n       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615\r\n       */\n      mdhd: async len => {\n        const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(len)); // this.parse_mxhd(mdhd_data, this.currentTrack);\n\n        const td = this.getTrackDescription();\n        td.creationTime = mdhd_data.creationTime;\n        td.modificationTime = mdhd_data.modificationTime;\n        td.timeScale = mdhd_data.timeScale;\n        td.duration = mdhd_data.duration;\n      },\n      chap: async len => {\n        const td = this.getTrackDescription();\n        const trackIds = [];\n\n        while (len >= Token.UINT32_BE.len) {\n          trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\n          len -= Token.UINT32_BE.len;\n        }\n\n        td.chapterList = trackIds;\n      },\n      tkhd: async len => {\n        const track = await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len));\n        this.tracks.push(track);\n      },\n\n      /**\r\n       * Parse mdat atom.\r\n       * Will scan for chapters\r\n       */\n      mdat: async len => {\n        this.audioLengthInBytes = len;\n        this.calculateBitRate();\n\n        if (this.options.includeChapters) {\n          const trackWithChapters = this.tracks.filter(track => track.chapterList);\n\n          if (trackWithChapters.length === 1) {\n            const chapterTrackIds = trackWithChapters[0].chapterList;\n            const chapterTracks = this.tracks.filter(track => chapterTrackIds.indexOf(track.trackId) !== -1);\n\n            if (chapterTracks.length === 1) {\n              return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\n            }\n          }\n        }\n\n        await this.tokenizer.ignore(len);\n      },\n      ftyp: async len => {\n        const types = [];\n\n        while (len > 0) {\n          const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\n          len -= AtomToken.ftyp.len;\n          const value = ftype.type.replace(/\\W/g, '');\n\n          if (value.length > 0) {\n            types.push(value); // unshift for backward compatibility\n          }\n        }\n\n        debug(`ftyp: ${types.join('/')}`);\n        const x = types.filter(distinct).join('/');\n        this.metadata.setFormat('container', x);\n      },\n\n      /**\r\n       * Parse sample description atom\r\n       */\n      stsd: async len => {\n        const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\n        const trackDescription = this.getTrackDescription();\n        trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n      },\n\n      /**\r\n       * sample-to-Chunk Atoms\r\n       */\n      stsc: async len => {\n        const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(len));\n        this.getTrackDescription().sampleToChunkTable = stsc.entries;\n      },\n\n      /**\r\n       * time to sample\r\n       */\n      stts: async len => {\n        const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(len));\n        this.getTrackDescription().timeToSampleTable = stts.entries;\n      },\n\n      /**\r\n       * Parse sample-sizes atom ('stsz')\r\n       */\n      stsz: async len => {\n        const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\n        const td = this.getTrackDescription();\n        td.sampleSize = stsz.sampleSize;\n        td.sampleSizeTable = stsz.entries;\n      },\n\n      /**\r\n       * Parse chunk-offset atom ('stco')\r\n       */\n      stco: async len => {\n        const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(len));\n        this.getTrackDescription().chunkOffsetTable = stco.entries; // remember chunk offsets\n      },\n      date: async len => {\n        const date = await this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));\n        this.addTag('date', date);\n      }\n    };\n  }\n\n  static read_BE_Signed_Integer(value) {\n    return Token.readIntBE(value, 0, value.length);\n  }\n\n  static read_BE_Unsigned_Integer(value) {\n    return Token.readUIntBE(value, 0, value.length);\n  }\n\n  async parse() {\n    this.tracks = [];\n    let remainingFileSize = this.tokenizer.fileInfo.size;\n\n    while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\n      try {\n        const token = await this.tokenizer.peekToken(AtomToken.Header);\n\n        if (token.name === '\\0\\0\\0\\0') {\n          const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\n          debug(errMsg);\n          this.addWarning(errMsg);\n          break;\n        }\n      } catch (error) {\n        const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\n        debug(errMsg);\n        this.addWarning(errMsg);\n        break;\n      }\n\n      const rootAtom = await Atom_1.Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);\n      remainingFileSize -= rootAtom.header.length === 0 ? remainingFileSize : rootAtom.header.length;\n    } // Post process metadata\n\n\n    const formatList = [];\n    this.tracks.forEach(track => {\n      const trackFormats = [];\n      track.soundSampleDescription.forEach(ssd => {\n        const streamInfo = {};\n        const encoderInfo = encoderDict[ssd.dataFormat];\n\n        if (encoderInfo) {\n          trackFormats.push(encoderInfo.format);\n          streamInfo.codecName = encoderInfo.format;\n        } else {\n          streamInfo.codecName = `<${ssd.dataFormat}>`;\n        }\n\n        if (ssd.description) {\n          const {\n            description\n          } = ssd;\n\n          if (description.sampleRate > 0) {\n            streamInfo.type = type_1.TrackType.audio;\n            streamInfo.audio = {\n              samplingFrequency: description.sampleRate,\n              bitDepth: description.sampleSize,\n              channels: description.numAudioChannels\n            };\n          }\n        }\n\n        this.metadata.addStreamInfo(streamInfo);\n      });\n\n      if (trackFormats.length >= 1) {\n        formatList.push(trackFormats.join('/'));\n      }\n    });\n\n    if (formatList.length > 0) {\n      this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\n    }\n\n    const audioTracks = this.tracks.filter(track => {\n      return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;\n    });\n\n    if (audioTracks.length >= 1) {\n      const audioTrack = audioTracks[0];\n      const duration = audioTrack.duration / audioTrack.timeScale;\n      this.metadata.setFormat('duration', duration); // calculate duration in seconds\n\n      const ssd = audioTrack.soundSampleDescription[0];\n\n      if (ssd.description) {\n        this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\n        this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\n        this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\n      }\n\n      const encoderInfo = encoderDict[ssd.dataFormat];\n\n      if (encoderInfo) {\n        this.metadata.setFormat('lossless', !encoderInfo.lossy);\n      }\n\n      this.calculateBitRate();\n    }\n  }\n\n  async handleAtom(atom, remaining) {\n    if (atom.parent) {\n      switch (atom.parent.header.name) {\n        case 'ilst':\n        case '<id>':\n          return this.parseMetadataItemData(atom);\n      }\n    } // const payloadLength = atom.getPayloadLength(remaining);\n\n\n    if (this.atomParsers[atom.header.name]) {\n      return this.atomParsers[atom.header.name](remaining);\n    } else {\n      debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);\n      await this.tokenizer.ignore(remaining);\n    }\n  }\n\n  getTrackDescription() {\n    return this.tracks[this.tracks.length - 1];\n  }\n\n  calculateBitRate() {\n    if (this.audioLengthInBytes && this.metadata.format.duration) {\n      this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);\n    }\n  }\n\n  addTag(id, value) {\n    this.metadata.addTag(tagFormat, id, value);\n  }\n\n  addWarning(message) {\n    debug('Warning: ' + message);\n    this.metadata.addWarning(message);\n  }\n  /**\r\n   * Parse data of Meta-item-list-atom (item of 'ilst' atom)\r\n   * @param metaAtom\r\n   * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\r\n   */\n\n\n  parseMetadataItemData(metaAtom) {\n    let tagKey = metaAtom.header.name;\n    return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {\n      const payLoadLength = child.getPayloadLength(remaining);\n\n      switch (child.header.name) {\n        case 'data':\n          // value atom\n          return this.parseValueAtom(tagKey, child);\n\n        case 'name':\n          // name atom (optional)\n          const name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\n          tagKey += ':' + name.name;\n          break;\n\n        case 'mean':\n          // name atom (optional)\n          const mean = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength)); // console.log(\"  %s[%s] = %s\", tagKey, header.name, mean.name);\n\n          tagKey += ':' + mean.name;\n          break;\n\n        default:\n          const dataAtom = await this.tokenizer.readToken(new Token.BufferType(payLoadLength));\n          this.addWarning('Unsupported meta-item: ' + tagKey + '[' + child.header.name + '] => value=' + dataAtom.toString('hex') + ' ascii=' + dataAtom.toString('ascii'));\n      }\n    }, metaAtom.getPayloadLength(0));\n  }\n\n  async parseValueAtom(tagKey, metaAtom) {\n    const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(metaAtom.header.length - AtomToken.Header.len));\n\n    if (dataAtom.type.set !== 0) {\n      throw new Error('Unsupported type-set != 0: ' + dataAtom.type.set);\n    } // Use well-known-type table\n    // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\n\n\n    switch (dataAtom.type.type) {\n      case 0:\n        // reserved: Reserved for use where no type needs to be indicated\n        switch (tagKey) {\n          case 'trkn':\n          case 'disk':\n            const num = Token.UINT8.get(dataAtom.value, 3);\n            const of = Token.UINT8.get(dataAtom.value, 5); // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\n\n            this.addTag(tagKey, num + '/' + of);\n            break;\n\n          case 'gnre':\n            const genreInt = Token.UINT8.get(dataAtom.value, 1);\n            const genreStr = ID3v1Parser_1.Genres[genreInt - 1]; // console.log(\"  %s[data] = %s\", tagKey, genreStr);\n\n            this.addTag(tagKey, genreStr);\n            break;\n\n          default: // console.log(\"  reserved-data: name=%s, len=%s, set=%s, type=%s, locale=%s, value{ hex=%s, ascii=%s }\",\n          // header.name, header.length, dataAtom.type.set, dataAtom.type.type, dataAtom.locale, dataAtom.value.toString('hex'), dataAtom.value.toString('ascii'));\n\n        }\n\n        break;\n\n      case 1: // UTF-8: Without any count or NULL terminator\n\n      case 18:\n        // Unknown: Found in m4b in combination with a '©gen' tag\n        this.addTag(tagKey, dataAtom.value.toString('utf-8'));\n        break;\n\n      case 13:\n        // JPEG\n        if (this.options.skipCovers) break;\n        this.addTag(tagKey, {\n          format: 'image/jpeg',\n          data: Buffer.from(dataAtom.value)\n        });\n        break;\n\n      case 14:\n        // PNG\n        if (this.options.skipCovers) break;\n        this.addTag(tagKey, {\n          format: 'image/png',\n          data: Buffer.from(dataAtom.value)\n        });\n        break;\n\n      case 21:\n        // BE Signed Integer\n        this.addTag(tagKey, MP4Parser.read_BE_Signed_Integer(dataAtom.value));\n        break;\n\n      case 22:\n        // BE Unsigned Integer\n        this.addTag(tagKey, MP4Parser.read_BE_Unsigned_Integer(dataAtom.value));\n        break;\n\n      case 65:\n        // An 8-bit signed integer\n        this.addTag(tagKey, dataAtom.value.readInt8(0));\n        break;\n\n      case 66:\n        // A big-endian 16-bit signed integer\n        this.addTag(tagKey, dataAtom.value.readInt16BE(0));\n        break;\n\n      case 67:\n        // A big-endian 32-bit signed integer\n        this.addTag(tagKey, dataAtom.value.readInt32BE(0));\n        break;\n\n      default:\n        this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\n    }\n  }\n  /**\r\n   * @param sampleDescription\r\n   * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\r\n   */\n\n\n  parseSoundSampleDescription(sampleDescription) {\n    const ssd = {\n      dataFormat: sampleDescription.dataFormat,\n      dataReferenceIndex: sampleDescription.dataReferenceIndex\n    };\n    let offset = 0;\n    const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\n    offset += AtomToken.SoundSampleDescriptionVersion.len;\n\n    if (version.version === 0 || version.version === 1) {\n      // Sound Sample Description (Version 0)\n      ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\n    } else {\n      debug(`Warning: sound-sample-description ${version} not implemented`);\n    }\n\n    return ssd;\n  }\n\n  async parseChapterTrack(chapterTrack, track, len) {\n    if (!chapterTrack.sampleSize) {\n      if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length) throw new Error('Expected equal chunk-offset-table & sample-size-table length.');\n    }\n\n    const chapters = [];\n\n    for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\n      const chunkOffset = chapterTrack.chunkOffsetTable[i];\n      const nextChunkLen = chunkOffset - this.tokenizer.position;\n      const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\n      len -= nextChunkLen + sampleSize;\n      if (len < 0) throw new Error('Chapter chunk exceeding token length');\n      await this.tokenizer.ignore(nextChunkLen);\n      const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\n      debug(`Chapter ${i + 1}: ${title}`);\n      const chapter = {\n        title,\n        sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\n      };\n      debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`);\n      chapters.push(chapter);\n    }\n\n    this.metadata.setFormat('chapters', chapters);\n    await this.tokenizer.ignore(len);\n  }\n\n  findSampleOffset(track, chapterOffset) {\n    let totalDuration = 0;\n    track.timeToSampleTable.forEach(e => {\n      totalDuration += e.count * e.duration;\n    });\n    debug(`Total duration=${totalDuration}`);\n    let chunkIndex = 0;\n\n    while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\n      ++chunkIndex;\n    }\n\n    return this.getChunkDuration(chunkIndex + 1, track);\n  }\n\n  getChunkDuration(chunkId, track) {\n    let ttsi = 0;\n    let ttsc = track.timeToSampleTable[ttsi].count;\n    let ttsd = track.timeToSampleTable[ttsi].duration;\n    let curChunkId = 1;\n    let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n    let totalDuration = 0;\n\n    while (curChunkId < chunkId) {\n      const nrOfSamples = Math.min(ttsc, samplesPerChunk);\n      totalDuration += nrOfSamples * ttsd;\n      ttsc -= nrOfSamples;\n      samplesPerChunk -= nrOfSamples;\n\n      if (samplesPerChunk === 0) {\n        ++curChunkId;\n        samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n      } else {\n        ++ttsi;\n        ttsc = track.timeToSampleTable[ttsi].count;\n        ttsd = track.timeToSampleTable[ttsi].duration;\n      }\n    }\n\n    return totalDuration;\n  }\n\n  getSamplesPerChunk(chunkId, stcTable) {\n    for (let i = 0; i < stcTable.length - 1; ++i) {\n      if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\n        return stcTable[i].samplesPerChunk;\n      }\n    }\n\n    return stcTable[stcTable.length - 1].samplesPerChunk;\n  }\n\n}\n\nexports.MP4Parser = MP4Parser;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/mp4/MP4Parser.js"],"names":["Object","defineProperty","exports","value","MP4Parser","initDebug","require","Token","BasicParser_1","Atom_1","AtomToken","ID3v1Parser_1","type_1","debug","tagFormat","encoderDict","raw","lossy","format","MAC3","MAC6","ima4","ulaw","alaw","Qclp","alac","mp4a","mp4s","c608","c708","distinct","index","self","indexOf","BasicParser","constructor","arguments","atomParsers","mvhd","len","_mvhd","tokenizer","readToken","MvhdAtom","metadata","setFormat","creationTime","modificationTime","mdhd","mdhd_data","MdhdAtom","td","getTrackDescription","timeScale","duration","chap","trackIds","UINT32_BE","push","readNumber","chapterList","tkhd","track","TrackHeaderAtom","tracks","mdat","audioLengthInBytes","calculateBitRate","options","includeChapters","trackWithChapters","filter","length","chapterTrackIds","chapterTracks","trackId","parseChapterTrack","ignore","ftyp","types","ftype","type","replace","join","x","stsd","StsdAtom","trackDescription","soundSampleDescription","table","map","dfEntry","parseSoundSampleDescription","stsc","StscAtom","sampleToChunkTable","entries","stts","SttsAtom","timeToSampleTable","stsz","StszAtom","sampleSize","sampleSizeTable","stco","StcoAtom","chunkOffsetTable","date","StringType","addTag","read_BE_Signed_Integer","readIntBE","read_BE_Unsigned_Integer","readUIntBE","parse","remainingFileSize","fileInfo","size","token","peekToken","Header","name","errMsg","position","addWarning","error","message","rootAtom","Atom","readAtom","atom","remaining","handleAtom","header","formatList","forEach","trackFormats","ssd","streamInfo","encoderInfo","dataFormat","codecName","description","sampleRate","TrackType","audio","samplingFrequency","bitDepth","channels","numAudioChannels","addStreamInfo","audioTracks","audioTrack","parent","parseMetadataItemData","atomPath","id","metaAtom","tagKey","readAtoms","child","payLoadLength","getPayloadLength","parseValueAtom","NameAtom","mean","dataAtom","BufferType","toString","DataAtom","set","Error","num","UINT8","get","of","genreInt","genreStr","Genres","skipCovers","data","Buffer","from","readInt8","readInt16BE","readInt32BE","sampleDescription","dataReferenceIndex","offset","version","SoundSampleDescriptionVersion","SoundSampleDescriptionV0","chapterTrack","chapters","i","chunkOffset","nextChunkLen","title","ChapterText","chapter","sampleOffset","findSampleOffset","chapterOffset","totalDuration","e","count","chunkIndex","getChunkDuration","chunkId","ttsi","ttsc","ttsd","curChunkId","samplesPerChunk","getSamplesPerChunk","nrOfSamples","Math","min","stcTable","firstChunk"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MP4Parser = void 0;\r\nconst initDebug = require(\"debug\");\r\nconst Token = require(\"token-types\");\r\nconst BasicParser_1 = require(\"../common/BasicParser\");\r\nconst Atom_1 = require(\"./Atom\");\r\nconst AtomToken = require(\"./AtomToken\");\r\nconst ID3v1Parser_1 = require(\"../id3v1/ID3v1Parser\");\r\nconst type_1 = require(\"../type\");\r\nconst debug = initDebug('music-metadata:parser:MP4');\r\nconst tagFormat = 'iTunes';\r\nconst encoderDict = {\r\n    raw: {\r\n        lossy: false,\r\n        format: 'raw'\r\n    },\r\n    MAC3: {\r\n        lossy: true,\r\n        format: 'MACE 3:1'\r\n    },\r\n    MAC6: {\r\n        lossy: true,\r\n        format: 'MACE 6:1'\r\n    },\r\n    ima4: {\r\n        lossy: true,\r\n        format: 'IMA 4:1'\r\n    },\r\n    ulaw: {\r\n        lossy: true,\r\n        format: 'uLaw 2:1'\r\n    },\r\n    alaw: {\r\n        lossy: true,\r\n        format: 'uLaw 2:1'\r\n    },\r\n    Qclp: {\r\n        lossy: true,\r\n        format: 'QUALCOMM PureVoice'\r\n    },\r\n    '.mp3': {\r\n        lossy: true,\r\n        format: 'MPEG-1 layer 3'\r\n    },\r\n    alac: {\r\n        lossy: false,\r\n        format: 'ALAC'\r\n    },\r\n    'ac-3': {\r\n        lossy: true,\r\n        format: 'AC-3'\r\n    },\r\n    mp4a: {\r\n        lossy: true,\r\n        format: 'MPEG-4/AAC'\r\n    },\r\n    mp4s: {\r\n        lossy: true,\r\n        format: 'MP4S'\r\n    },\r\n    // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\r\n    c608: {\r\n        lossy: true,\r\n        format: 'CEA-608'\r\n    },\r\n    c708: {\r\n        lossy: true,\r\n        format: 'CEA-708'\r\n    }\r\n};\r\nfunction distinct(value, index, self) {\r\n    return self.indexOf(value) === index;\r\n}\r\n/*\r\n * Parser for the MP4 (MPEG-4 Part 14) container format\r\n * Standard: ISO/IEC 14496-14\r\n * supporting:\r\n * - QuickTime container\r\n * - MP4 File Format\r\n * - 3GPP file format\r\n * - 3GPP2 file format\r\n *\r\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\r\n * Support for Apple iTunes tags as found in a M4A/M4V files.\r\n * Ref:\r\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\r\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\r\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\r\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\r\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\r\n */\r\nclass MP4Parser extends BasicParser_1.BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.atomParsers = {\r\n            /**\r\n             * Parse movie header (mvhd) atom\r\n             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\r\n             */\r\n            mvhd: async (len) => {\r\n                const _mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));\r\n                this.metadata.setFormat('creationTime', _mvhd.creationTime);\r\n                this.metadata.setFormat('modificationTime', _mvhd.modificationTime);\r\n            },\r\n            /**\r\n             * Parse media header (mdhd) atom\r\n             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615\r\n             */\r\n            mdhd: async (len) => {\r\n                const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(len));\r\n                // this.parse_mxhd(mdhd_data, this.currentTrack);\r\n                const td = this.getTrackDescription();\r\n                td.creationTime = mdhd_data.creationTime;\r\n                td.modificationTime = mdhd_data.modificationTime;\r\n                td.timeScale = mdhd_data.timeScale;\r\n                td.duration = mdhd_data.duration;\r\n            },\r\n            chap: async (len) => {\r\n                const td = this.getTrackDescription();\r\n                const trackIds = [];\r\n                while (len >= Token.UINT32_BE.len) {\r\n                    trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\r\n                    len -= Token.UINT32_BE.len;\r\n                }\r\n                td.chapterList = trackIds;\r\n            },\r\n            tkhd: async (len) => {\r\n                const track = (await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len)));\r\n                this.tracks.push(track);\r\n            },\r\n            /**\r\n             * Parse mdat atom.\r\n             * Will scan for chapters\r\n             */\r\n            mdat: async (len) => {\r\n                this.audioLengthInBytes = len;\r\n                this.calculateBitRate();\r\n                if (this.options.includeChapters) {\r\n                    const trackWithChapters = this.tracks.filter(track => track.chapterList);\r\n                    if (trackWithChapters.length === 1) {\r\n                        const chapterTrackIds = trackWithChapters[0].chapterList;\r\n                        const chapterTracks = this.tracks.filter(track => chapterTrackIds.indexOf(track.trackId) !== -1);\r\n                        if (chapterTracks.length === 1) {\r\n                            return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\r\n                        }\r\n                    }\r\n                }\r\n                await this.tokenizer.ignore(len);\r\n            },\r\n            ftyp: async (len) => {\r\n                const types = [];\r\n                while (len > 0) {\r\n                    const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\r\n                    len -= AtomToken.ftyp.len;\r\n                    const value = ftype.type.replace(/\\W/g, '');\r\n                    if (value.length > 0) {\r\n                        types.push(value); // unshift for backward compatibility\r\n                    }\r\n                }\r\n                debug(`ftyp: ${types.join('/')}`);\r\n                const x = types.filter(distinct).join('/');\r\n                this.metadata.setFormat('container', x);\r\n            },\r\n            /**\r\n             * Parse sample description atom\r\n             */\r\n            stsd: async (len) => {\r\n                const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\r\n                const trackDescription = this.getTrackDescription();\r\n                trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\r\n            },\r\n            /**\r\n             * sample-to-Chunk Atoms\r\n             */\r\n            stsc: async (len) => {\r\n                const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(len));\r\n                this.getTrackDescription().sampleToChunkTable = stsc.entries;\r\n            },\r\n            /**\r\n             * time to sample\r\n             */\r\n            stts: async (len) => {\r\n                const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(len));\r\n                this.getTrackDescription().timeToSampleTable = stts.entries;\r\n            },\r\n            /**\r\n             * Parse sample-sizes atom ('stsz')\r\n             */\r\n            stsz: async (len) => {\r\n                const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\r\n                const td = this.getTrackDescription();\r\n                td.sampleSize = stsz.sampleSize;\r\n                td.sampleSizeTable = stsz.entries;\r\n            },\r\n            /**\r\n             * Parse chunk-offset atom ('stco')\r\n             */\r\n            stco: async (len) => {\r\n                const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(len));\r\n                this.getTrackDescription().chunkOffsetTable = stco.entries; // remember chunk offsets\r\n            },\r\n            date: async (len) => {\r\n                const date = await this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));\r\n                this.addTag('date', date);\r\n            }\r\n        };\r\n    }\r\n    static read_BE_Signed_Integer(value) {\r\n        return Token.readIntBE(value, 0, value.length);\r\n    }\r\n    static read_BE_Unsigned_Integer(value) {\r\n        return Token.readUIntBE(value, 0, value.length);\r\n    }\r\n    async parse() {\r\n        this.tracks = [];\r\n        let remainingFileSize = this.tokenizer.fileInfo.size;\r\n        while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\r\n            try {\r\n                const token = await this.tokenizer.peekToken(AtomToken.Header);\r\n                if (token.name === '\\0\\0\\0\\0') {\r\n                    const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\r\n                    debug(errMsg);\r\n                    this.addWarning(errMsg);\r\n                    break;\r\n                }\r\n            }\r\n            catch (error) {\r\n                const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\r\n                debug(errMsg);\r\n                this.addWarning(errMsg);\r\n                break;\r\n            }\r\n            const rootAtom = await Atom_1.Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);\r\n            remainingFileSize -= rootAtom.header.length === 0 ? remainingFileSize : rootAtom.header.length;\r\n        }\r\n        // Post process metadata\r\n        const formatList = [];\r\n        this.tracks.forEach(track => {\r\n            const trackFormats = [];\r\n            track.soundSampleDescription.forEach(ssd => {\r\n                const streamInfo = {};\r\n                const encoderInfo = encoderDict[ssd.dataFormat];\r\n                if (encoderInfo) {\r\n                    trackFormats.push(encoderInfo.format);\r\n                    streamInfo.codecName = encoderInfo.format;\r\n                }\r\n                else {\r\n                    streamInfo.codecName = `<${ssd.dataFormat}>`;\r\n                }\r\n                if (ssd.description) {\r\n                    const { description } = ssd;\r\n                    if (description.sampleRate > 0) {\r\n                        streamInfo.type = type_1.TrackType.audio;\r\n                        streamInfo.audio = {\r\n                            samplingFrequency: description.sampleRate,\r\n                            bitDepth: description.sampleSize,\r\n                            channels: description.numAudioChannels\r\n                        };\r\n                    }\r\n                }\r\n                this.metadata.addStreamInfo(streamInfo);\r\n            });\r\n            if (trackFormats.length >= 1) {\r\n                formatList.push(trackFormats.join('/'));\r\n            }\r\n        });\r\n        if (formatList.length > 0) {\r\n            this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\r\n        }\r\n        const audioTracks = this.tracks.filter(track => {\r\n            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;\r\n        });\r\n        if (audioTracks.length >= 1) {\r\n            const audioTrack = audioTracks[0];\r\n            const duration = audioTrack.duration / audioTrack.timeScale;\r\n            this.metadata.setFormat('duration', duration); // calculate duration in seconds\r\n            const ssd = audioTrack.soundSampleDescription[0];\r\n            if (ssd.description) {\r\n                this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\r\n                this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\r\n                this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\r\n            }\r\n            const encoderInfo = encoderDict[ssd.dataFormat];\r\n            if (encoderInfo) {\r\n                this.metadata.setFormat('lossless', !encoderInfo.lossy);\r\n            }\r\n            this.calculateBitRate();\r\n        }\r\n    }\r\n    async handleAtom(atom, remaining) {\r\n        if (atom.parent) {\r\n            switch (atom.parent.header.name) {\r\n                case 'ilst':\r\n                case '<id>':\r\n                    return this.parseMetadataItemData(atom);\r\n            }\r\n        }\r\n        // const payloadLength = atom.getPayloadLength(remaining);\r\n        if (this.atomParsers[atom.header.name]) {\r\n            return this.atomParsers[atom.header.name](remaining);\r\n        }\r\n        else {\r\n            debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);\r\n            await this.tokenizer.ignore(remaining);\r\n        }\r\n    }\r\n    getTrackDescription() {\r\n        return this.tracks[this.tracks.length - 1];\r\n    }\r\n    calculateBitRate() {\r\n        if (this.audioLengthInBytes && this.metadata.format.duration) {\r\n            this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);\r\n        }\r\n    }\r\n    addTag(id, value) {\r\n        this.metadata.addTag(tagFormat, id, value);\r\n    }\r\n    addWarning(message) {\r\n        debug('Warning: ' + message);\r\n        this.metadata.addWarning(message);\r\n    }\r\n    /**\r\n     * Parse data of Meta-item-list-atom (item of 'ilst' atom)\r\n     * @param metaAtom\r\n     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\r\n     */\r\n    parseMetadataItemData(metaAtom) {\r\n        let tagKey = metaAtom.header.name;\r\n        return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {\r\n            const payLoadLength = child.getPayloadLength(remaining);\r\n            switch (child.header.name) {\r\n                case 'data': // value atom\r\n                    return this.parseValueAtom(tagKey, child);\r\n                case 'name': // name atom (optional)\r\n                    const name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\r\n                    tagKey += ':' + name.name;\r\n                    break;\r\n                case 'mean': // name atom (optional)\r\n                    const mean = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\r\n                    // console.log(\"  %s[%s] = %s\", tagKey, header.name, mean.name);\r\n                    tagKey += ':' + mean.name;\r\n                    break;\r\n                default:\r\n                    const dataAtom = await this.tokenizer.readToken(new Token.BufferType(payLoadLength));\r\n                    this.addWarning('Unsupported meta-item: ' + tagKey + '[' + child.header.name + '] => value=' + dataAtom.toString('hex') + ' ascii=' + dataAtom.toString('ascii'));\r\n            }\r\n        }, metaAtom.getPayloadLength(0));\r\n    }\r\n    async parseValueAtom(tagKey, metaAtom) {\r\n        const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(metaAtom.header.length - AtomToken.Header.len));\r\n        if (dataAtom.type.set !== 0) {\r\n            throw new Error('Unsupported type-set != 0: ' + dataAtom.type.set);\r\n        }\r\n        // Use well-known-type table\r\n        // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\r\n        switch (dataAtom.type.type) {\r\n            case 0: // reserved: Reserved for use where no type needs to be indicated\r\n                switch (tagKey) {\r\n                    case 'trkn':\r\n                    case 'disk':\r\n                        const num = Token.UINT8.get(dataAtom.value, 3);\r\n                        const of = Token.UINT8.get(dataAtom.value, 5);\r\n                        // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\r\n                        this.addTag(tagKey, num + '/' + of);\r\n                        break;\r\n                    case 'gnre':\r\n                        const genreInt = Token.UINT8.get(dataAtom.value, 1);\r\n                        const genreStr = ID3v1Parser_1.Genres[genreInt - 1];\r\n                        // console.log(\"  %s[data] = %s\", tagKey, genreStr);\r\n                        this.addTag(tagKey, genreStr);\r\n                        break;\r\n                    default:\r\n                    // console.log(\"  reserved-data: name=%s, len=%s, set=%s, type=%s, locale=%s, value{ hex=%s, ascii=%s }\",\r\n                    // header.name, header.length, dataAtom.type.set, dataAtom.type.type, dataAtom.locale, dataAtom.value.toString('hex'), dataAtom.value.toString('ascii'));\r\n                }\r\n                break;\r\n            case 1: // UTF-8: Without any count or NULL terminator\r\n            case 18: // Unknown: Found in m4b in combination with a '©gen' tag\r\n                this.addTag(tagKey, dataAtom.value.toString('utf-8'));\r\n                break;\r\n            case 13: // JPEG\r\n                if (this.options.skipCovers)\r\n                    break;\r\n                this.addTag(tagKey, {\r\n                    format: 'image/jpeg',\r\n                    data: Buffer.from(dataAtom.value)\r\n                });\r\n                break;\r\n            case 14: // PNG\r\n                if (this.options.skipCovers)\r\n                    break;\r\n                this.addTag(tagKey, {\r\n                    format: 'image/png',\r\n                    data: Buffer.from(dataAtom.value)\r\n                });\r\n                break;\r\n            case 21: // BE Signed Integer\r\n                this.addTag(tagKey, MP4Parser.read_BE_Signed_Integer(dataAtom.value));\r\n                break;\r\n            case 22: // BE Unsigned Integer\r\n                this.addTag(tagKey, MP4Parser.read_BE_Unsigned_Integer(dataAtom.value));\r\n                break;\r\n            case 65: // An 8-bit signed integer\r\n                this.addTag(tagKey, dataAtom.value.readInt8(0));\r\n                break;\r\n            case 66: // A big-endian 16-bit signed integer\r\n                this.addTag(tagKey, dataAtom.value.readInt16BE(0));\r\n                break;\r\n            case 67: // A big-endian 32-bit signed integer\r\n                this.addTag(tagKey, dataAtom.value.readInt32BE(0));\r\n                break;\r\n            default:\r\n                this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\r\n        }\r\n    }\r\n    /**\r\n     * @param sampleDescription\r\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\r\n     */\r\n    parseSoundSampleDescription(sampleDescription) {\r\n        const ssd = {\r\n            dataFormat: sampleDescription.dataFormat,\r\n            dataReferenceIndex: sampleDescription.dataReferenceIndex\r\n        };\r\n        let offset = 0;\r\n        const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\r\n        offset += AtomToken.SoundSampleDescriptionVersion.len;\r\n        if (version.version === 0 || version.version === 1) {\r\n            // Sound Sample Description (Version 0)\r\n            ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\r\n        }\r\n        else {\r\n            debug(`Warning: sound-sample-description ${version} not implemented`);\r\n        }\r\n        return ssd;\r\n    }\r\n    async parseChapterTrack(chapterTrack, track, len) {\r\n        if (!chapterTrack.sampleSize) {\r\n            if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)\r\n                throw new Error('Expected equal chunk-offset-table & sample-size-table length.');\r\n        }\r\n        const chapters = [];\r\n        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\r\n            const chunkOffset = chapterTrack.chunkOffsetTable[i];\r\n            const nextChunkLen = chunkOffset - this.tokenizer.position;\r\n            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\r\n            len -= nextChunkLen + sampleSize;\r\n            if (len < 0)\r\n                throw new Error('Chapter chunk exceeding token length');\r\n            await this.tokenizer.ignore(nextChunkLen);\r\n            const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\r\n            debug(`Chapter ${i + 1}: ${title}`);\r\n            const chapter = {\r\n                title,\r\n                sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\r\n            };\r\n            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`);\r\n            chapters.push(chapter);\r\n        }\r\n        this.metadata.setFormat('chapters', chapters);\r\n        await this.tokenizer.ignore(len);\r\n    }\r\n    findSampleOffset(track, chapterOffset) {\r\n        let totalDuration = 0;\r\n        track.timeToSampleTable.forEach(e => {\r\n            totalDuration += e.count * e.duration;\r\n        });\r\n        debug(`Total duration=${totalDuration}`);\r\n        let chunkIndex = 0;\r\n        while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\r\n            ++chunkIndex;\r\n        }\r\n        return this.getChunkDuration(chunkIndex + 1, track);\r\n    }\r\n    getChunkDuration(chunkId, track) {\r\n        let ttsi = 0;\r\n        let ttsc = track.timeToSampleTable[ttsi].count;\r\n        let ttsd = track.timeToSampleTable[ttsi].duration;\r\n        let curChunkId = 1;\r\n        let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\r\n        let totalDuration = 0;\r\n        while (curChunkId < chunkId) {\r\n            const nrOfSamples = Math.min(ttsc, samplesPerChunk);\r\n            totalDuration += nrOfSamples * ttsd;\r\n            ttsc -= nrOfSamples;\r\n            samplesPerChunk -= nrOfSamples;\r\n            if (samplesPerChunk === 0) {\r\n                ++curChunkId;\r\n                samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\r\n            }\r\n            else {\r\n                ++ttsi;\r\n                ttsc = track.timeToSampleTable[ttsi].count;\r\n                ttsd = track.timeToSampleTable[ttsi].duration;\r\n            }\r\n        }\r\n        return totalDuration;\r\n    }\r\n    getSamplesPerChunk(chunkId, stcTable) {\r\n        for (let i = 0; i < stcTable.length - 1; ++i) {\r\n            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\r\n                return stcTable[i].samplesPerChunk;\r\n            }\r\n        }\r\n        return stcTable[stcTable.length - 1].samplesPerChunk;\r\n    }\r\n}\r\nexports.MP4Parser = MP4Parser;\r\n"]},"metadata":{},"sourceType":"script"}