{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MP4Parser = void 0;\n\nvar initDebug = require(\"debug\");\n\nvar Token = require(\"token-types\");\n\nvar BasicParser_1 = require(\"../common/BasicParser\");\n\nvar Atom_1 = require(\"./Atom\");\n\nvar AtomToken = require(\"./AtomToken\");\n\nvar ID3v1Parser_1 = require(\"../id3v1/ID3v1Parser\");\n\nvar type_1 = require(\"../type\");\n\nvar debug = initDebug('music-metadata:parser:MP4');\nvar tagFormat = 'iTunes';\nvar encoderDict = {\n  raw: {\n    lossy: false,\n    format: 'raw'\n  },\n  MAC3: {\n    lossy: true,\n    format: 'MACE 3:1'\n  },\n  MAC6: {\n    lossy: true,\n    format: 'MACE 6:1'\n  },\n  ima4: {\n    lossy: true,\n    format: 'IMA 4:1'\n  },\n  ulaw: {\n    lossy: true,\n    format: 'uLaw 2:1'\n  },\n  alaw: {\n    lossy: true,\n    format: 'uLaw 2:1'\n  },\n  Qclp: {\n    lossy: true,\n    format: 'QUALCOMM PureVoice'\n  },\n  '.mp3': {\n    lossy: true,\n    format: 'MPEG-1 layer 3'\n  },\n  alac: {\n    lossy: false,\n    format: 'ALAC'\n  },\n  'ac-3': {\n    lossy: true,\n    format: 'AC-3'\n  },\n  mp4a: {\n    lossy: true,\n    format: 'MPEG-4/AAC'\n  },\n  mp4s: {\n    lossy: true,\n    format: 'MP4S'\n  },\n  // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\n  c608: {\n    lossy: true,\n    format: 'CEA-608'\n  },\n  c708: {\n    lossy: true,\n    format: 'CEA-708'\n  }\n};\n\nfunction distinct(value, index, self) {\n  return self.indexOf(value) === index;\n}\n/*\r\n * Parser for the MP4 (MPEG-4 Part 14) container format\r\n * Standard: ISO/IEC 14496-14\r\n * supporting:\r\n * - QuickTime container\r\n * - MP4 File Format\r\n * - 3GPP file format\r\n * - 3GPP2 file format\r\n *\r\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\r\n * Support for Apple iTunes tags as found in a M4A/M4V files.\r\n * Ref:\r\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\r\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\r\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\r\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\r\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\r\n */\n\n\nvar MP4Parser = /*#__PURE__*/function (_BasicParser_1$BasicP) {\n  _inherits(MP4Parser, _BasicParser_1$BasicP);\n\n  var _super = _createSuper(MP4Parser);\n\n  function MP4Parser() {\n    var _this;\n\n    _classCallCheck(this, MP4Parser);\n\n    _this = _super.apply(this, arguments);\n    _this.atomParsers = {\n      /**\r\n       * Parse movie header (mvhd) atom\r\n       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\r\n       */\n      mvhd: function () {\n        var _mvhd2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(len) {\n          var _mvhd;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return _this.tokenizer.readToken(new AtomToken.MvhdAtom(len));\n\n                case 2:\n                  _mvhd = _context.sent;\n\n                  _this.metadata.setFormat('creationTime', _mvhd.creationTime);\n\n                  _this.metadata.setFormat('modificationTime', _mvhd.modificationTime);\n\n                case 5:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        function mvhd(_x) {\n          return _mvhd2.apply(this, arguments);\n        }\n\n        return mvhd;\n      }(),\n\n      /**\r\n       * Parse media header (mdhd) atom\r\n       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615\r\n       */\n      mdhd: function () {\n        var _mdhd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(len) {\n          var mdhd_data, td;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return _this.tokenizer.readToken(new AtomToken.MdhdAtom(len));\n\n                case 2:\n                  mdhd_data = _context2.sent;\n                  // this.parse_mxhd(mdhd_data, this.currentTrack);\n                  td = _this.getTrackDescription();\n                  td.creationTime = mdhd_data.creationTime;\n                  td.modificationTime = mdhd_data.modificationTime;\n                  td.timeScale = mdhd_data.timeScale;\n                  td.duration = mdhd_data.duration;\n\n                case 8:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        function mdhd(_x2) {\n          return _mdhd.apply(this, arguments);\n        }\n\n        return mdhd;\n      }(),\n      chap: function () {\n        var _chap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(len) {\n          var td, trackIds;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  td = _this.getTrackDescription();\n                  trackIds = [];\n\n                case 2:\n                  if (!(len >= Token.UINT32_BE.len)) {\n                    _context3.next = 11;\n                    break;\n                  }\n\n                  _context3.t0 = trackIds;\n                  _context3.next = 6;\n                  return _this.tokenizer.readNumber(Token.UINT32_BE);\n\n                case 6:\n                  _context3.t1 = _context3.sent;\n\n                  _context3.t0.push.call(_context3.t0, _context3.t1);\n\n                  len -= Token.UINT32_BE.len;\n                  _context3.next = 2;\n                  break;\n\n                case 11:\n                  td.chapterList = trackIds;\n\n                case 12:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n\n        function chap(_x3) {\n          return _chap.apply(this, arguments);\n        }\n\n        return chap;\n      }(),\n      tkhd: function () {\n        var _tkhd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(len) {\n          var track;\n          return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return _this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len));\n\n                case 2:\n                  track = _context4.sent;\n\n                  _this.tracks.push(track);\n\n                case 4:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4);\n        }));\n\n        function tkhd(_x4) {\n          return _tkhd.apply(this, arguments);\n        }\n\n        return tkhd;\n      }(),\n\n      /**\r\n       * Parse mdat atom.\r\n       * Will scan for chapters\r\n       */\n      mdat: function () {\n        var _mdat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(len) {\n          var trackWithChapters, chapterTrackIds, chapterTracks;\n          return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  _this.audioLengthInBytes = len;\n\n                  _this.calculateBitRate();\n\n                  if (!_this.options.includeChapters) {\n                    _context5.next = 9;\n                    break;\n                  }\n\n                  trackWithChapters = _this.tracks.filter(function (track) {\n                    return track.chapterList;\n                  });\n\n                  if (!(trackWithChapters.length === 1)) {\n                    _context5.next = 9;\n                    break;\n                  }\n\n                  chapterTrackIds = trackWithChapters[0].chapterList;\n                  chapterTracks = _this.tracks.filter(function (track) {\n                    return chapterTrackIds.indexOf(track.trackId) !== -1;\n                  });\n\n                  if (!(chapterTracks.length === 1)) {\n                    _context5.next = 9;\n                    break;\n                  }\n\n                  return _context5.abrupt(\"return\", _this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len));\n\n                case 9:\n                  _context5.next = 11;\n                  return _this.tokenizer.ignore(len);\n\n                case 11:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5);\n        }));\n\n        function mdat(_x5) {\n          return _mdat.apply(this, arguments);\n        }\n\n        return mdat;\n      }(),\n      ftyp: function () {\n        var _ftyp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(len) {\n          var types, ftype, value, x;\n          return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  types = [];\n\n                case 1:\n                  if (!(len > 0)) {\n                    _context6.next = 10;\n                    break;\n                  }\n\n                  _context6.next = 4;\n                  return _this.tokenizer.readToken(AtomToken.ftyp);\n\n                case 4:\n                  ftype = _context6.sent;\n                  len -= AtomToken.ftyp.len;\n                  value = ftype.type.replace(/\\W/g, '');\n\n                  if (value.length > 0) {\n                    types.push(value); // unshift for backward compatibility\n                  }\n\n                  _context6.next = 1;\n                  break;\n\n                case 10:\n                  debug(\"ftyp: \".concat(types.join('/')));\n                  x = types.filter(distinct).join('/');\n\n                  _this.metadata.setFormat('container', x);\n\n                case 13:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6);\n        }));\n\n        function ftyp(_x6) {\n          return _ftyp.apply(this, arguments);\n        }\n\n        return ftyp;\n      }(),\n\n      /**\r\n       * Parse sample description atom\r\n       */\n      stsd: function () {\n        var _stsd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(len) {\n          var stsd, trackDescription;\n          return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  _context7.next = 2;\n                  return _this.tokenizer.readToken(new AtomToken.StsdAtom(len));\n\n                case 2:\n                  stsd = _context7.sent;\n                  trackDescription = _this.getTrackDescription();\n                  trackDescription.soundSampleDescription = stsd.table.map(function (dfEntry) {\n                    return _this.parseSoundSampleDescription(dfEntry);\n                  });\n\n                case 5:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee7);\n        }));\n\n        function stsd(_x7) {\n          return _stsd.apply(this, arguments);\n        }\n\n        return stsd;\n      }(),\n\n      /**\r\n       * sample-to-Chunk Atoms\r\n       */\n      stsc: function () {\n        var _stsc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(len) {\n          var stsc;\n          return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n            while (1) {\n              switch (_context8.prev = _context8.next) {\n                case 0:\n                  _context8.next = 2;\n                  return _this.tokenizer.readToken(new AtomToken.StscAtom(len));\n\n                case 2:\n                  stsc = _context8.sent;\n                  _this.getTrackDescription().sampleToChunkTable = stsc.entries;\n\n                case 4:\n                case \"end\":\n                  return _context8.stop();\n              }\n            }\n          }, _callee8);\n        }));\n\n        function stsc(_x8) {\n          return _stsc.apply(this, arguments);\n        }\n\n        return stsc;\n      }(),\n\n      /**\r\n       * time to sample\r\n       */\n      stts: function () {\n        var _stts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(len) {\n          var stts;\n          return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n            while (1) {\n              switch (_context9.prev = _context9.next) {\n                case 0:\n                  _context9.next = 2;\n                  return _this.tokenizer.readToken(new AtomToken.SttsAtom(len));\n\n                case 2:\n                  stts = _context9.sent;\n                  _this.getTrackDescription().timeToSampleTable = stts.entries;\n\n                case 4:\n                case \"end\":\n                  return _context9.stop();\n              }\n            }\n          }, _callee9);\n        }));\n\n        function stts(_x9) {\n          return _stts.apply(this, arguments);\n        }\n\n        return stts;\n      }(),\n\n      /**\r\n       * Parse sample-sizes atom ('stsz')\r\n       */\n      stsz: function () {\n        var _stsz = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(len) {\n          var stsz, td;\n          return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n            while (1) {\n              switch (_context10.prev = _context10.next) {\n                case 0:\n                  _context10.next = 2;\n                  return _this.tokenizer.readToken(new AtomToken.StszAtom(len));\n\n                case 2:\n                  stsz = _context10.sent;\n                  td = _this.getTrackDescription();\n                  td.sampleSize = stsz.sampleSize;\n                  td.sampleSizeTable = stsz.entries;\n\n                case 6:\n                case \"end\":\n                  return _context10.stop();\n              }\n            }\n          }, _callee10);\n        }));\n\n        function stsz(_x10) {\n          return _stsz.apply(this, arguments);\n        }\n\n        return stsz;\n      }(),\n\n      /**\r\n       * Parse chunk-offset atom ('stco')\r\n       */\n      stco: function () {\n        var _stco = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(len) {\n          var stco;\n          return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n            while (1) {\n              switch (_context11.prev = _context11.next) {\n                case 0:\n                  _context11.next = 2;\n                  return _this.tokenizer.readToken(new AtomToken.StcoAtom(len));\n\n                case 2:\n                  stco = _context11.sent;\n                  _this.getTrackDescription().chunkOffsetTable = stco.entries; // remember chunk offsets\n\n                case 4:\n                case \"end\":\n                  return _context11.stop();\n              }\n            }\n          }, _callee11);\n        }));\n\n        function stco(_x11) {\n          return _stco.apply(this, arguments);\n        }\n\n        return stco;\n      }(),\n      date: function () {\n        var _date = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(len) {\n          var date;\n          return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n            while (1) {\n              switch (_context12.prev = _context12.next) {\n                case 0:\n                  _context12.next = 2;\n                  return _this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));\n\n                case 2:\n                  date = _context12.sent;\n\n                  _this.addTag('date', date);\n\n                case 4:\n                case \"end\":\n                  return _context12.stop();\n              }\n            }\n          }, _callee12);\n        }));\n\n        function date(_x12) {\n          return _date.apply(this, arguments);\n        }\n\n        return date;\n      }()\n    };\n    return _this;\n  }\n\n  _createClass(MP4Parser, [{\n    key: \"parse\",\n    value: function () {\n      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var _this2 = this;\n\n        var remainingFileSize, token, errMsg, _errMsg, rootAtom, formatList, audioTracks, audioTrack, duration, ssd, encoderInfo;\n\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                this.tracks = [];\n                remainingFileSize = this.tokenizer.fileInfo.size;\n\n              case 2:\n                if (!(!this.tokenizer.fileInfo.size || remainingFileSize > 0)) {\n                  _context13.next = 26;\n                  break;\n                }\n\n                _context13.prev = 3;\n                _context13.next = 6;\n                return this.tokenizer.peekToken(AtomToken.Header);\n\n              case 6:\n                token = _context13.sent;\n\n                if (!(token.name === '\\0\\0\\0\\0')) {\n                  _context13.next = 12;\n                  break;\n                }\n\n                errMsg = \"Error at offset=\".concat(this.tokenizer.position, \": box.id=0\");\n                debug(errMsg);\n                this.addWarning(errMsg);\n                return _context13.abrupt(\"break\", 26);\n\n              case 12:\n                _context13.next = 20;\n                break;\n\n              case 14:\n                _context13.prev = 14;\n                _context13.t0 = _context13[\"catch\"](3);\n                _errMsg = \"Error at offset=\".concat(this.tokenizer.position, \": \").concat(_context13.t0.message);\n                debug(_errMsg);\n                this.addWarning(_errMsg);\n                return _context13.abrupt(\"break\", 26);\n\n              case 20:\n                _context13.next = 22;\n                return Atom_1.Atom.readAtom(this.tokenizer, function (atom, remaining) {\n                  return _this2.handleAtom(atom, remaining);\n                }, null, remainingFileSize);\n\n              case 22:\n                rootAtom = _context13.sent;\n                remainingFileSize -= rootAtom.header.length === 0 ? remainingFileSize : rootAtom.header.length;\n                _context13.next = 2;\n                break;\n\n              case 26:\n                // Post process metadata\n                formatList = [];\n                this.tracks.forEach(function (track) {\n                  var trackFormats = [];\n                  track.soundSampleDescription.forEach(function (ssd) {\n                    var streamInfo = {};\n                    var encoderInfo = encoderDict[ssd.dataFormat];\n\n                    if (encoderInfo) {\n                      trackFormats.push(encoderInfo.format);\n                      streamInfo.codecName = encoderInfo.format;\n                    } else {\n                      streamInfo.codecName = \"<\".concat(ssd.dataFormat, \">\");\n                    }\n\n                    if (ssd.description) {\n                      var description = ssd.description;\n\n                      if (description.sampleRate > 0) {\n                        streamInfo.type = type_1.TrackType.audio;\n                        streamInfo.audio = {\n                          samplingFrequency: description.sampleRate,\n                          bitDepth: description.sampleSize,\n                          channels: description.numAudioChannels\n                        };\n                      }\n                    }\n\n                    _this2.metadata.addStreamInfo(streamInfo);\n                  });\n\n                  if (trackFormats.length >= 1) {\n                    formatList.push(trackFormats.join('/'));\n                  }\n                });\n\n                if (formatList.length > 0) {\n                  this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\n                }\n\n                audioTracks = this.tracks.filter(function (track) {\n                  return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;\n                });\n\n                if (audioTracks.length >= 1) {\n                  audioTrack = audioTracks[0];\n                  duration = audioTrack.duration / audioTrack.timeScale;\n                  this.metadata.setFormat('duration', duration); // calculate duration in seconds\n\n                  ssd = audioTrack.soundSampleDescription[0];\n\n                  if (ssd.description) {\n                    this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\n                    this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\n                    this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\n                  }\n\n                  encoderInfo = encoderDict[ssd.dataFormat];\n\n                  if (encoderInfo) {\n                    this.metadata.setFormat('lossless', !encoderInfo.lossy);\n                  }\n\n                  this.calculateBitRate();\n                }\n\n              case 31:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[3, 14]]);\n      }));\n\n      function parse() {\n        return _parse.apply(this, arguments);\n      }\n\n      return parse;\n    }()\n  }, {\n    key: \"handleAtom\",\n    value: function () {\n      var _handleAtom = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(atom, remaining) {\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                if (!atom.parent) {\n                  _context14.next = 5;\n                  break;\n                }\n\n                _context14.t0 = atom.parent.header.name;\n                _context14.next = _context14.t0 === 'ilst' ? 4 : _context14.t0 === '<id>' ? 4 : 5;\n                break;\n\n              case 4:\n                return _context14.abrupt(\"return\", this.parseMetadataItemData(atom));\n\n              case 5:\n                if (!this.atomParsers[atom.header.name]) {\n                  _context14.next = 9;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", this.atomParsers[atom.header.name](remaining));\n\n              case 9:\n                debug(\"No parser for atom path=\".concat(atom.atomPath, \", payload-len=\").concat(remaining, \", ignoring atom\"));\n                _context14.next = 12;\n                return this.tokenizer.ignore(remaining);\n\n              case 12:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function handleAtom(_x13, _x14) {\n        return _handleAtom.apply(this, arguments);\n      }\n\n      return handleAtom;\n    }()\n  }, {\n    key: \"getTrackDescription\",\n    value: function getTrackDescription() {\n      return this.tracks[this.tracks.length - 1];\n    }\n  }, {\n    key: \"calculateBitRate\",\n    value: function calculateBitRate() {\n      if (this.audioLengthInBytes && this.metadata.format.duration) {\n        this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);\n      }\n    }\n  }, {\n    key: \"addTag\",\n    value: function addTag(id, value) {\n      this.metadata.addTag(tagFormat, id, value);\n    }\n  }, {\n    key: \"addWarning\",\n    value: function addWarning(message) {\n      debug('Warning: ' + message);\n      this.metadata.addWarning(message);\n    }\n    /**\r\n     * Parse data of Meta-item-list-atom (item of 'ilst' atom)\r\n     * @param metaAtom\r\n     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\r\n     */\n\n  }, {\n    key: \"parseMetadataItemData\",\n    value: function parseMetadataItemData(metaAtom) {\n      var _this3 = this;\n\n      var tagKey = metaAtom.header.name;\n      return metaAtom.readAtoms(this.tokenizer, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(child, remaining) {\n          var payLoadLength, name, mean, dataAtom;\n          return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n            while (1) {\n              switch (_context15.prev = _context15.next) {\n                case 0:\n                  payLoadLength = child.getPayloadLength(remaining);\n                  _context15.t0 = child.header.name;\n                  _context15.next = _context15.t0 === 'data' ? 4 : _context15.t0 === 'name' ? 5 : _context15.t0 === 'mean' ? 10 : 15;\n                  break;\n\n                case 4:\n                  return _context15.abrupt(\"return\", _this3.parseValueAtom(tagKey, child));\n\n                case 5:\n                  _context15.next = 7;\n                  return _this3.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\n\n                case 7:\n                  name = _context15.sent;\n                  tagKey += ':' + name.name;\n                  return _context15.abrupt(\"break\", 19);\n\n                case 10:\n                  _context15.next = 12;\n                  return _this3.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\n\n                case 12:\n                  mean = _context15.sent;\n                  // console.log(\"  %s[%s] = %s\", tagKey, header.name, mean.name);\n                  tagKey += ':' + mean.name;\n                  return _context15.abrupt(\"break\", 19);\n\n                case 15:\n                  _context15.next = 17;\n                  return _this3.tokenizer.readToken(new Token.BufferType(payLoadLength));\n\n                case 17:\n                  dataAtom = _context15.sent;\n\n                  _this3.addWarning('Unsupported meta-item: ' + tagKey + '[' + child.header.name + '] => value=' + dataAtom.toString('hex') + ' ascii=' + dataAtom.toString('ascii'));\n\n                case 19:\n                case \"end\":\n                  return _context15.stop();\n              }\n            }\n          }, _callee15);\n        }));\n\n        return function (_x15, _x16) {\n          return _ref.apply(this, arguments);\n        };\n      }(), metaAtom.getPayloadLength(0));\n    }\n  }, {\n    key: \"parseValueAtom\",\n    value: function () {\n      var _parseValueAtom = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(tagKey, metaAtom) {\n        var dataAtom, num, of, genreInt, genreStr;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.next = 2;\n                return this.tokenizer.readToken(new AtomToken.DataAtom(metaAtom.header.length - AtomToken.Header.len));\n\n              case 2:\n                dataAtom = _context16.sent;\n\n                if (!(dataAtom.type.set !== 0)) {\n                  _context16.next = 5;\n                  break;\n                }\n\n                throw new Error('Unsupported type-set != 0: ' + dataAtom.type.set);\n\n              case 5:\n                _context16.t0 = dataAtom.type.type;\n                _context16.next = _context16.t0 === 0 ? 8 : _context16.t0 === 1 ? 20 : _context16.t0 === 18 ? 20 : _context16.t0 === 13 ? 22 : _context16.t0 === 14 ? 26 : _context16.t0 === 21 ? 30 : _context16.t0 === 22 ? 32 : _context16.t0 === 65 ? 34 : _context16.t0 === 66 ? 36 : _context16.t0 === 67 ? 38 : 40;\n                break;\n\n              case 8:\n                _context16.t1 = tagKey;\n                _context16.next = _context16.t1 === 'trkn' ? 11 : _context16.t1 === 'disk' ? 11 : _context16.t1 === 'gnre' ? 15 : 19;\n                break;\n\n              case 11:\n                num = Token.UINT8.get(dataAtom.value, 3);\n                of = Token.UINT8.get(dataAtom.value, 5); // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\n\n                this.addTag(tagKey, num + '/' + of);\n                return _context16.abrupt(\"break\", 19);\n\n              case 15:\n                genreInt = Token.UINT8.get(dataAtom.value, 1);\n                genreStr = ID3v1Parser_1.Genres[genreInt - 1]; // console.log(\"  %s[data] = %s\", tagKey, genreStr);\n\n                this.addTag(tagKey, genreStr);\n                return _context16.abrupt(\"break\", 19);\n\n              case 19:\n                return _context16.abrupt(\"break\", 41);\n\n              case 20:\n                // Unknown: Found in m4b in combination with a '©gen' tag\n                this.addTag(tagKey, dataAtom.value.toString('utf-8'));\n                return _context16.abrupt(\"break\", 41);\n\n              case 22:\n                if (!this.options.skipCovers) {\n                  _context16.next = 24;\n                  break;\n                }\n\n                return _context16.abrupt(\"break\", 41);\n\n              case 24:\n                this.addTag(tagKey, {\n                  format: 'image/jpeg',\n                  data: Buffer.from(dataAtom.value)\n                });\n                return _context16.abrupt(\"break\", 41);\n\n              case 26:\n                if (!this.options.skipCovers) {\n                  _context16.next = 28;\n                  break;\n                }\n\n                return _context16.abrupt(\"break\", 41);\n\n              case 28:\n                this.addTag(tagKey, {\n                  format: 'image/png',\n                  data: Buffer.from(dataAtom.value)\n                });\n                return _context16.abrupt(\"break\", 41);\n\n              case 30:\n                // BE Signed Integer\n                this.addTag(tagKey, MP4Parser.read_BE_Signed_Integer(dataAtom.value));\n                return _context16.abrupt(\"break\", 41);\n\n              case 32:\n                // BE Unsigned Integer\n                this.addTag(tagKey, MP4Parser.read_BE_Unsigned_Integer(dataAtom.value));\n                return _context16.abrupt(\"break\", 41);\n\n              case 34:\n                // An 8-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt8(0));\n                return _context16.abrupt(\"break\", 41);\n\n              case 36:\n                // A big-endian 16-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt16BE(0));\n                return _context16.abrupt(\"break\", 41);\n\n              case 38:\n                // A big-endian 32-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt32BE(0));\n                return _context16.abrupt(\"break\", 41);\n\n              case 40:\n                this.addWarning(\"atom key=\".concat(tagKey, \", has unknown well-known-type (data-type): \").concat(dataAtom.type.type));\n\n              case 41:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function parseValueAtom(_x17, _x18) {\n        return _parseValueAtom.apply(this, arguments);\n      }\n\n      return parseValueAtom;\n    }()\n    /**\r\n     * @param sampleDescription\r\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\r\n     */\n\n  }, {\n    key: \"parseSoundSampleDescription\",\n    value: function parseSoundSampleDescription(sampleDescription) {\n      var ssd = {\n        dataFormat: sampleDescription.dataFormat,\n        dataReferenceIndex: sampleDescription.dataReferenceIndex\n      };\n      var offset = 0;\n      var version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\n      offset += AtomToken.SoundSampleDescriptionVersion.len;\n\n      if (version.version === 0 || version.version === 1) {\n        // Sound Sample Description (Version 0)\n        ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\n      } else {\n        debug(\"Warning: sound-sample-description \".concat(version, \" not implemented\"));\n      }\n\n      return ssd;\n    }\n  }, {\n    key: \"parseChapterTrack\",\n    value: function () {\n      var _parseChapterTrack = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(chapterTrack, track, len) {\n        var chapters, i, chunkOffset, nextChunkLen, sampleSize, title, chapter;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (chapterTrack.sampleSize) {\n                  _context17.next = 3;\n                  break;\n                }\n\n                if (!(chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)) {\n                  _context17.next = 3;\n                  break;\n                }\n\n                throw new Error('Expected equal chunk-offset-table & sample-size-table length.');\n\n              case 3:\n                chapters = [];\n                i = 0;\n\n              case 5:\n                if (!(i < chapterTrack.chunkOffsetTable.length && len > 0)) {\n                  _context17.next = 24;\n                  break;\n                }\n\n                chunkOffset = chapterTrack.chunkOffsetTable[i];\n                nextChunkLen = chunkOffset - this.tokenizer.position;\n                sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\n                len -= nextChunkLen + sampleSize;\n\n                if (!(len < 0)) {\n                  _context17.next = 12;\n                  break;\n                }\n\n                throw new Error('Chapter chunk exceeding token length');\n\n              case 12:\n                _context17.next = 14;\n                return this.tokenizer.ignore(nextChunkLen);\n\n              case 14:\n                _context17.next = 16;\n                return this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\n\n              case 16:\n                title = _context17.sent;\n                debug(\"Chapter \".concat(i + 1, \": \").concat(title));\n                chapter = {\n                  title: title,\n                  sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\n                };\n                debug(\"Chapter title=\".concat(chapter.title, \", offset=\").concat(chapter.sampleOffset, \"/\").concat(this.tracks[0].duration));\n                chapters.push(chapter);\n\n              case 21:\n                ++i;\n                _context17.next = 5;\n                break;\n\n              case 24:\n                this.metadata.setFormat('chapters', chapters);\n                _context17.next = 27;\n                return this.tokenizer.ignore(len);\n\n              case 27:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function parseChapterTrack(_x19, _x20, _x21) {\n        return _parseChapterTrack.apply(this, arguments);\n      }\n\n      return parseChapterTrack;\n    }()\n  }, {\n    key: \"findSampleOffset\",\n    value: function findSampleOffset(track, chapterOffset) {\n      var totalDuration = 0;\n      track.timeToSampleTable.forEach(function (e) {\n        totalDuration += e.count * e.duration;\n      });\n      debug(\"Total duration=\".concat(totalDuration));\n      var chunkIndex = 0;\n\n      while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\n        ++chunkIndex;\n      }\n\n      return this.getChunkDuration(chunkIndex + 1, track);\n    }\n  }, {\n    key: \"getChunkDuration\",\n    value: function getChunkDuration(chunkId, track) {\n      var ttsi = 0;\n      var ttsc = track.timeToSampleTable[ttsi].count;\n      var ttsd = track.timeToSampleTable[ttsi].duration;\n      var curChunkId = 1;\n      var samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n      var totalDuration = 0;\n\n      while (curChunkId < chunkId) {\n        var nrOfSamples = Math.min(ttsc, samplesPerChunk);\n        totalDuration += nrOfSamples * ttsd;\n        ttsc -= nrOfSamples;\n        samplesPerChunk -= nrOfSamples;\n\n        if (samplesPerChunk === 0) {\n          ++curChunkId;\n          samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n        } else {\n          ++ttsi;\n          ttsc = track.timeToSampleTable[ttsi].count;\n          ttsd = track.timeToSampleTable[ttsi].duration;\n        }\n      }\n\n      return totalDuration;\n    }\n  }, {\n    key: \"getSamplesPerChunk\",\n    value: function getSamplesPerChunk(chunkId, stcTable) {\n      for (var i = 0; i < stcTable.length - 1; ++i) {\n        if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\n          return stcTable[i].samplesPerChunk;\n        }\n      }\n\n      return stcTable[stcTable.length - 1].samplesPerChunk;\n    }\n  }], [{\n    key: \"read_BE_Signed_Integer\",\n    value: function read_BE_Signed_Integer(value) {\n      return Token.readIntBE(value, 0, value.length);\n    }\n  }, {\n    key: \"read_BE_Unsigned_Integer\",\n    value: function read_BE_Unsigned_Integer(value) {\n      return Token.readUIntBE(value, 0, value.length);\n    }\n  }]);\n\n  return MP4Parser;\n}(BasicParser_1.BasicParser);\n\nexports.MP4Parser = MP4Parser;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/mp4/MP4Parser.js"],"names":["Object","defineProperty","exports","value","MP4Parser","initDebug","require","Token","BasicParser_1","Atom_1","AtomToken","ID3v1Parser_1","type_1","debug","tagFormat","encoderDict","raw","lossy","format","MAC3","MAC6","ima4","ulaw","alaw","Qclp","alac","mp4a","mp4s","c608","c708","distinct","index","self","indexOf","arguments","atomParsers","mvhd","len","tokenizer","readToken","MvhdAtom","_mvhd","metadata","setFormat","creationTime","modificationTime","mdhd","MdhdAtom","mdhd_data","td","getTrackDescription","timeScale","duration","chap","trackIds","UINT32_BE","readNumber","push","chapterList","tkhd","TrackHeaderAtom","track","tracks","mdat","audioLengthInBytes","calculateBitRate","options","includeChapters","trackWithChapters","filter","length","chapterTrackIds","chapterTracks","trackId","parseChapterTrack","ignore","ftyp","types","ftype","type","replace","join","x","stsd","StsdAtom","trackDescription","soundSampleDescription","table","map","dfEntry","parseSoundSampleDescription","stsc","StscAtom","sampleToChunkTable","entries","stts","SttsAtom","timeToSampleTable","stsz","StszAtom","sampleSize","sampleSizeTable","stco","StcoAtom","chunkOffsetTable","date","StringType","addTag","remainingFileSize","fileInfo","size","peekToken","Header","token","name","errMsg","position","addWarning","message","Atom","readAtom","atom","remaining","handleAtom","rootAtom","header","formatList","forEach","trackFormats","ssd","streamInfo","encoderInfo","dataFormat","codecName","description","sampleRate","TrackType","audio","samplingFrequency","bitDepth","channels","numAudioChannels","addStreamInfo","audioTracks","audioTrack","parent","parseMetadataItemData","atomPath","id","metaAtom","tagKey","readAtoms","child","payLoadLength","getPayloadLength","parseValueAtom","NameAtom","mean","BufferType","dataAtom","toString","DataAtom","set","Error","num","UINT8","get","of","genreInt","genreStr","Genres","skipCovers","data","Buffer","from","read_BE_Signed_Integer","read_BE_Unsigned_Integer","readInt8","readInt16BE","readInt32BE","sampleDescription","dataReferenceIndex","offset","version","SoundSampleDescriptionVersion","SoundSampleDescriptionV0","chapterTrack","chapters","i","chunkOffset","nextChunkLen","ChapterText","title","chapter","sampleOffset","findSampleOffset","chapterOffset","totalDuration","e","count","chunkIndex","getChunkDuration","chunkId","ttsi","ttsc","ttsd","curChunkId","samplesPerChunk","getSamplesPerChunk","nrOfSamples","Math","min","stcTable","firstChunk","readIntBE","readUIntBE","BasicParser"],"mappings":"AAAA;;;;;;;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,SAAR,GAAoB,KAAK,CAAzB;;AACA,IAAMC,SAAS,GAAGC,OAAO,CAAC,OAAD,CAAzB;;AACA,IAAMC,KAAK,GAAGD,OAAO,CAAC,aAAD,CAArB;;AACA,IAAME,aAAa,GAAGF,OAAO,CAAC,uBAAD,CAA7B;;AACA,IAAMG,MAAM,GAAGH,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMI,SAAS,GAAGJ,OAAO,CAAC,aAAD,CAAzB;;AACA,IAAMK,aAAa,GAAGL,OAAO,CAAC,sBAAD,CAA7B;;AACA,IAAMM,MAAM,GAAGN,OAAO,CAAC,SAAD,CAAtB;;AACA,IAAMO,KAAK,GAAGR,SAAS,CAAC,2BAAD,CAAvB;AACA,IAAMS,SAAS,GAAG,QAAlB;AACA,IAAMC,WAAW,GAAG;AAChBC,EAAAA,GAAG,EAAE;AACDC,IAAAA,KAAK,EAAE,KADN;AAEDC,IAAAA,MAAM,EAAE;AAFP,GADW;AAKhBC,EAAAA,IAAI,EAAE;AACFF,IAAAA,KAAK,EAAE,IADL;AAEFC,IAAAA,MAAM,EAAE;AAFN,GALU;AAShBE,EAAAA,IAAI,EAAE;AACFH,IAAAA,KAAK,EAAE,IADL;AAEFC,IAAAA,MAAM,EAAE;AAFN,GATU;AAahBG,EAAAA,IAAI,EAAE;AACFJ,IAAAA,KAAK,EAAE,IADL;AAEFC,IAAAA,MAAM,EAAE;AAFN,GAbU;AAiBhBI,EAAAA,IAAI,EAAE;AACFL,IAAAA,KAAK,EAAE,IADL;AAEFC,IAAAA,MAAM,EAAE;AAFN,GAjBU;AAqBhBK,EAAAA,IAAI,EAAE;AACFN,IAAAA,KAAK,EAAE,IADL;AAEFC,IAAAA,MAAM,EAAE;AAFN,GArBU;AAyBhBM,EAAAA,IAAI,EAAE;AACFP,IAAAA,KAAK,EAAE,IADL;AAEFC,IAAAA,MAAM,EAAE;AAFN,GAzBU;AA6BhB,UAAQ;AACJD,IAAAA,KAAK,EAAE,IADH;AAEJC,IAAAA,MAAM,EAAE;AAFJ,GA7BQ;AAiChBO,EAAAA,IAAI,EAAE;AACFR,IAAAA,KAAK,EAAE,KADL;AAEFC,IAAAA,MAAM,EAAE;AAFN,GAjCU;AAqChB,UAAQ;AACJD,IAAAA,KAAK,EAAE,IADH;AAEJC,IAAAA,MAAM,EAAE;AAFJ,GArCQ;AAyChBQ,EAAAA,IAAI,EAAE;AACFT,IAAAA,KAAK,EAAE,IADL;AAEFC,IAAAA,MAAM,EAAE;AAFN,GAzCU;AA6ChBS,EAAAA,IAAI,EAAE;AACFV,IAAAA,KAAK,EAAE,IADL;AAEFC,IAAAA,MAAM,EAAE;AAFN,GA7CU;AAiDhB;AACAU,EAAAA,IAAI,EAAE;AACFX,IAAAA,KAAK,EAAE,IADL;AAEFC,IAAAA,MAAM,EAAE;AAFN,GAlDU;AAsDhBW,EAAAA,IAAI,EAAE;AACFZ,IAAAA,KAAK,EAAE,IADL;AAEFC,IAAAA,MAAM,EAAE;AAFN;AAtDU,CAApB;;AA2DA,SAASY,QAAT,CAAkB3B,KAAlB,EAAyB4B,KAAzB,EAAgCC,IAAhC,EAAsC;AAClC,SAAOA,IAAI,CAACC,OAAL,CAAa9B,KAAb,MAAwB4B,KAA/B;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACM3B,S;;;;;AACF,uBAAc;AAAA;;AAAA;;AACV,+BAAS8B,SAAT;AACA,UAAKC,WAAL,GAAmB;AACf;AACZ;AACA;AACA;AACYC,MAAAA,IAAI;AAAA,8EAAE,iBAAOC,GAAP;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBACkB,MAAKC,SAAL,CAAeC,SAAf,CAAyB,IAAI7B,SAAS,CAAC8B,QAAd,CAAuBH,GAAvB,CAAzB,CADlB;;AAAA;AACII,kBAAAA,KADJ;;AAEF,wBAAKC,QAAL,CAAcC,SAAd,CAAwB,cAAxB,EAAwCF,KAAK,CAACG,YAA9C;;AACA,wBAAKF,QAAL,CAAcC,SAAd,CAAwB,kBAAxB,EAA4CF,KAAK,CAACI,gBAAlD;;AAHE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SALW;;AAUf;AACZ;AACA;AACA;AACYC,MAAAA,IAAI;AAAA,6EAAE,kBAAOT,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBACsB,MAAKC,SAAL,CAAeC,SAAf,CAAyB,IAAI7B,SAAS,CAACqC,QAAd,CAAuBV,GAAvB,CAAzB,CADtB;;AAAA;AACIW,kBAAAA,SADJ;AAEF;AACMC,kBAAAA,EAHJ,GAGS,MAAKC,mBAAL,EAHT;AAIFD,kBAAAA,EAAE,CAACL,YAAH,GAAkBI,SAAS,CAACJ,YAA5B;AACAK,kBAAAA,EAAE,CAACJ,gBAAH,GAAsBG,SAAS,CAACH,gBAAhC;AACAI,kBAAAA,EAAE,CAACE,SAAH,GAAeH,SAAS,CAACG,SAAzB;AACAF,kBAAAA,EAAE,CAACG,QAAH,GAAcJ,SAAS,CAACI,QAAxB;;AAPE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SAdW;AAuBfC,MAAAA,IAAI;AAAA,6EAAE,kBAAOhB,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AACIY,kBAAAA,EADJ,GACS,MAAKC,mBAAL,EADT;AAEII,kBAAAA,QAFJ,GAEe,EAFf;;AAAA;AAAA,wBAGKjB,GAAG,IAAI9B,KAAK,CAACgD,SAAN,CAAgBlB,GAH5B;AAAA;AAAA;AAAA;;AAAA,iCAIEiB,QAJF;AAAA;AAAA,yBAIsB,MAAKhB,SAAL,CAAekB,UAAf,CAA0BjD,KAAK,CAACgD,SAAhC,CAJtB;;AAAA;AAAA;;AAAA,+BAIWE,IAJX;;AAKEpB,kBAAAA,GAAG,IAAI9B,KAAK,CAACgD,SAAN,CAAgBlB,GAAvB;AALF;AAAA;;AAAA;AAOFY,kBAAAA,EAAE,CAACS,WAAH,GAAiBJ,QAAjB;;AAPE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SAvBW;AAgCfK,MAAAA,IAAI;AAAA,6EAAE,kBAAOtB,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBACmB,MAAKC,SAAL,CAAeC,SAAf,CAAyB,IAAI7B,SAAS,CAACkD,eAAd,CAA8BvB,GAA9B,CAAzB,CADnB;;AAAA;AACIwB,kBAAAA,KADJ;;AAEF,wBAAKC,MAAL,CAAYL,IAAZ,CAAiBI,KAAjB;;AAFE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SAhCW;;AAoCf;AACZ;AACA;AACA;AACYE,MAAAA,IAAI;AAAA,6EAAE,kBAAO1B,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AACF,wBAAK2B,kBAAL,GAA0B3B,GAA1B;;AACA,wBAAK4B,gBAAL;;AAFE,uBAGE,MAAKC,OAAL,CAAaC,eAHf;AAAA;AAAA;AAAA;;AAIQC,kBAAAA,iBAJR,GAI4B,MAAKN,MAAL,CAAYO,MAAZ,CAAmB,UAAAR,KAAK;AAAA,2BAAIA,KAAK,CAACH,WAAV;AAAA,mBAAxB,CAJ5B;;AAAA,wBAKMU,iBAAiB,CAACE,MAAlB,KAA6B,CALnC;AAAA;AAAA;AAAA;;AAMYC,kBAAAA,eANZ,GAM8BH,iBAAiB,CAAC,CAAD,CAAjB,CAAqBV,WANnD;AAOYc,kBAAAA,aAPZ,GAO4B,MAAKV,MAAL,CAAYO,MAAZ,CAAmB,UAAAR,KAAK;AAAA,2BAAIU,eAAe,CAACtC,OAAhB,CAAwB4B,KAAK,CAACY,OAA9B,MAA2C,CAAC,CAAhD;AAAA,mBAAxB,CAP5B;;AAAA,wBAQUD,aAAa,CAACF,MAAd,KAAyB,CARnC;AAAA;AAAA;AAAA;;AAAA,oDASiB,MAAKI,iBAAL,CAAuBF,aAAa,CAAC,CAAD,CAApC,EAAyCJ,iBAAiB,CAAC,CAAD,CAA1D,EAA+D/B,GAA/D,CATjB;;AAAA;AAAA;AAAA,yBAaI,MAAKC,SAAL,CAAeqC,MAAf,CAAsBtC,GAAtB,CAbJ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SAxCW;AAuDfuC,MAAAA,IAAI;AAAA,6EAAE,kBAAOvC,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AACIwC,kBAAAA,KADJ,GACY,EADZ;;AAAA;AAAA,wBAEKxC,GAAG,GAAG,CAFX;AAAA;AAAA;AAAA;;AAAA;AAAA,yBAGsB,MAAKC,SAAL,CAAeC,SAAf,CAAyB7B,SAAS,CAACkE,IAAnC,CAHtB;;AAAA;AAGQE,kBAAAA,KAHR;AAIEzC,kBAAAA,GAAG,IAAI3B,SAAS,CAACkE,IAAV,CAAevC,GAAtB;AACMlC,kBAAAA,KALR,GAKgB2E,KAAK,CAACC,IAAN,CAAWC,OAAX,CAAmB,KAAnB,EAA0B,EAA1B,CALhB;;AAME,sBAAI7E,KAAK,CAACmE,MAAN,GAAe,CAAnB,EAAsB;AAClBO,oBAAAA,KAAK,CAACpB,IAAN,CAAWtD,KAAX,EADkB,CACC;AACtB;;AARH;AAAA;;AAAA;AAUFU,kBAAAA,KAAK,iBAAUgE,KAAK,CAACI,IAAN,CAAW,GAAX,CAAV,EAAL;AACMC,kBAAAA,CAXJ,GAWQL,KAAK,CAACR,MAAN,CAAavC,QAAb,EAAuBmD,IAAvB,CAA4B,GAA5B,CAXR;;AAYF,wBAAKvC,QAAL,CAAcC,SAAd,CAAwB,WAAxB,EAAqCuC,CAArC;;AAZE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SAvDW;;AAqEf;AACZ;AACA;AACYC,MAAAA,IAAI;AAAA,6EAAE,kBAAO9C,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBACiB,MAAKC,SAAL,CAAeC,SAAf,CAAyB,IAAI7B,SAAS,CAAC0E,QAAd,CAAuB/C,GAAvB,CAAzB,CADjB;;AAAA;AACI8C,kBAAAA,IADJ;AAEIE,kBAAAA,gBAFJ,GAEuB,MAAKnC,mBAAL,EAFvB;AAGFmC,kBAAAA,gBAAgB,CAACC,sBAAjB,GAA0CH,IAAI,CAACI,KAAL,CAAWC,GAAX,CAAe,UAAAC,OAAO;AAAA,2BAAI,MAAKC,2BAAL,CAAiCD,OAAjC,CAAJ;AAAA,mBAAtB,CAA1C;;AAHE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SAxEW;;AA6Ef;AACZ;AACA;AACYE,MAAAA,IAAI;AAAA,6EAAE,kBAAOtD,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBACiB,MAAKC,SAAL,CAAeC,SAAf,CAAyB,IAAI7B,SAAS,CAACkF,QAAd,CAAuBvD,GAAvB,CAAzB,CADjB;;AAAA;AACIsD,kBAAAA,IADJ;AAEF,wBAAKzC,mBAAL,GAA2B2C,kBAA3B,GAAgDF,IAAI,CAACG,OAArD;;AAFE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SAhFW;;AAoFf;AACZ;AACA;AACYC,MAAAA,IAAI;AAAA,6EAAE,kBAAO1D,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBACiB,MAAKC,SAAL,CAAeC,SAAf,CAAyB,IAAI7B,SAAS,CAACsF,QAAd,CAAuB3D,GAAvB,CAAzB,CADjB;;AAAA;AACI0D,kBAAAA,IADJ;AAEF,wBAAK7C,mBAAL,GAA2B+C,iBAA3B,GAA+CF,IAAI,CAACD,OAApD;;AAFE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SAvFW;;AA2Ff;AACZ;AACA;AACYI,MAAAA,IAAI;AAAA,6EAAE,mBAAO7D,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBACiB,MAAKC,SAAL,CAAeC,SAAf,CAAyB,IAAI7B,SAAS,CAACyF,QAAd,CAAuB9D,GAAvB,CAAzB,CADjB;;AAAA;AACI6D,kBAAAA,IADJ;AAEIjD,kBAAAA,EAFJ,GAES,MAAKC,mBAAL,EAFT;AAGFD,kBAAAA,EAAE,CAACmD,UAAH,GAAgBF,IAAI,CAACE,UAArB;AACAnD,kBAAAA,EAAE,CAACoD,eAAH,GAAqBH,IAAI,CAACJ,OAA1B;;AAJE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SA9FW;;AAoGf;AACZ;AACA;AACYQ,MAAAA,IAAI;AAAA,6EAAE,mBAAOjE,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBACiB,MAAKC,SAAL,CAAeC,SAAf,CAAyB,IAAI7B,SAAS,CAAC6F,QAAd,CAAuBlE,GAAvB,CAAzB,CADjB;;AAAA;AACIiE,kBAAAA,IADJ;AAEF,wBAAKpD,mBAAL,GAA2BsD,gBAA3B,GAA8CF,IAAI,CAACR,OAAnD,CAFE,CAE0D;;AAF1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SAvGW;AA2GfW,MAAAA,IAAI;AAAA,6EAAE,mBAAOpE,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBACiB,MAAKC,SAAL,CAAeC,SAAf,CAAyB,IAAIhC,KAAK,CAACmG,UAAV,CAAqBrE,GAArB,EAA0B,OAA1B,CAAzB,CADjB;;AAAA;AACIoE,kBAAAA,IADJ;;AAEF,wBAAKE,MAAL,CAAY,MAAZ,EAAoBF,IAApB;;AAFE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AA3GW,KAAnB;AAFU;AAkHb;;;;;4EAOD;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AACI,qBAAK3C,MAAL,GAAc,EAAd;AACI8C,gBAAAA,iBAFR,GAE4B,KAAKtE,SAAL,CAAeuE,QAAf,CAAwBC,IAFpD;;AAAA;AAAA,sBAGW,CAAC,KAAKxE,SAAL,CAAeuE,QAAf,CAAwBC,IAAzB,IAAiCF,iBAAiB,GAAG,CAHhE;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,uBAKgC,KAAKtE,SAAL,CAAeyE,SAAf,CAAyBrG,SAAS,CAACsG,MAAnC,CALhC;;AAAA;AAKkBC,gBAAAA,KALlB;;AAAA,sBAMgBA,KAAK,CAACC,IAAN,KAAe,UAN/B;AAAA;AAAA;AAAA;;AAOsBC,gBAAAA,MAPtB,6BAOkD,KAAK7E,SAAL,CAAe8E,QAPjE;AAQgBvG,gBAAAA,KAAK,CAACsG,MAAD,CAAL;AACA,qBAAKE,UAAL,CAAgBF,MAAhB;AAThB;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAckBA,gBAAAA,OAdlB,6BAc8C,KAAK7E,SAAL,CAAe8E,QAd7D,eAc0E,cAAME,OAdhF;AAeYzG,gBAAAA,KAAK,CAACsG,OAAD,CAAL;AACA,qBAAKE,UAAL,CAAgBF,OAAhB;AAhBZ;;AAAA;AAAA;AAAA,uBAmB+B1G,MAAM,CAAC8G,IAAP,CAAYC,QAAZ,CAAqB,KAAKlF,SAA1B,EAAqC,UAACmF,IAAD,EAAOC,SAAP;AAAA,yBAAqB,MAAI,CAACC,UAAL,CAAgBF,IAAhB,EAAsBC,SAAtB,CAArB;AAAA,iBAArC,EAA4F,IAA5F,EAAkGd,iBAAlG,CAnB/B;;AAAA;AAmBcgB,gBAAAA,QAnBd;AAoBQhB,gBAAAA,iBAAiB,IAAIgB,QAAQ,CAACC,MAAT,CAAgBvD,MAAhB,KAA2B,CAA3B,GAA+BsC,iBAA/B,GAAmDgB,QAAQ,CAACC,MAAT,CAAgBvD,MAAxF;AApBR;AAAA;;AAAA;AAsBI;AACMwD,gBAAAA,UAvBV,GAuBuB,EAvBvB;AAwBI,qBAAKhE,MAAL,CAAYiE,OAAZ,CAAoB,UAAAlE,KAAK,EAAI;AACzB,sBAAMmE,YAAY,GAAG,EAArB;AACAnE,kBAAAA,KAAK,CAACyB,sBAAN,CAA6ByC,OAA7B,CAAqC,UAAAE,GAAG,EAAI;AACxC,wBAAMC,UAAU,GAAG,EAAnB;AACA,wBAAMC,WAAW,GAAGpH,WAAW,CAACkH,GAAG,CAACG,UAAL,CAA/B;;AACA,wBAAID,WAAJ,EAAiB;AACbH,sBAAAA,YAAY,CAACvE,IAAb,CAAkB0E,WAAW,CAACjH,MAA9B;AACAgH,sBAAAA,UAAU,CAACG,SAAX,GAAuBF,WAAW,CAACjH,MAAnC;AACH,qBAHD,MAIK;AACDgH,sBAAAA,UAAU,CAACG,SAAX,cAA2BJ,GAAG,CAACG,UAA/B;AACH;;AACD,wBAAIH,GAAG,CAACK,WAAR,EAAqB;AACjB,0BAAQA,WAAR,GAAwBL,GAAxB,CAAQK,WAAR;;AACA,0BAAIA,WAAW,CAACC,UAAZ,GAAyB,CAA7B,EAAgC;AAC5BL,wBAAAA,UAAU,CAACnD,IAAX,GAAkBnE,MAAM,CAAC4H,SAAP,CAAiBC,KAAnC;AACAP,wBAAAA,UAAU,CAACO,KAAX,GAAmB;AACfC,0BAAAA,iBAAiB,EAAEJ,WAAW,CAACC,UADhB;AAEfI,0BAAAA,QAAQ,EAAEL,WAAW,CAAClC,UAFP;AAGfwC,0BAAAA,QAAQ,EAAEN,WAAW,CAACO;AAHP,yBAAnB;AAKH;AACJ;;AACD,oBAAA,MAAI,CAACnG,QAAL,CAAcoG,aAAd,CAA4BZ,UAA5B;AACH,mBAtBD;;AAuBA,sBAAIF,YAAY,CAAC1D,MAAb,IAAuB,CAA3B,EAA8B;AAC1BwD,oBAAAA,UAAU,CAACrE,IAAX,CAAgBuE,YAAY,CAAC/C,IAAb,CAAkB,GAAlB,CAAhB;AACH;AACJ,iBA5BD;;AA6BA,oBAAI6C,UAAU,CAACxD,MAAX,GAAoB,CAAxB,EAA2B;AACvB,uBAAK5B,QAAL,CAAcC,SAAd,CAAwB,OAAxB,EAAiCmF,UAAU,CAACzD,MAAX,CAAkBvC,QAAlB,EAA4BmD,IAA5B,CAAiC,GAAjC,CAAjC;AACH;;AACK8D,gBAAAA,WAxDV,GAwDwB,KAAKjF,MAAL,CAAYO,MAAZ,CAAmB,UAAAR,KAAK,EAAI;AAC5C,yBAAOA,KAAK,CAACyB,sBAAN,CAA6BhB,MAA7B,IAAuC,CAAvC,IAA4CT,KAAK,CAACyB,sBAAN,CAA6B,CAA7B,EAAgCgD,WAA5E,IAA2FzE,KAAK,CAACyB,sBAAN,CAA6B,CAA7B,EAAgCgD,WAAhC,CAA4CO,gBAA5C,GAA+D,CAAjK;AACH,iBAFmB,CAxDxB;;AA2DI,oBAAIE,WAAW,CAACzE,MAAZ,IAAsB,CAA1B,EAA6B;AACnB0E,kBAAAA,UADmB,GACND,WAAW,CAAC,CAAD,CADL;AAEnB3F,kBAAAA,QAFmB,GAER4F,UAAU,CAAC5F,QAAX,GAAsB4F,UAAU,CAAC7F,SAFzB;AAGzB,uBAAKT,QAAL,CAAcC,SAAd,CAAwB,UAAxB,EAAoCS,QAApC,EAHyB,CAGsB;;AACzC6E,kBAAAA,GAJmB,GAIbe,UAAU,CAAC1D,sBAAX,CAAkC,CAAlC,CAJa;;AAKzB,sBAAI2C,GAAG,CAACK,WAAR,EAAqB;AACjB,yBAAK5F,QAAL,CAAcC,SAAd,CAAwB,YAAxB,EAAsCsF,GAAG,CAACK,WAAJ,CAAgBC,UAAtD;AACA,yBAAK7F,QAAL,CAAcC,SAAd,CAAwB,eAAxB,EAAyCsF,GAAG,CAACK,WAAJ,CAAgBlC,UAAzD;AACA,yBAAK1D,QAAL,CAAcC,SAAd,CAAwB,kBAAxB,EAA4CsF,GAAG,CAACK,WAAJ,CAAgBO,gBAA5D;AACH;;AACKV,kBAAAA,WAVmB,GAULpH,WAAW,CAACkH,GAAG,CAACG,UAAL,CAVN;;AAWzB,sBAAID,WAAJ,EAAiB;AACb,yBAAKzF,QAAL,CAAcC,SAAd,CAAwB,UAAxB,EAAoC,CAACwF,WAAW,CAAClH,KAAjD;AACH;;AACD,uBAAKgD,gBAAL;AACH;;AA1EL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;iFA4EA,mBAAiBwD,IAAjB,EAAuBC,SAAvB;AAAA;AAAA;AAAA;AAAA;AAAA,qBACQD,IAAI,CAACwB,MADb;AAAA;AAAA;AAAA;;AAAA,gCAEgBxB,IAAI,CAACwB,MAAL,CAAYpB,MAAZ,CAAmBX,IAFnC;AAAA,oDAGiB,MAHjB,yBAIiB,MAJjB;AAAA;;AAAA;AAAA,mDAKuB,KAAKgC,qBAAL,CAA2BzB,IAA3B,CALvB;;AAAA;AAAA,qBASQ,KAAKtF,WAAL,CAAiBsF,IAAI,CAACI,MAAL,CAAYX,IAA7B,CATR;AAAA;AAAA;AAAA;;AAAA,mDAUe,KAAK/E,WAAL,CAAiBsF,IAAI,CAACI,MAAL,CAAYX,IAA7B,EAAmCQ,SAAnC,CAVf;;AAAA;AAaQ7G,gBAAAA,KAAK,mCAA4B4G,IAAI,CAAC0B,QAAjC,2BAA0DzB,SAA1D,qBAAL;AAbR;AAAA,uBAcc,KAAKpF,SAAL,CAAeqC,MAAf,CAAsB+C,SAAtB,CAdd;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WAiBA,+BAAsB;AAClB,aAAO,KAAK5D,MAAL,CAAY,KAAKA,MAAL,CAAYQ,MAAZ,GAAqB,CAAjC,CAAP;AACH;;;WACD,4BAAmB;AACf,UAAI,KAAKN,kBAAL,IAA2B,KAAKtB,QAAL,CAAcxB,MAAd,CAAqBkC,QAApD,EAA8D;AAC1D,aAAKV,QAAL,CAAcC,SAAd,CAAwB,SAAxB,EAAmC,IAAI,KAAKqB,kBAAT,GAA8B,KAAKtB,QAAL,CAAcxB,MAAd,CAAqBkC,QAAtF;AACH;AACJ;;;WACD,gBAAOgG,EAAP,EAAWjJ,KAAX,EAAkB;AACd,WAAKuC,QAAL,CAAciE,MAAd,CAAqB7F,SAArB,EAAgCsI,EAAhC,EAAoCjJ,KAApC;AACH;;;WACD,oBAAWmH,OAAX,EAAoB;AAChBzG,MAAAA,KAAK,CAAC,cAAcyG,OAAf,CAAL;AACA,WAAK5E,QAAL,CAAc2E,UAAd,CAAyBC,OAAzB;AACH;AACD;AACJ;AACA;AACA;AACA;;;;WACI,+BAAsB+B,QAAtB,EAAgC;AAAA;;AAC5B,UAAIC,MAAM,GAAGD,QAAQ,CAACxB,MAAT,CAAgBX,IAA7B;AACA,aAAOmC,QAAQ,CAACE,SAAT,CAAmB,KAAKjH,SAAxB;AAAA,4EAAmC,mBAAOkH,KAAP,EAAc9B,SAAd;AAAA;AAAA;AAAA;AAAA;AAAA;AAChC+B,kBAAAA,aADgC,GAChBD,KAAK,CAACE,gBAAN,CAAuBhC,SAAvB,CADgB;AAAA,kCAE9B8B,KAAK,CAAC3B,MAAN,CAAaX,IAFiB;AAAA,sDAG7B,MAH6B,yBAK7B,MAL6B,yBAS7B,MAT6B;AAAA;;AAAA;AAAA,qDAIvB,MAAI,CAACyC,cAAL,CAAoBL,MAApB,EAA4BE,KAA5B,CAJuB;;AAAA;AAAA;AAAA,yBAMX,MAAI,CAAClH,SAAL,CAAeC,SAAf,CAAyB,IAAI7B,SAAS,CAACkJ,QAAd,CAAuBH,aAAvB,CAAzB,CANW;;AAAA;AAMxBvC,kBAAAA,IANwB;AAO9BoC,kBAAAA,MAAM,IAAI,MAAMpC,IAAI,CAACA,IAArB;AAP8B;;AAAA;AAAA;AAAA,yBAUX,MAAI,CAAC5E,SAAL,CAAeC,SAAf,CAAyB,IAAI7B,SAAS,CAACkJ,QAAd,CAAuBH,aAAvB,CAAzB,CAVW;;AAAA;AAUxBI,kBAAAA,IAVwB;AAW9B;AACAP,kBAAAA,MAAM,IAAI,MAAMO,IAAI,CAAC3C,IAArB;AAZ8B;;AAAA;AAAA;AAAA,yBAeP,MAAI,CAAC5E,SAAL,CAAeC,SAAf,CAAyB,IAAIhC,KAAK,CAACuJ,UAAV,CAAqBL,aAArB,CAAzB,CAfO;;AAAA;AAexBM,kBAAAA,QAfwB;;AAgB9B,kBAAA,MAAI,CAAC1C,UAAL,CAAgB,4BAA4BiC,MAA5B,GAAqC,GAArC,GAA2CE,KAAK,CAAC3B,MAAN,CAAaX,IAAxD,GAA+D,aAA/D,GAA+E6C,QAAQ,CAACC,QAAT,CAAkB,KAAlB,CAA/E,GAA0G,SAA1G,GAAsHD,QAAQ,CAACC,QAAT,CAAkB,OAAlB,CAAtI;;AAhB8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAnC;;AAAA;AAAA;AAAA;AAAA,WAkBJX,QAAQ,CAACK,gBAAT,CAA0B,CAA1B,CAlBI,CAAP;AAmBH;;;;qFACD,mBAAqBJ,MAArB,EAA6BD,QAA7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAC2B,KAAK/G,SAAL,CAAeC,SAAf,CAAyB,IAAI7B,SAAS,CAACuJ,QAAd,CAAuBZ,QAAQ,CAACxB,MAAT,CAAgBvD,MAAhB,GAAyB5D,SAAS,CAACsG,MAAV,CAAiB3E,GAAjE,CAAzB,CAD3B;;AAAA;AACU0H,gBAAAA,QADV;;AAAA,sBAEQA,QAAQ,CAAChF,IAAT,CAAcmF,GAAd,KAAsB,CAF9B;AAAA;AAAA;AAAA;;AAAA,sBAGc,IAAIC,KAAJ,CAAU,gCAAgCJ,QAAQ,CAAChF,IAAT,CAAcmF,GAAxD,CAHd;;AAAA;AAAA,gCAOYH,QAAQ,CAAChF,IAAT,CAAcA,IAP1B;AAAA,oDAQa,CARb,yBA4Ba,CA5Bb,0BA6Ba,EA7Bb,0BAgCa,EAhCb,0BAwCa,EAxCb,0BAgDa,EAhDb,0BAmDa,EAnDb,0BAsDa,EAtDb,0BAyDa,EAzDb,0BA4Da,EA5Db;AAAA;;AAAA;AAAA,gCASoBuE,MATpB;AAAA,oDAUqB,MAVrB,0BAWqB,MAXrB,0BAiBqB,MAjBrB;AAAA;;AAAA;AAY0Bc,gBAAAA,GAZ1B,GAYgC7J,KAAK,CAAC8J,KAAN,CAAYC,GAAZ,CAAgBP,QAAQ,CAAC5J,KAAzB,EAAgC,CAAhC,CAZhC;AAa0BoK,gBAAAA,EAb1B,GAa+BhK,KAAK,CAAC8J,KAAN,CAAYC,GAAZ,CAAgBP,QAAQ,CAAC5J,KAAzB,EAAgC,CAAhC,CAb/B,EAcoB;;AACA,qBAAKwG,MAAL,CAAY2C,MAAZ,EAAoBc,GAAG,GAAG,GAAN,GAAYG,EAAhC;AAfpB;;AAAA;AAkB0BC,gBAAAA,QAlB1B,GAkBqCjK,KAAK,CAAC8J,KAAN,CAAYC,GAAZ,CAAgBP,QAAQ,CAAC5J,KAAzB,EAAgC,CAAhC,CAlBrC;AAmB0BsK,gBAAAA,QAnB1B,GAmBqC9J,aAAa,CAAC+J,MAAd,CAAqBF,QAAQ,GAAG,CAAhC,CAnBrC,EAoBoB;;AACA,qBAAK7D,MAAL,CAAY2C,MAAZ,EAAoBmB,QAApB;AArBpB;;AAAA;AAAA;;AAAA;AA6BiB;AACL,qBAAK9D,MAAL,CAAY2C,MAAZ,EAAoBS,QAAQ,CAAC5J,KAAT,CAAe6J,QAAf,CAAwB,OAAxB,CAApB;AA9BZ;;AAAA;AAAA,qBAiCgB,KAAK9F,OAAL,CAAayG,UAjC7B;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAmCY,qBAAKhE,MAAL,CAAY2C,MAAZ,EAAoB;AAChBpI,kBAAAA,MAAM,EAAE,YADQ;AAEhB0J,kBAAAA,IAAI,EAAEC,MAAM,CAACC,IAAP,CAAYf,QAAQ,CAAC5J,KAArB;AAFU,iBAApB;AAnCZ;;AAAA;AAAA,qBAyCgB,KAAK+D,OAAL,CAAayG,UAzC7B;AAAA;AAAA;AAAA;;AAAA;;AAAA;AA2CY,qBAAKhE,MAAL,CAAY2C,MAAZ,EAAoB;AAChBpI,kBAAAA,MAAM,EAAE,WADQ;AAEhB0J,kBAAAA,IAAI,EAAEC,MAAM,CAACC,IAAP,CAAYf,QAAQ,CAAC5J,KAArB;AAFU,iBAApB;AA3CZ;;AAAA;AAgDiB;AACL,qBAAKwG,MAAL,CAAY2C,MAAZ,EAAoBlJ,SAAS,CAAC2K,sBAAV,CAAiChB,QAAQ,CAAC5J,KAA1C,CAApB;AAjDZ;;AAAA;AAmDiB;AACL,qBAAKwG,MAAL,CAAY2C,MAAZ,EAAoBlJ,SAAS,CAAC4K,wBAAV,CAAmCjB,QAAQ,CAAC5J,KAA5C,CAApB;AApDZ;;AAAA;AAsDiB;AACL,qBAAKwG,MAAL,CAAY2C,MAAZ,EAAoBS,QAAQ,CAAC5J,KAAT,CAAe8K,QAAf,CAAwB,CAAxB,CAApB;AAvDZ;;AAAA;AAyDiB;AACL,qBAAKtE,MAAL,CAAY2C,MAAZ,EAAoBS,QAAQ,CAAC5J,KAAT,CAAe+K,WAAf,CAA2B,CAA3B,CAApB;AA1DZ;;AAAA;AA4DiB;AACL,qBAAKvE,MAAL,CAAY2C,MAAZ,EAAoBS,QAAQ,CAAC5J,KAAT,CAAegL,WAAf,CAA2B,CAA3B,CAApB;AA7DZ;;AAAA;AAgEY,qBAAK9D,UAAL,oBAA4BiC,MAA5B,wDAAgFS,QAAQ,CAAChF,IAAT,CAAcA,IAA9F;;AAhEZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAmEA;AACJ;AACA;AACA;;;;WACI,qCAA4BqG,iBAA5B,EAA+C;AAC3C,UAAMnD,GAAG,GAAG;AACRG,QAAAA,UAAU,EAAEgD,iBAAiB,CAAChD,UADtB;AAERiD,QAAAA,kBAAkB,EAAED,iBAAiB,CAACC;AAF9B,OAAZ;AAIA,UAAIC,MAAM,GAAG,CAAb;AACA,UAAMC,OAAO,GAAG7K,SAAS,CAAC8K,6BAAV,CAAwClB,GAAxC,CAA4Cc,iBAAiB,CAAC9C,WAA9D,EAA2EgD,MAA3E,CAAhB;AACAA,MAAAA,MAAM,IAAI5K,SAAS,CAAC8K,6BAAV,CAAwCnJ,GAAlD;;AACA,UAAIkJ,OAAO,CAACA,OAAR,KAAoB,CAApB,IAAyBA,OAAO,CAACA,OAAR,KAAoB,CAAjD,EAAoD;AAChD;AACAtD,QAAAA,GAAG,CAACK,WAAJ,GAAkB5H,SAAS,CAAC+K,wBAAV,CAAmCnB,GAAnC,CAAuCc,iBAAiB,CAAC9C,WAAzD,EAAsEgD,MAAtE,CAAlB;AACH,OAHD,MAIK;AACDzK,QAAAA,KAAK,6CAAsC0K,OAAtC,sBAAL;AACH;;AACD,aAAOtD,GAAP;AACH;;;;wFACD,mBAAwByD,YAAxB,EAAsC7H,KAAtC,EAA6CxB,GAA7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBACSqJ,YAAY,CAACtF,UADtB;AAAA;AAAA;AAAA;;AAAA,sBAEYsF,YAAY,CAAClF,gBAAb,CAA8BlC,MAA9B,KAAyCoH,YAAY,CAACrF,eAAb,CAA6B/B,MAFlF;AAAA;AAAA;AAAA;;AAAA,sBAGkB,IAAI6F,KAAJ,CAAU,+DAAV,CAHlB;;AAAA;AAKUwB,gBAAAA,QALV,GAKqB,EALrB;AAMaC,gBAAAA,CANb,GAMiB,CANjB;;AAAA;AAAA,sBAMoBA,CAAC,GAAGF,YAAY,CAAClF,gBAAb,CAA8BlC,MAAlC,IAA4CjC,GAAG,GAAG,CANtE;AAAA;AAAA;AAAA;;AAOcwJ,gBAAAA,WAPd,GAO4BH,YAAY,CAAClF,gBAAb,CAA8BoF,CAA9B,CAP5B;AAQcE,gBAAAA,YARd,GAQ6BD,WAAW,GAAG,KAAKvJ,SAAL,CAAe8E,QAR1D;AASchB,gBAAAA,UATd,GAS2BsF,YAAY,CAACtF,UAAb,GAA0B,CAA1B,GAA8BsF,YAAY,CAACtF,UAA3C,GAAwDsF,YAAY,CAACrF,eAAb,CAA6BuF,CAA7B,CATnF;AAUQvJ,gBAAAA,GAAG,IAAIyJ,YAAY,GAAG1F,UAAtB;;AAVR,sBAWY/D,GAAG,GAAG,CAXlB;AAAA;AAAA;AAAA;;AAAA,sBAYkB,IAAI8H,KAAJ,CAAU,sCAAV,CAZlB;;AAAA;AAAA;AAAA,uBAac,KAAK7H,SAAL,CAAeqC,MAAf,CAAsBmH,YAAtB,CAbd;;AAAA;AAAA;AAAA,uBAc4B,KAAKxJ,SAAL,CAAeC,SAAf,CAAyB,IAAI7B,SAAS,CAACqL,WAAd,CAA0B3F,UAA1B,CAAzB,CAd5B;;AAAA;AAcc4F,gBAAAA,KAdd;AAeQnL,gBAAAA,KAAK,mBAAY+K,CAAC,GAAG,CAAhB,eAAsBI,KAAtB,EAAL;AACMC,gBAAAA,OAhBd,GAgBwB;AACZD,kBAAAA,KAAK,EAALA,KADY;AAEZE,kBAAAA,YAAY,EAAE,KAAKC,gBAAL,CAAsBtI,KAAtB,EAA6B,KAAKvB,SAAL,CAAe8E,QAA5C;AAFF,iBAhBxB;AAoBQvG,gBAAAA,KAAK,yBAAkBoL,OAAO,CAACD,KAA1B,sBAA2CC,OAAO,CAACC,YAAnD,cAAmE,KAAKpI,MAAL,CAAY,CAAZ,EAAeV,QAAlF,EAAL;AACAuI,gBAAAA,QAAQ,CAAClI,IAAT,CAAcwI,OAAd;;AArBR;AAMyE,kBAAEL,CAN3E;AAAA;AAAA;;AAAA;AAuBI,qBAAKlJ,QAAL,CAAcC,SAAd,CAAwB,UAAxB,EAAoCgJ,QAApC;AAvBJ;AAAA,uBAwBU,KAAKrJ,SAAL,CAAeqC,MAAf,CAAsBtC,GAAtB,CAxBV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WA0BA,0BAAiBwB,KAAjB,EAAwBuI,aAAxB,EAAuC;AACnC,UAAIC,aAAa,GAAG,CAApB;AACAxI,MAAAA,KAAK,CAACoC,iBAAN,CAAwB8B,OAAxB,CAAgC,UAAAuE,CAAC,EAAI;AACjCD,QAAAA,aAAa,IAAIC,CAAC,CAACC,KAAF,GAAUD,CAAC,CAAClJ,QAA7B;AACH,OAFD;AAGAvC,MAAAA,KAAK,0BAAmBwL,aAAnB,EAAL;AACA,UAAIG,UAAU,GAAG,CAAjB;;AACA,aAAOA,UAAU,GAAG3I,KAAK,CAAC2C,gBAAN,CAAuBlC,MAApC,IAA8CT,KAAK,CAAC2C,gBAAN,CAAuBgG,UAAvB,IAAqCJ,aAA1F,EAAyG;AACrG,UAAEI,UAAF;AACH;;AACD,aAAO,KAAKC,gBAAL,CAAsBD,UAAU,GAAG,CAAnC,EAAsC3I,KAAtC,CAAP;AACH;;;WACD,0BAAiB6I,OAAjB,EAA0B7I,KAA1B,EAAiC;AAC7B,UAAI8I,IAAI,GAAG,CAAX;AACA,UAAIC,IAAI,GAAG/I,KAAK,CAACoC,iBAAN,CAAwB0G,IAAxB,EAA8BJ,KAAzC;AACA,UAAIM,IAAI,GAAGhJ,KAAK,CAACoC,iBAAN,CAAwB0G,IAAxB,EAA8BvJ,QAAzC;AACA,UAAI0J,UAAU,GAAG,CAAjB;AACA,UAAIC,eAAe,GAAG,KAAKC,kBAAL,CAAwBF,UAAxB,EAAoCjJ,KAAK,CAACgC,kBAA1C,CAAtB;AACA,UAAIwG,aAAa,GAAG,CAApB;;AACA,aAAOS,UAAU,GAAGJ,OAApB,EAA6B;AACzB,YAAMO,WAAW,GAAGC,IAAI,CAACC,GAAL,CAASP,IAAT,EAAeG,eAAf,CAApB;AACAV,QAAAA,aAAa,IAAIY,WAAW,GAAGJ,IAA/B;AACAD,QAAAA,IAAI,IAAIK,WAAR;AACAF,QAAAA,eAAe,IAAIE,WAAnB;;AACA,YAAIF,eAAe,KAAK,CAAxB,EAA2B;AACvB,YAAED,UAAF;AACAC,UAAAA,eAAe,GAAG,KAAKC,kBAAL,CAAwBF,UAAxB,EAAoCjJ,KAAK,CAACgC,kBAA1C,CAAlB;AACH,SAHD,MAIK;AACD,YAAE8G,IAAF;AACAC,UAAAA,IAAI,GAAG/I,KAAK,CAACoC,iBAAN,CAAwB0G,IAAxB,EAA8BJ,KAArC;AACAM,UAAAA,IAAI,GAAGhJ,KAAK,CAACoC,iBAAN,CAAwB0G,IAAxB,EAA8BvJ,QAArC;AACH;AACJ;;AACD,aAAOiJ,aAAP;AACH;;;WACD,4BAAmBK,OAAnB,EAA4BU,QAA5B,EAAsC;AAClC,WAAK,IAAIxB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwB,QAAQ,CAAC9I,MAAT,GAAkB,CAAtC,EAAyC,EAAEsH,CAA3C,EAA8C;AAC1C,YAAIc,OAAO,IAAIU,QAAQ,CAACxB,CAAD,CAAR,CAAYyB,UAAvB,IAAqCX,OAAO,GAAGU,QAAQ,CAACxB,CAAC,GAAG,CAAL,CAAR,CAAgByB,UAAnE,EAA+E;AAC3E,iBAAOD,QAAQ,CAACxB,CAAD,CAAR,CAAYmB,eAAnB;AACH;AACJ;;AACD,aAAOK,QAAQ,CAACA,QAAQ,CAAC9I,MAAT,GAAkB,CAAnB,CAAR,CAA8ByI,eAArC;AACH;;;WA1SD,gCAA8B5M,KAA9B,EAAqC;AACjC,aAAOI,KAAK,CAAC+M,SAAN,CAAgBnN,KAAhB,EAAuB,CAAvB,EAA0BA,KAAK,CAACmE,MAAhC,CAAP;AACH;;;WACD,kCAAgCnE,KAAhC,EAAuC;AACnC,aAAOI,KAAK,CAACgN,UAAN,CAAiBpN,KAAjB,EAAwB,CAAxB,EAA2BA,KAAK,CAACmE,MAAjC,CAAP;AACH;;;;EAzHmB9D,aAAa,CAACgN,W;;AAgatCtN,OAAO,CAACE,SAAR,GAAoBA,SAApB","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MP4Parser = void 0;\r\nconst initDebug = require(\"debug\");\r\nconst Token = require(\"token-types\");\r\nconst BasicParser_1 = require(\"../common/BasicParser\");\r\nconst Atom_1 = require(\"./Atom\");\r\nconst AtomToken = require(\"./AtomToken\");\r\nconst ID3v1Parser_1 = require(\"../id3v1/ID3v1Parser\");\r\nconst type_1 = require(\"../type\");\r\nconst debug = initDebug('music-metadata:parser:MP4');\r\nconst tagFormat = 'iTunes';\r\nconst encoderDict = {\r\n    raw: {\r\n        lossy: false,\r\n        format: 'raw'\r\n    },\r\n    MAC3: {\r\n        lossy: true,\r\n        format: 'MACE 3:1'\r\n    },\r\n    MAC6: {\r\n        lossy: true,\r\n        format: 'MACE 6:1'\r\n    },\r\n    ima4: {\r\n        lossy: true,\r\n        format: 'IMA 4:1'\r\n    },\r\n    ulaw: {\r\n        lossy: true,\r\n        format: 'uLaw 2:1'\r\n    },\r\n    alaw: {\r\n        lossy: true,\r\n        format: 'uLaw 2:1'\r\n    },\r\n    Qclp: {\r\n        lossy: true,\r\n        format: 'QUALCOMM PureVoice'\r\n    },\r\n    '.mp3': {\r\n        lossy: true,\r\n        format: 'MPEG-1 layer 3'\r\n    },\r\n    alac: {\r\n        lossy: false,\r\n        format: 'ALAC'\r\n    },\r\n    'ac-3': {\r\n        lossy: true,\r\n        format: 'AC-3'\r\n    },\r\n    mp4a: {\r\n        lossy: true,\r\n        format: 'MPEG-4/AAC'\r\n    },\r\n    mp4s: {\r\n        lossy: true,\r\n        format: 'MP4S'\r\n    },\r\n    // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\r\n    c608: {\r\n        lossy: true,\r\n        format: 'CEA-608'\r\n    },\r\n    c708: {\r\n        lossy: true,\r\n        format: 'CEA-708'\r\n    }\r\n};\r\nfunction distinct(value, index, self) {\r\n    return self.indexOf(value) === index;\r\n}\r\n/*\r\n * Parser for the MP4 (MPEG-4 Part 14) container format\r\n * Standard: ISO/IEC 14496-14\r\n * supporting:\r\n * - QuickTime container\r\n * - MP4 File Format\r\n * - 3GPP file format\r\n * - 3GPP2 file format\r\n *\r\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\r\n * Support for Apple iTunes tags as found in a M4A/M4V files.\r\n * Ref:\r\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\r\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\r\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\r\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\r\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\r\n */\r\nclass MP4Parser extends BasicParser_1.BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.atomParsers = {\r\n            /**\r\n             * Parse movie header (mvhd) atom\r\n             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\r\n             */\r\n            mvhd: async (len) => {\r\n                const _mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));\r\n                this.metadata.setFormat('creationTime', _mvhd.creationTime);\r\n                this.metadata.setFormat('modificationTime', _mvhd.modificationTime);\r\n            },\r\n            /**\r\n             * Parse media header (mdhd) atom\r\n             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615\r\n             */\r\n            mdhd: async (len) => {\r\n                const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(len));\r\n                // this.parse_mxhd(mdhd_data, this.currentTrack);\r\n                const td = this.getTrackDescription();\r\n                td.creationTime = mdhd_data.creationTime;\r\n                td.modificationTime = mdhd_data.modificationTime;\r\n                td.timeScale = mdhd_data.timeScale;\r\n                td.duration = mdhd_data.duration;\r\n            },\r\n            chap: async (len) => {\r\n                const td = this.getTrackDescription();\r\n                const trackIds = [];\r\n                while (len >= Token.UINT32_BE.len) {\r\n                    trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\r\n                    len -= Token.UINT32_BE.len;\r\n                }\r\n                td.chapterList = trackIds;\r\n            },\r\n            tkhd: async (len) => {\r\n                const track = (await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len)));\r\n                this.tracks.push(track);\r\n            },\r\n            /**\r\n             * Parse mdat atom.\r\n             * Will scan for chapters\r\n             */\r\n            mdat: async (len) => {\r\n                this.audioLengthInBytes = len;\r\n                this.calculateBitRate();\r\n                if (this.options.includeChapters) {\r\n                    const trackWithChapters = this.tracks.filter(track => track.chapterList);\r\n                    if (trackWithChapters.length === 1) {\r\n                        const chapterTrackIds = trackWithChapters[0].chapterList;\r\n                        const chapterTracks = this.tracks.filter(track => chapterTrackIds.indexOf(track.trackId) !== -1);\r\n                        if (chapterTracks.length === 1) {\r\n                            return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\r\n                        }\r\n                    }\r\n                }\r\n                await this.tokenizer.ignore(len);\r\n            },\r\n            ftyp: async (len) => {\r\n                const types = [];\r\n                while (len > 0) {\r\n                    const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\r\n                    len -= AtomToken.ftyp.len;\r\n                    const value = ftype.type.replace(/\\W/g, '');\r\n                    if (value.length > 0) {\r\n                        types.push(value); // unshift for backward compatibility\r\n                    }\r\n                }\r\n                debug(`ftyp: ${types.join('/')}`);\r\n                const x = types.filter(distinct).join('/');\r\n                this.metadata.setFormat('container', x);\r\n            },\r\n            /**\r\n             * Parse sample description atom\r\n             */\r\n            stsd: async (len) => {\r\n                const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\r\n                const trackDescription = this.getTrackDescription();\r\n                trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\r\n            },\r\n            /**\r\n             * sample-to-Chunk Atoms\r\n             */\r\n            stsc: async (len) => {\r\n                const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(len));\r\n                this.getTrackDescription().sampleToChunkTable = stsc.entries;\r\n            },\r\n            /**\r\n             * time to sample\r\n             */\r\n            stts: async (len) => {\r\n                const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(len));\r\n                this.getTrackDescription().timeToSampleTable = stts.entries;\r\n            },\r\n            /**\r\n             * Parse sample-sizes atom ('stsz')\r\n             */\r\n            stsz: async (len) => {\r\n                const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\r\n                const td = this.getTrackDescription();\r\n                td.sampleSize = stsz.sampleSize;\r\n                td.sampleSizeTable = stsz.entries;\r\n            },\r\n            /**\r\n             * Parse chunk-offset atom ('stco')\r\n             */\r\n            stco: async (len) => {\r\n                const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(len));\r\n                this.getTrackDescription().chunkOffsetTable = stco.entries; // remember chunk offsets\r\n            },\r\n            date: async (len) => {\r\n                const date = await this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));\r\n                this.addTag('date', date);\r\n            }\r\n        };\r\n    }\r\n    static read_BE_Signed_Integer(value) {\r\n        return Token.readIntBE(value, 0, value.length);\r\n    }\r\n    static read_BE_Unsigned_Integer(value) {\r\n        return Token.readUIntBE(value, 0, value.length);\r\n    }\r\n    async parse() {\r\n        this.tracks = [];\r\n        let remainingFileSize = this.tokenizer.fileInfo.size;\r\n        while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\r\n            try {\r\n                const token = await this.tokenizer.peekToken(AtomToken.Header);\r\n                if (token.name === '\\0\\0\\0\\0') {\r\n                    const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\r\n                    debug(errMsg);\r\n                    this.addWarning(errMsg);\r\n                    break;\r\n                }\r\n            }\r\n            catch (error) {\r\n                const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\r\n                debug(errMsg);\r\n                this.addWarning(errMsg);\r\n                break;\r\n            }\r\n            const rootAtom = await Atom_1.Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);\r\n            remainingFileSize -= rootAtom.header.length === 0 ? remainingFileSize : rootAtom.header.length;\r\n        }\r\n        // Post process metadata\r\n        const formatList = [];\r\n        this.tracks.forEach(track => {\r\n            const trackFormats = [];\r\n            track.soundSampleDescription.forEach(ssd => {\r\n                const streamInfo = {};\r\n                const encoderInfo = encoderDict[ssd.dataFormat];\r\n                if (encoderInfo) {\r\n                    trackFormats.push(encoderInfo.format);\r\n                    streamInfo.codecName = encoderInfo.format;\r\n                }\r\n                else {\r\n                    streamInfo.codecName = `<${ssd.dataFormat}>`;\r\n                }\r\n                if (ssd.description) {\r\n                    const { description } = ssd;\r\n                    if (description.sampleRate > 0) {\r\n                        streamInfo.type = type_1.TrackType.audio;\r\n                        streamInfo.audio = {\r\n                            samplingFrequency: description.sampleRate,\r\n                            bitDepth: description.sampleSize,\r\n                            channels: description.numAudioChannels\r\n                        };\r\n                    }\r\n                }\r\n                this.metadata.addStreamInfo(streamInfo);\r\n            });\r\n            if (trackFormats.length >= 1) {\r\n                formatList.push(trackFormats.join('/'));\r\n            }\r\n        });\r\n        if (formatList.length > 0) {\r\n            this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\r\n        }\r\n        const audioTracks = this.tracks.filter(track => {\r\n            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;\r\n        });\r\n        if (audioTracks.length >= 1) {\r\n            const audioTrack = audioTracks[0];\r\n            const duration = audioTrack.duration / audioTrack.timeScale;\r\n            this.metadata.setFormat('duration', duration); // calculate duration in seconds\r\n            const ssd = audioTrack.soundSampleDescription[0];\r\n            if (ssd.description) {\r\n                this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\r\n                this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\r\n                this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\r\n            }\r\n            const encoderInfo = encoderDict[ssd.dataFormat];\r\n            if (encoderInfo) {\r\n                this.metadata.setFormat('lossless', !encoderInfo.lossy);\r\n            }\r\n            this.calculateBitRate();\r\n        }\r\n    }\r\n    async handleAtom(atom, remaining) {\r\n        if (atom.parent) {\r\n            switch (atom.parent.header.name) {\r\n                case 'ilst':\r\n                case '<id>':\r\n                    return this.parseMetadataItemData(atom);\r\n            }\r\n        }\r\n        // const payloadLength = atom.getPayloadLength(remaining);\r\n        if (this.atomParsers[atom.header.name]) {\r\n            return this.atomParsers[atom.header.name](remaining);\r\n        }\r\n        else {\r\n            debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);\r\n            await this.tokenizer.ignore(remaining);\r\n        }\r\n    }\r\n    getTrackDescription() {\r\n        return this.tracks[this.tracks.length - 1];\r\n    }\r\n    calculateBitRate() {\r\n        if (this.audioLengthInBytes && this.metadata.format.duration) {\r\n            this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);\r\n        }\r\n    }\r\n    addTag(id, value) {\r\n        this.metadata.addTag(tagFormat, id, value);\r\n    }\r\n    addWarning(message) {\r\n        debug('Warning: ' + message);\r\n        this.metadata.addWarning(message);\r\n    }\r\n    /**\r\n     * Parse data of Meta-item-list-atom (item of 'ilst' atom)\r\n     * @param metaAtom\r\n     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\r\n     */\r\n    parseMetadataItemData(metaAtom) {\r\n        let tagKey = metaAtom.header.name;\r\n        return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {\r\n            const payLoadLength = child.getPayloadLength(remaining);\r\n            switch (child.header.name) {\r\n                case 'data': // value atom\r\n                    return this.parseValueAtom(tagKey, child);\r\n                case 'name': // name atom (optional)\r\n                    const name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\r\n                    tagKey += ':' + name.name;\r\n                    break;\r\n                case 'mean': // name atom (optional)\r\n                    const mean = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\r\n                    // console.log(\"  %s[%s] = %s\", tagKey, header.name, mean.name);\r\n                    tagKey += ':' + mean.name;\r\n                    break;\r\n                default:\r\n                    const dataAtom = await this.tokenizer.readToken(new Token.BufferType(payLoadLength));\r\n                    this.addWarning('Unsupported meta-item: ' + tagKey + '[' + child.header.name + '] => value=' + dataAtom.toString('hex') + ' ascii=' + dataAtom.toString('ascii'));\r\n            }\r\n        }, metaAtom.getPayloadLength(0));\r\n    }\r\n    async parseValueAtom(tagKey, metaAtom) {\r\n        const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(metaAtom.header.length - AtomToken.Header.len));\r\n        if (dataAtom.type.set !== 0) {\r\n            throw new Error('Unsupported type-set != 0: ' + dataAtom.type.set);\r\n        }\r\n        // Use well-known-type table\r\n        // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\r\n        switch (dataAtom.type.type) {\r\n            case 0: // reserved: Reserved for use where no type needs to be indicated\r\n                switch (tagKey) {\r\n                    case 'trkn':\r\n                    case 'disk':\r\n                        const num = Token.UINT8.get(dataAtom.value, 3);\r\n                        const of = Token.UINT8.get(dataAtom.value, 5);\r\n                        // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\r\n                        this.addTag(tagKey, num + '/' + of);\r\n                        break;\r\n                    case 'gnre':\r\n                        const genreInt = Token.UINT8.get(dataAtom.value, 1);\r\n                        const genreStr = ID3v1Parser_1.Genres[genreInt - 1];\r\n                        // console.log(\"  %s[data] = %s\", tagKey, genreStr);\r\n                        this.addTag(tagKey, genreStr);\r\n                        break;\r\n                    default:\r\n                    // console.log(\"  reserved-data: name=%s, len=%s, set=%s, type=%s, locale=%s, value{ hex=%s, ascii=%s }\",\r\n                    // header.name, header.length, dataAtom.type.set, dataAtom.type.type, dataAtom.locale, dataAtom.value.toString('hex'), dataAtom.value.toString('ascii'));\r\n                }\r\n                break;\r\n            case 1: // UTF-8: Without any count or NULL terminator\r\n            case 18: // Unknown: Found in m4b in combination with a '©gen' tag\r\n                this.addTag(tagKey, dataAtom.value.toString('utf-8'));\r\n                break;\r\n            case 13: // JPEG\r\n                if (this.options.skipCovers)\r\n                    break;\r\n                this.addTag(tagKey, {\r\n                    format: 'image/jpeg',\r\n                    data: Buffer.from(dataAtom.value)\r\n                });\r\n                break;\r\n            case 14: // PNG\r\n                if (this.options.skipCovers)\r\n                    break;\r\n                this.addTag(tagKey, {\r\n                    format: 'image/png',\r\n                    data: Buffer.from(dataAtom.value)\r\n                });\r\n                break;\r\n            case 21: // BE Signed Integer\r\n                this.addTag(tagKey, MP4Parser.read_BE_Signed_Integer(dataAtom.value));\r\n                break;\r\n            case 22: // BE Unsigned Integer\r\n                this.addTag(tagKey, MP4Parser.read_BE_Unsigned_Integer(dataAtom.value));\r\n                break;\r\n            case 65: // An 8-bit signed integer\r\n                this.addTag(tagKey, dataAtom.value.readInt8(0));\r\n                break;\r\n            case 66: // A big-endian 16-bit signed integer\r\n                this.addTag(tagKey, dataAtom.value.readInt16BE(0));\r\n                break;\r\n            case 67: // A big-endian 32-bit signed integer\r\n                this.addTag(tagKey, dataAtom.value.readInt32BE(0));\r\n                break;\r\n            default:\r\n                this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\r\n        }\r\n    }\r\n    /**\r\n     * @param sampleDescription\r\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\r\n     */\r\n    parseSoundSampleDescription(sampleDescription) {\r\n        const ssd = {\r\n            dataFormat: sampleDescription.dataFormat,\r\n            dataReferenceIndex: sampleDescription.dataReferenceIndex\r\n        };\r\n        let offset = 0;\r\n        const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\r\n        offset += AtomToken.SoundSampleDescriptionVersion.len;\r\n        if (version.version === 0 || version.version === 1) {\r\n            // Sound Sample Description (Version 0)\r\n            ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\r\n        }\r\n        else {\r\n            debug(`Warning: sound-sample-description ${version} not implemented`);\r\n        }\r\n        return ssd;\r\n    }\r\n    async parseChapterTrack(chapterTrack, track, len) {\r\n        if (!chapterTrack.sampleSize) {\r\n            if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)\r\n                throw new Error('Expected equal chunk-offset-table & sample-size-table length.');\r\n        }\r\n        const chapters = [];\r\n        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\r\n            const chunkOffset = chapterTrack.chunkOffsetTable[i];\r\n            const nextChunkLen = chunkOffset - this.tokenizer.position;\r\n            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\r\n            len -= nextChunkLen + sampleSize;\r\n            if (len < 0)\r\n                throw new Error('Chapter chunk exceeding token length');\r\n            await this.tokenizer.ignore(nextChunkLen);\r\n            const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\r\n            debug(`Chapter ${i + 1}: ${title}`);\r\n            const chapter = {\r\n                title,\r\n                sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\r\n            };\r\n            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`);\r\n            chapters.push(chapter);\r\n        }\r\n        this.metadata.setFormat('chapters', chapters);\r\n        await this.tokenizer.ignore(len);\r\n    }\r\n    findSampleOffset(track, chapterOffset) {\r\n        let totalDuration = 0;\r\n        track.timeToSampleTable.forEach(e => {\r\n            totalDuration += e.count * e.duration;\r\n        });\r\n        debug(`Total duration=${totalDuration}`);\r\n        let chunkIndex = 0;\r\n        while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\r\n            ++chunkIndex;\r\n        }\r\n        return this.getChunkDuration(chunkIndex + 1, track);\r\n    }\r\n    getChunkDuration(chunkId, track) {\r\n        let ttsi = 0;\r\n        let ttsc = track.timeToSampleTable[ttsi].count;\r\n        let ttsd = track.timeToSampleTable[ttsi].duration;\r\n        let curChunkId = 1;\r\n        let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\r\n        let totalDuration = 0;\r\n        while (curChunkId < chunkId) {\r\n            const nrOfSamples = Math.min(ttsc, samplesPerChunk);\r\n            totalDuration += nrOfSamples * ttsd;\r\n            ttsc -= nrOfSamples;\r\n            samplesPerChunk -= nrOfSamples;\r\n            if (samplesPerChunk === 0) {\r\n                ++curChunkId;\r\n                samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\r\n            }\r\n            else {\r\n                ++ttsi;\r\n                ttsc = track.timeToSampleTable[ttsi].count;\r\n                ttsd = track.timeToSampleTable[ttsi].duration;\r\n            }\r\n        }\r\n        return totalDuration;\r\n    }\r\n    getSamplesPerChunk(chunkId, stcTable) {\r\n        for (let i = 0; i < stcTable.length - 1; ++i) {\r\n            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\r\n                return stcTable[i].samplesPerChunk;\r\n            }\r\n        }\r\n        return stcTable[stcTable.length - 1].samplesPerChunk;\r\n    }\r\n}\r\nexports.MP4Parser = MP4Parser;\r\n"]},"metadata":{},"sourceType":"script"}