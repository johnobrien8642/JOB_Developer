{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _inherits = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _classCallCheck = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MpegParser = void 0;\n\nvar Token = require(\"token-types\");\n\nvar core_1 = require(\"strtok3/lib/core\");\n\nvar initDebug = require(\"debug\");\n\nvar Util_1 = require(\"../common/Util\");\n\nvar AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\n\nvar XingTag_1 = require(\"./XingTag\");\n\nvar debug = initDebug('music-metadata:parser:mpeg');\n/**\r\n * Cache buffer size used for searching synchronization preabmle\r\n */\n\nvar maxPeekLen = 1024;\n/**\r\n * MPEG-4 Audio definitions\r\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\r\n */\n\nvar MPEG4 = {\n  /**\r\n   * Audio Object Types\r\n   */\n  AudioObjectTypes: ['AAC Main', 'AAC LC', 'AAC SSR', 'AAC LTP' // Long Term Prediction\n  ],\n\n  /**\r\n   * Sampling Frequencies\r\n   * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\r\n   */\n  SamplingFrequencies: [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, undefined, undefined, -1]\n  /**\r\n   * Channel Configurations\r\n   */\n\n};\nvar MPEG4_ChannelConfigurations = [undefined, ['front-center'], ['front-left', 'front-right'], ['front-center', 'front-left', 'front-right'], ['front-center', 'front-left', 'front-right', 'back-center'], ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'], ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'], ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']];\n/**\r\n * MPEG Audio Layer I/II/III frame header\r\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\r\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\r\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\r\n */\n\nvar MpegFrameHeader = /*#__PURE__*/function () {\n  function MpegFrameHeader(buf, off) {\n    _classCallCheck(this, MpegFrameHeader);\n\n    // B(20,19): MPEG Audio versionIndex ID\n    this.versionIndex = Util_1.default.getBitAllignedNumber(buf, off + 1, 3, 2); // C(18,17): Layer description\n\n    this.layer = MpegFrameHeader.LayerDescription[Util_1.default.getBitAllignedNumber(buf, off + 1, 5, 2)];\n\n    if (this.versionIndex > 1 && this.layer === 0) {\n      this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\n    } else {\n      this.parseMpegHeader(buf, off); // Conventional MPEG header\n    } // D(16): Protection bit (if true 16-bit CRC follows header)\n\n\n    this.isProtectedByCRC = !Util_1.default.isBitSet(buf, off + 1, 7);\n  }\n\n  _createClass(MpegFrameHeader, [{\n    key: \"calcDuration\",\n    value: function calcDuration(numFrames) {\n      return numFrames * this.calcSamplesPerFrame() / this.samplingRate;\n    }\n  }, {\n    key: \"calcSamplesPerFrame\",\n    value: function calcSamplesPerFrame() {\n      return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\n    }\n  }, {\n    key: \"calculateSideInfoLength\",\n    value: function calculateSideInfoLength() {\n      if (this.layer !== 3) return 2;\n\n      if (this.channelModeIndex === 3) {\n        // mono\n        if (this.version === 1) {\n          return 17;\n        } else if (this.version === 2 || this.version === 2.5) {\n          return 9;\n        }\n      } else {\n        if (this.version === 1) {\n          return 32;\n        } else if (this.version === 2 || this.version === 2.5) {\n          return 17;\n        }\n      }\n    }\n  }, {\n    key: \"calcSlotSize\",\n    value: function calcSlotSize() {\n      return [null, 4, 1, 1][this.layer];\n    }\n  }, {\n    key: \"parseMpegHeader\",\n    value: function parseMpegHeader(buf, off) {\n      this.container = 'MPEG'; // E(15,12): Bitrate index\n\n      this.bitrateIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 0, 4); // F(11,10): Sampling rate frequency index\n\n      this.sampRateFreqIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 4, 2); // G(9): Padding bit\n\n      this.padding = Util_1.default.isBitSet(buf, off + 2, 6); // H(8): Private bit\n\n      this.privateBit = Util_1.default.isBitSet(buf, off + 2, 7); // I(7,6): Channel Mode\n\n      this.channelModeIndex = Util_1.default.getBitAllignedNumber(buf, off + 3, 0, 2); // J(5,4): Mode extension (Only used in Joint stereo)\n\n      this.modeExtension = Util_1.default.getBitAllignedNumber(buf, off + 3, 2, 2); // K(3): Copyright\n\n      this.isCopyrighted = Util_1.default.isBitSet(buf, off + 3, 4); // L(2): Original\n\n      this.isOriginalMedia = Util_1.default.isBitSet(buf, off + 3, 5); // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\n\n      this.emphasis = Util_1.default.getBitAllignedNumber(buf, off + 3, 7, 2);\n      this.version = MpegFrameHeader.VersionID[this.versionIndex];\n      this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\n      this.codec = \"MPEG \".concat(this.version, \" Layer \").concat(this.layer); // Calculate bitrate\n\n      var bitrateInKbps = this.calcBitrate();\n\n      if (!bitrateInKbps) {\n        throw new Error('Cannot determine bit-rate');\n      }\n\n      this.bitrate = bitrateInKbps * 1000; // Calculate sampling rate\n\n      this.samplingRate = this.calcSamplingRate();\n\n      if (this.samplingRate == null) {\n        throw new Error('Cannot determine sampling-rate');\n      }\n    }\n  }, {\n    key: \"parseAdtsHeader\",\n    value: function parseAdtsHeader(buf, off) {\n      debug(\"layer=0 => ADTS\");\n      this.version = this.versionIndex === 2 ? 4 : 2;\n      this.container = 'ADTS/MPEG-' + this.version;\n      var profileIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 0, 2);\n      this.codec = 'AAC';\n      this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\n      debug(\"MPEG-4 audio-codec=\".concat(this.codec));\n      var samplingFrequencyIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 2, 4);\n      this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\n      debug(\"sampling-rate=\".concat(this.samplingRate));\n      var channelIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 7, 3);\n      this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\n      debug(\"channel-config=\".concat(this.mp4ChannelConfig.join('+')));\n      this.frameLength = Util_1.default.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\n    }\n  }, {\n    key: \"calcBitrate\",\n    value: function calcBitrate() {\n      if (this.bitrateIndex === 0x00 || // free\n      this.bitrateIndex === 0x0F) {\n        // reserved\n        return;\n      }\n\n      var codecIndex = \"\".concat(Math.floor(this.version)).concat(this.layer);\n      return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\n    }\n  }, {\n    key: \"calcSamplingRate\",\n    value: function calcSamplingRate() {\n      if (this.sampRateFreqIndex === 0x03) return null; // 'reserved'\n\n      return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\n    }\n  }]);\n\n  return MpegFrameHeader;\n}();\n\nMpegFrameHeader.SyncByte1 = 0xFF;\nMpegFrameHeader.SyncByte2 = 0xE0;\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\nMpegFrameHeader.bitrate_index = {\n  0x01: {\n    11: 32,\n    12: 32,\n    13: 32,\n    21: 32,\n    22: 8,\n    23: 8\n  },\n  0x02: {\n    11: 64,\n    12: 48,\n    13: 40,\n    21: 48,\n    22: 16,\n    23: 16\n  },\n  0x03: {\n    11: 96,\n    12: 56,\n    13: 48,\n    21: 56,\n    22: 24,\n    23: 24\n  },\n  0x04: {\n    11: 128,\n    12: 64,\n    13: 56,\n    21: 64,\n    22: 32,\n    23: 32\n  },\n  0x05: {\n    11: 160,\n    12: 80,\n    13: 64,\n    21: 80,\n    22: 40,\n    23: 40\n  },\n  0x06: {\n    11: 192,\n    12: 96,\n    13: 80,\n    21: 96,\n    22: 48,\n    23: 48\n  },\n  0x07: {\n    11: 224,\n    12: 112,\n    13: 96,\n    21: 112,\n    22: 56,\n    23: 56\n  },\n  0x08: {\n    11: 256,\n    12: 128,\n    13: 112,\n    21: 128,\n    22: 64,\n    23: 64\n  },\n  0x09: {\n    11: 288,\n    12: 160,\n    13: 128,\n    21: 144,\n    22: 80,\n    23: 80\n  },\n  0x0A: {\n    11: 320,\n    12: 192,\n    13: 160,\n    21: 160,\n    22: 96,\n    23: 96\n  },\n  0x0B: {\n    11: 352,\n    12: 224,\n    13: 192,\n    21: 176,\n    22: 112,\n    23: 112\n  },\n  0x0C: {\n    11: 384,\n    12: 256,\n    13: 224,\n    21: 192,\n    22: 128,\n    23: 128\n  },\n  0x0D: {\n    11: 416,\n    12: 320,\n    13: 256,\n    21: 224,\n    22: 144,\n    23: 144\n  },\n  0x0E: {\n    11: 448,\n    12: 384,\n    13: 320,\n    21: 256,\n    22: 160,\n    23: 160\n  }\n};\nMpegFrameHeader.sampling_rate_freq_index = {\n  1: {\n    0x00: 44100,\n    0x01: 48000,\n    0x02: 32000\n  },\n  2: {\n    0x00: 22050,\n    0x01: 24000,\n    0x02: 16000\n  },\n  2.5: {\n    0x00: 11025,\n    0x01: 12000,\n    0x02: 8000\n  }\n};\nMpegFrameHeader.samplesInFrameTable = [\n/* Layer   I    II   III */\n[0, 384, 1152, 1152], [0, 384, 1152, 576] // MPEG-2(.5\n];\n/**\r\n * MPEG Audio Layer I/II/III\r\n */\n\nvar FrameHeader = {\n  len: 4,\n  get: function get(buf, off) {\n    return new MpegFrameHeader(buf, off);\n  }\n};\n\nfunction getVbrCodecProfile(vbrScale) {\n  return 'V' + Math.floor((100 - vbrScale) / 10);\n}\n\nvar MpegParser = /*#__PURE__*/function (_AbstractID3Parser_1$) {\n  _inherits(MpegParser, _AbstractID3Parser_1$);\n\n  var _super = _createSuper(MpegParser);\n\n  function MpegParser() {\n    var _this;\n\n    _classCallCheck(this, MpegParser);\n\n    _this = _super.apply(this, arguments);\n    _this.frameCount = 0;\n    _this.syncFrameCount = -1;\n    _this.countSkipFrameData = 0;\n    _this.totalDataLength = 0;\n    _this.bitrates = [];\n    _this.calculateEofDuration = false;\n    _this.buf_frame_header = Buffer.alloc(4);\n    _this.syncPeek = {\n      buf: Buffer.alloc(maxPeekLen),\n      len: 0\n    };\n    return _this;\n  }\n  /**\r\n   * Called after ID3 headers have been parsed\r\n   */\n\n\n  _createClass(MpegParser, [{\n    key: \"_parse\",\n    value: function () {\n      var _parse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var quit, numberOfSamples, duration;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.metadata.setFormat('lossless', false);\n                _context.prev = 1;\n                quit = false;\n\n              case 3:\n                if (quit) {\n                  _context.next = 11;\n                  break;\n                }\n\n                _context.next = 6;\n                return this.sync();\n\n              case 6:\n                _context.next = 8;\n                return this.parseCommonMpegHeader();\n\n              case 8:\n                quit = _context.sent;\n                _context.next = 3;\n                break;\n\n              case 11:\n                _context.next = 21;\n                break;\n\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](1);\n\n                if (!(_context.t0 instanceof core_1.EndOfStreamError)) {\n                  _context.next = 20;\n                  break;\n                }\n\n                debug(\"End-of-stream\");\n\n                if (this.calculateEofDuration) {\n                  numberOfSamples = this.frameCount * this.samplesPerFrame;\n                  this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                  duration = numberOfSamples / this.metadata.format.sampleRate;\n                  debug(\"Calculate duration at EOF: \".concat(duration, \" sec.\"), duration);\n                  this.metadata.setFormat('duration', duration);\n                }\n\n                _context.next = 21;\n                break;\n\n              case 20:\n                throw _context.t0;\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 13]]);\n      }));\n\n      function _parse() {\n        return _parse2.apply(this, arguments);\n      }\n\n      return _parse;\n    }()\n    /**\r\n     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\r\n     */\n\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      var format = this.metadata.format;\n      var hasID3v1 = this.metadata.native.hasOwnProperty('ID3v1');\n\n      if (format.duration && this.tokenizer.fileInfo.size) {\n        var mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n\n        if (format.codecProfile && format.codecProfile[0] === 'V') {\n          this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\n        }\n      } else if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\n        var _mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n\n        var numberOfSamples = Math.round(_mpegSize / this.frame_size) * this.samplesPerFrame;\n        this.metadata.setFormat('numberOfSamples', numberOfSamples);\n        var duration = numberOfSamples / format.sampleRate;\n        debug(\"Calculate CBR duration based on file size: %s\", duration);\n        this.metadata.setFormat('duration', duration);\n      }\n    }\n  }, {\n    key: \"sync\",\n    value: function () {\n      var _sync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var gotFirstSync, bo;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                gotFirstSync = false;\n\n              case 1:\n                if (!true) {\n                  _context2.next = 36;\n                  break;\n                }\n\n                bo = 0;\n                _context2.next = 5;\n                return this.tokenizer.peekBuffer(this.syncPeek.buf, {\n                  length: maxPeekLen,\n                  mayBeLess: true\n                });\n\n              case 5:\n                this.syncPeek.len = _context2.sent;\n\n                if (!(this.syncPeek.len <= 163)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                throw new core_1.EndOfStreamError();\n\n              case 8:\n                if (!true) {\n                  _context2.next = 34;\n                  break;\n                }\n\n                if (!(gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0)) {\n                  _context2.next = 20;\n                  break;\n                }\n\n                this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\n                this.buf_frame_header[1] = this.syncPeek.buf[bo];\n                _context2.next = 14;\n                return this.tokenizer.ignore(bo);\n\n              case 14:\n                debug(\"Sync at offset=\".concat(this.tokenizer.position - 1, \", frameCount=\").concat(this.frameCount));\n\n                if (this.syncFrameCount === this.frameCount) {\n                  debug(\"Re-synced MPEG stream, frameCount=\".concat(this.frameCount));\n                  this.frameCount = 0;\n                  this.frame_size = 0;\n                }\n\n                this.syncFrameCount = this.frameCount;\n                return _context2.abrupt(\"return\");\n\n              case 20:\n                gotFirstSync = false;\n                bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\n\n                if (!(bo === -1)) {\n                  _context2.next = 30;\n                  break;\n                }\n\n                if (!(this.syncPeek.len < this.syncPeek.buf.length)) {\n                  _context2.next = 25;\n                  break;\n                }\n\n                throw new core_1.EndOfStreamError();\n\n              case 25:\n                _context2.next = 27;\n                return this.tokenizer.ignore(this.syncPeek.len);\n\n              case 27:\n                return _context2.abrupt(\"break\", 34);\n\n              case 30:\n                ++bo;\n                gotFirstSync = true;\n\n              case 32:\n                _context2.next = 8;\n                break;\n\n              case 34:\n                _context2.next = 1;\n                break;\n\n              case 36:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function sync() {\n        return _sync.apply(this, arguments);\n      }\n\n      return sync;\n    }()\n    /**\r\n     * Combined ADTS & MPEG (MP2 & MP3) header handling\r\n     * @return {Promise<boolean>} true if parser should quit\r\n     */\n\n  }, {\n    key: \"parseCommonMpegHeader\",\n    value: function () {\n      var _parseCommonMpegHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var header;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.frameCount === 0) {\n                  this.mpegOffset = this.tokenizer.position - 1;\n                }\n\n                _context3.next = 3;\n                return this.tokenizer.peekBuffer(this.buf_frame_header, {\n                  offset: 1,\n                  length: 3\n                });\n\n              case 3:\n                _context3.prev = 3;\n                header = FrameHeader.get(this.buf_frame_header, 0);\n                _context3.next = 13;\n                break;\n\n              case 7:\n                _context3.prev = 7;\n                _context3.t0 = _context3[\"catch\"](3);\n                _context3.next = 11;\n                return this.tokenizer.ignore(1);\n\n              case 11:\n                this.metadata.addWarning('Parse error: ' + _context3.t0.message);\n                return _context3.abrupt(\"return\", false);\n\n              case 13:\n                _context3.next = 15;\n                return this.tokenizer.ignore(3);\n\n              case 15:\n                this.metadata.setFormat('container', header.container);\n                this.metadata.setFormat('codec', header.codec);\n                this.metadata.setFormat('lossless', false);\n                this.metadata.setFormat('sampleRate', header.samplingRate);\n                this.frameCount++;\n\n                if (!(header.version >= 2 && header.layer === 0)) {\n                  _context3.next = 24;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this.parseAdts(header));\n\n              case 24:\n                return _context3.abrupt(\"return\", this.parseAudioFrameHeader(header));\n\n              case 25:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 7]]);\n      }));\n\n      function parseCommonMpegHeader() {\n        return _parseCommonMpegHeader.apply(this, arguments);\n      }\n\n      return parseCommonMpegHeader;\n    }()\n    /**\r\n     * @return {Promise<boolean>} true if parser should quit\r\n     */\n\n  }, {\n    key: \"parseAudioFrameHeader\",\n    value: function () {\n      var _parseAudioFrameHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(header) {\n        var slot_size, samples_per_frame, bps, fsize;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\n                this.metadata.setFormat('bitrate', header.bitrate);\n\n                if (this.frameCount < 20 * 10000) {\n                  debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\n                }\n\n                slot_size = header.calcSlotSize();\n\n                if (!(slot_size === null)) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                throw new Error('invalid slot_size');\n\n              case 6:\n                samples_per_frame = header.calcSamplesPerFrame();\n                debug(\"samples_per_frame=\".concat(samples_per_frame));\n                bps = samples_per_frame / 8.0;\n                fsize = bps * header.bitrate / header.samplingRate + (header.padding ? slot_size : 0);\n                this.frame_size = Math.floor(fsize);\n                this.audioFrameHeader = header;\n                this.bitrates.push(header.bitrate); // xtra header only exists in first frame\n\n                if (!(this.frameCount === 1)) {\n                  _context4.next = 18;\n                  break;\n                }\n\n                this.offset = FrameHeader.len;\n                _context4.next = 17;\n                return this.skipSideInformation();\n\n              case 17:\n                return _context4.abrupt(\"return\", false);\n\n              case 18:\n                if (!(this.frameCount === 3)) {\n                  _context4.next = 30;\n                  break;\n                }\n\n                if (!this.areAllSame(this.bitrates)) {\n                  _context4.next = 26;\n                  break;\n                }\n\n                // Actual calculation will be done in finalize\n                this.samplesPerFrame = samples_per_frame;\n                this.metadata.setFormat('codecProfile', 'CBR');\n\n                if (!this.tokenizer.fileInfo.size) {\n                  _context4.next = 24;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", true);\n\n              case 24:\n                _context4.next = 28;\n                break;\n\n              case 26:\n                if (!this.metadata.format.duration) {\n                  _context4.next = 28;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", true);\n\n              case 28:\n                if (this.options.duration) {\n                  _context4.next = 30;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", true);\n\n              case 30:\n                // once we know the file is VBR attach listener to end of\n                // stream so we can do the duration calculation when we\n                // have counted all the frames\n                if (this.options.duration && this.frameCount === 4) {\n                  this.samplesPerFrame = samples_per_frame;\n                  this.calculateEofDuration = true;\n                }\n\n                this.offset = 4;\n\n                if (!header.isProtectedByCRC) {\n                  _context4.next = 38;\n                  break;\n                }\n\n                _context4.next = 35;\n                return this.parseCrc();\n\n              case 35:\n                return _context4.abrupt(\"return\", false);\n\n              case 38:\n                _context4.next = 40;\n                return this.skipSideInformation();\n\n              case 40:\n                return _context4.abrupt(\"return\", false);\n\n              case 41:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function parseAudioFrameHeader(_x) {\n        return _parseAudioFrameHeader.apply(this, arguments);\n      }\n\n      return parseAudioFrameHeader;\n    }()\n  }, {\n    key: \"parseAdts\",\n    value: function () {\n      var _parseAdts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(header) {\n        var buf, framesPerSec, bytesPerFrame, bitrate;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                buf = Buffer.alloc(3);\n                _context5.next = 3;\n                return this.tokenizer.readBuffer(buf);\n\n              case 3:\n                header.frameLength += Util_1.default.getBitAllignedNumber(buf, 0, 0, 11);\n                this.totalDataLength += header.frameLength;\n                this.samplesPerFrame = 1024;\n                framesPerSec = header.samplingRate / this.samplesPerFrame;\n                bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\n                bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\n                this.metadata.setFormat('bitrate', bitrate);\n                debug(\"frame-count=\".concat(this.frameCount, \", size=\").concat(header.frameLength, \" bytes, bit-rate=\").concat(bitrate));\n                _context5.next = 13;\n                return this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);\n\n              case 13:\n                if (!(this.frameCount === 3)) {\n                  _context5.next = 21;\n                  break;\n                }\n\n                this.metadata.setFormat('codecProfile', header.codecProfile);\n\n                if (header.mp4ChannelConfig) {\n                  this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\n                }\n\n                if (!this.options.duration) {\n                  _context5.next = 20;\n                  break;\n                }\n\n                this.calculateEofDuration = true;\n                _context5.next = 21;\n                break;\n\n              case 20:\n                return _context5.abrupt(\"return\", true);\n\n              case 21:\n                return _context5.abrupt(\"return\", false);\n\n              case 22:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function parseAdts(_x2) {\n        return _parseAdts.apply(this, arguments);\n      }\n\n      return parseAdts;\n    }()\n  }, {\n    key: \"parseCrc\",\n    value: function () {\n      var _parseCrc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.tokenizer.readNumber(Token.INT16_BE);\n\n              case 2:\n                this.crc = _context6.sent;\n                this.offset += 2;\n                return _context6.abrupt(\"return\", this.skipSideInformation());\n\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function parseCrc() {\n        return _parseCrc.apply(this, arguments);\n      }\n\n      return parseCrc;\n    }()\n  }, {\n    key: \"skipSideInformation\",\n    value: function () {\n      var _skipSideInformation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var sideinfo_length;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                sideinfo_length = this.audioFrameHeader.calculateSideInfoLength(); // side information\n\n                _context7.next = 3;\n                return this.tokenizer.readToken(new Token.BufferType(sideinfo_length));\n\n              case 3:\n                this.offset += sideinfo_length;\n                _context7.next = 6;\n                return this.readXtraInfoHeader();\n\n              case 6:\n                return _context7.abrupt(\"return\");\n\n              case 7:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function skipSideInformation() {\n        return _skipSideInformation.apply(this, arguments);\n      }\n\n      return skipSideInformation;\n    }()\n  }, {\n    key: \"readXtraInfoHeader\",\n    value: function () {\n      var _readXtraInfoHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var headerTag, infoTag, codecProfile, version, frameDataLeft;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);\n\n              case 2:\n                headerTag = _context8.sent;\n                this.offset += XingTag_1.InfoTagHeaderTag.len; // 12\n\n                _context8.t0 = headerTag;\n                _context8.next = _context8.t0 === 'Info' ? 7 : _context8.t0 === 'Xing' ? 9 : _context8.t0 === 'Xtra' ? 15 : _context8.t0 === 'LAME' ? 16 : 29;\n                break;\n\n              case 7:\n                this.metadata.setFormat('codecProfile', 'CBR');\n                return _context8.abrupt(\"return\", this.readXingInfoHeader());\n\n              case 9:\n                _context8.next = 11;\n                return this.readXingInfoHeader();\n\n              case 11:\n                infoTag = _context8.sent;\n                codecProfile = getVbrCodecProfile(infoTag.vbrScale);\n                this.metadata.setFormat('codecProfile', codecProfile);\n                return _context8.abrupt(\"return\", null);\n\n              case 15:\n                return _context8.abrupt(\"break\", 29);\n\n              case 16:\n                _context8.next = 18;\n                return this.tokenizer.readToken(XingTag_1.LameEncoderVersion);\n\n              case 18:\n                version = _context8.sent;\n\n                if (!(this.frame_size >= this.offset + XingTag_1.LameEncoderVersion.len)) {\n                  _context8.next = 27;\n                  break;\n                }\n\n                this.offset += XingTag_1.LameEncoderVersion.len;\n                this.metadata.setFormat('tool', 'LAME ' + version);\n                _context8.next = 24;\n                return this.skipFrameData(this.frame_size - this.offset);\n\n              case 24:\n                return _context8.abrupt(\"return\", null);\n\n              case 27:\n                this.metadata.addWarning('Corrupt LAME header');\n                return _context8.abrupt(\"break\", 29);\n\n              case 29:\n                // ToDo: promise duration???\n                frameDataLeft = this.frame_size - this.offset;\n\n                if (!(frameDataLeft < 0)) {\n                  _context8.next = 34;\n                  break;\n                }\n\n                this.metadata.addWarning('Frame ' + this.frameCount + 'corrupt: negative frameDataLeft');\n                _context8.next = 36;\n                break;\n\n              case 34:\n                _context8.next = 36;\n                return this.skipFrameData(frameDataLeft);\n\n              case 36:\n                return _context8.abrupt(\"return\", null);\n\n              case 37:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function readXtraInfoHeader() {\n        return _readXtraInfoHeader.apply(this, arguments);\n      }\n\n      return readXtraInfoHeader;\n    }()\n    /**\r\n     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\r\n     * @returns {Promise<string>}\r\n     */\n\n  }, {\n    key: \"readXingInfoHeader\",\n    value: function () {\n      var _readXingInfoHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _offset, infoTag, duration, frameDataLeft;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _offset = this.tokenizer.position;\n                _context9.next = 3;\n                return XingTag_1.readXingHeader(this.tokenizer);\n\n              case 3:\n                infoTag = _context9.sent;\n                this.offset += this.tokenizer.position - _offset;\n\n                if (infoTag.lame) {\n                  this.metadata.setFormat('tool', 'LAME ' + Util_1.default.stripNulls(infoTag.lame.version));\n\n                  if (infoTag.lame.extended) {\n                    // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);\n                    this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);\n\n                    if (infoTag.lame.extended.track_gain) {\n                      this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);\n                    }\n\n                    if (infoTag.lame.extended.album_gain) {\n                      this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);\n                    }\n\n                    this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);\n                  }\n                }\n\n                if (!infoTag.streamSize) {\n                  _context9.next = 11;\n                  break;\n                }\n\n                duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\n                this.metadata.setFormat('duration', duration);\n                debug('Get duration from Xing header: %s', this.metadata.format.duration);\n                return _context9.abrupt(\"return\", infoTag);\n\n              case 11:\n                // frames field is not present\n                frameDataLeft = this.frame_size - this.offset;\n                _context9.next = 14;\n                return this.skipFrameData(frameDataLeft);\n\n              case 14:\n                return _context9.abrupt(\"return\", infoTag);\n\n              case 15:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function readXingInfoHeader() {\n        return _readXingInfoHeader.apply(this, arguments);\n      }\n\n      return readXingInfoHeader;\n    }()\n  }, {\n    key: \"skipFrameData\",\n    value: function () {\n      var _skipFrameData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(frameDataLeft) {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!(frameDataLeft < 0)) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                throw new Error('frame-data-left cannot be negative');\n\n              case 2:\n                _context10.next = 4;\n                return this.tokenizer.ignore(frameDataLeft);\n\n              case 4:\n                this.countSkipFrameData += frameDataLeft;\n\n              case 5:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function skipFrameData(_x3) {\n        return _skipFrameData.apply(this, arguments);\n      }\n\n      return skipFrameData;\n    }()\n  }, {\n    key: \"areAllSame\",\n    value: function areAllSame(array) {\n      var first = array[0];\n      return array.every(function (element) {\n        return element === first;\n      });\n    }\n  }]);\n\n  return MpegParser;\n}(AbstractID3Parser_1.AbstractID3Parser);\n\nexports.MpegParser = MpegParser;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/mpeg/MpegParser.js"],"names":["Object","defineProperty","exports","value","MpegParser","Token","require","core_1","initDebug","Util_1","AbstractID3Parser_1","XingTag_1","debug","maxPeekLen","MPEG4","AudioObjectTypes","SamplingFrequencies","undefined","MPEG4_ChannelConfigurations","MpegFrameHeader","buf","off","versionIndex","default","getBitAllignedNumber","layer","LayerDescription","parseAdtsHeader","parseMpegHeader","isProtectedByCRC","isBitSet","numFrames","calcSamplesPerFrame","samplingRate","samplesInFrameTable","version","channelModeIndex","container","bitrateIndex","sampRateFreqIndex","padding","privateBit","modeExtension","isCopyrighted","isOriginalMedia","emphasis","VersionID","channelMode","ChannelMode","codec","bitrateInKbps","calcBitrate","Error","bitrate","calcSamplingRate","profileIndex","codecProfile","samplingFrequencyIndex","channelIndex","mp4ChannelConfig","join","frameLength","codecIndex","Math","floor","bitrate_index","sampling_rate_freq_index","SyncByte1","SyncByte2","FrameHeader","len","get","getVbrCodecProfile","vbrScale","arguments","frameCount","syncFrameCount","countSkipFrameData","totalDataLength","bitrates","calculateEofDuration","buf_frame_header","Buffer","alloc","syncPeek","metadata","setFormat","quit","sync","parseCommonMpegHeader","EndOfStreamError","numberOfSamples","samplesPerFrame","duration","format","sampleRate","hasID3v1","native","hasOwnProperty","tokenizer","fileInfo","size","mpegSize","mpegOffset","round","frame_size","gotFirstSync","bo","peekBuffer","length","mayBeLess","ignore","position","indexOf","offset","header","addWarning","message","parseAdts","parseAudioFrameHeader","slot_size","calcSlotSize","samples_per_frame","bps","fsize","audioFrameHeader","push","skipSideInformation","areAllSame","options","parseCrc","readBuffer","framesPerSec","bytesPerFrame","readNumber","INT16_BE","crc","sideinfo_length","calculateSideInfoLength","readToken","BufferType","readXtraInfoHeader","InfoTagHeaderTag","headerTag","readXingInfoHeader","infoTag","LameEncoderVersion","skipFrameData","frameDataLeft","_offset","readXingHeader","lame","stripNulls","extended","track_peak","track_gain","adjustment","album_gain","music_length","streamSize","calcDuration","array","first","every","element","AbstractID3Parser"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MpegParser = void 0;\r\nconst Token = require(\"token-types\");\r\nconst core_1 = require(\"strtok3/lib/core\");\r\nconst initDebug = require(\"debug\");\r\nconst Util_1 = require(\"../common/Util\");\r\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\r\nconst XingTag_1 = require(\"./XingTag\");\r\nconst debug = initDebug('music-metadata:parser:mpeg');\r\n/**\r\n * Cache buffer size used for searching synchronization preabmle\r\n */\r\nconst maxPeekLen = 1024;\r\n/**\r\n * MPEG-4 Audio definitions\r\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\r\n */\r\nconst MPEG4 = {\r\n    /**\r\n     * Audio Object Types\r\n     */\r\n    AudioObjectTypes: [\r\n        'AAC Main',\r\n        'AAC LC',\r\n        'AAC SSR',\r\n        'AAC LTP' // Long Term Prediction\r\n    ],\r\n    /**\r\n     * Sampling Frequencies\r\n     * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\r\n     */\r\n    SamplingFrequencies: [\r\n        96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, undefined, undefined, -1\r\n    ]\r\n    /**\r\n     * Channel Configurations\r\n     */\r\n};\r\nconst MPEG4_ChannelConfigurations = [\r\n    undefined,\r\n    ['front-center'],\r\n    ['front-left', 'front-right'],\r\n    ['front-center', 'front-left', 'front-right'],\r\n    ['front-center', 'front-left', 'front-right', 'back-center'],\r\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'],\r\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'],\r\n    ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']\r\n];\r\n/**\r\n * MPEG Audio Layer I/II/III frame header\r\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\r\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\r\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\r\n */\r\nclass MpegFrameHeader {\r\n    constructor(buf, off) {\r\n        // B(20,19): MPEG Audio versionIndex ID\r\n        this.versionIndex = Util_1.default.getBitAllignedNumber(buf, off + 1, 3, 2);\r\n        // C(18,17): Layer description\r\n        this.layer = MpegFrameHeader.LayerDescription[Util_1.default.getBitAllignedNumber(buf, off + 1, 5, 2)];\r\n        if (this.versionIndex > 1 && this.layer === 0) {\r\n            this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\r\n        }\r\n        else {\r\n            this.parseMpegHeader(buf, off); // Conventional MPEG header\r\n        }\r\n        // D(16): Protection bit (if true 16-bit CRC follows header)\r\n        this.isProtectedByCRC = !Util_1.default.isBitSet(buf, off + 1, 7);\r\n    }\r\n    calcDuration(numFrames) {\r\n        return numFrames * this.calcSamplesPerFrame() / this.samplingRate;\r\n    }\r\n    calcSamplesPerFrame() {\r\n        return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\r\n    }\r\n    calculateSideInfoLength() {\r\n        if (this.layer !== 3)\r\n            return 2;\r\n        if (this.channelModeIndex === 3) {\r\n            // mono\r\n            if (this.version === 1) {\r\n                return 17;\r\n            }\r\n            else if (this.version === 2 || this.version === 2.5) {\r\n                return 9;\r\n            }\r\n        }\r\n        else {\r\n            if (this.version === 1) {\r\n                return 32;\r\n            }\r\n            else if (this.version === 2 || this.version === 2.5) {\r\n                return 17;\r\n            }\r\n        }\r\n    }\r\n    calcSlotSize() {\r\n        return [null, 4, 1, 1][this.layer];\r\n    }\r\n    parseMpegHeader(buf, off) {\r\n        this.container = 'MPEG';\r\n        // E(15,12): Bitrate index\r\n        this.bitrateIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 0, 4);\r\n        // F(11,10): Sampling rate frequency index\r\n        this.sampRateFreqIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 4, 2);\r\n        // G(9): Padding bit\r\n        this.padding = Util_1.default.isBitSet(buf, off + 2, 6);\r\n        // H(8): Private bit\r\n        this.privateBit = Util_1.default.isBitSet(buf, off + 2, 7);\r\n        // I(7,6): Channel Mode\r\n        this.channelModeIndex = Util_1.default.getBitAllignedNumber(buf, off + 3, 0, 2);\r\n        // J(5,4): Mode extension (Only used in Joint stereo)\r\n        this.modeExtension = Util_1.default.getBitAllignedNumber(buf, off + 3, 2, 2);\r\n        // K(3): Copyright\r\n        this.isCopyrighted = Util_1.default.isBitSet(buf, off + 3, 4);\r\n        // L(2): Original\r\n        this.isOriginalMedia = Util_1.default.isBitSet(buf, off + 3, 5);\r\n        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\r\n        this.emphasis = Util_1.default.getBitAllignedNumber(buf, off + 3, 7, 2);\r\n        this.version = MpegFrameHeader.VersionID[this.versionIndex];\r\n        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\r\n        this.codec = `MPEG ${this.version} Layer ${this.layer}`;\r\n        // Calculate bitrate\r\n        const bitrateInKbps = this.calcBitrate();\r\n        if (!bitrateInKbps) {\r\n            throw new Error('Cannot determine bit-rate');\r\n        }\r\n        this.bitrate = bitrateInKbps * 1000;\r\n        // Calculate sampling rate\r\n        this.samplingRate = this.calcSamplingRate();\r\n        if (this.samplingRate == null) {\r\n            throw new Error('Cannot determine sampling-rate');\r\n        }\r\n    }\r\n    parseAdtsHeader(buf, off) {\r\n        debug(`layer=0 => ADTS`);\r\n        this.version = this.versionIndex === 2 ? 4 : 2;\r\n        this.container = 'ADTS/MPEG-' + this.version;\r\n        const profileIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 0, 2);\r\n        this.codec = 'AAC';\r\n        this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\r\n        debug(`MPEG-4 audio-codec=${this.codec}`);\r\n        const samplingFrequencyIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 2, 4);\r\n        this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\r\n        debug(`sampling-rate=${this.samplingRate}`);\r\n        const channelIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 7, 3);\r\n        this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\r\n        debug(`channel-config=${this.mp4ChannelConfig.join('+')}`);\r\n        this.frameLength = Util_1.default.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\r\n    }\r\n    calcBitrate() {\r\n        if (this.bitrateIndex === 0x00 || // free\r\n            this.bitrateIndex === 0x0F) { // reserved\r\n            return;\r\n        }\r\n        const codecIndex = `${Math.floor(this.version)}${this.layer}`;\r\n        return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\r\n    }\r\n    calcSamplingRate() {\r\n        if (this.sampRateFreqIndex === 0x03)\r\n            return null; // 'reserved'\r\n        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\r\n    }\r\n}\r\nMpegFrameHeader.SyncByte1 = 0xFF;\r\nMpegFrameHeader.SyncByte2 = 0xE0;\r\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\r\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\r\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\r\nMpegFrameHeader.bitrate_index = {\r\n    0x01: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },\r\n    0x02: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },\r\n    0x03: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },\r\n    0x04: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },\r\n    0x05: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },\r\n    0x06: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },\r\n    0x07: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },\r\n    0x08: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },\r\n    0x09: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },\r\n    0x0A: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },\r\n    0x0B: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },\r\n    0x0C: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },\r\n    0x0D: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },\r\n    0x0E: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }\r\n};\r\nMpegFrameHeader.sampling_rate_freq_index = {\r\n    1: { 0x00: 44100, 0x01: 48000, 0x02: 32000 },\r\n    2: { 0x00: 22050, 0x01: 24000, 0x02: 16000 },\r\n    2.5: { 0x00: 11025, 0x01: 12000, 0x02: 8000 }\r\n};\r\nMpegFrameHeader.samplesInFrameTable = [\r\n    /* Layer   I    II   III */\r\n    [0, 384, 1152, 1152],\r\n    [0, 384, 1152, 576] // MPEG-2(.5\r\n];\r\n/**\r\n * MPEG Audio Layer I/II/III\r\n */\r\nconst FrameHeader = {\r\n    len: 4,\r\n    get: (buf, off) => {\r\n        return new MpegFrameHeader(buf, off);\r\n    }\r\n};\r\nfunction getVbrCodecProfile(vbrScale) {\r\n    return 'V' + Math.floor((100 - vbrScale) / 10);\r\n}\r\nclass MpegParser extends AbstractID3Parser_1.AbstractID3Parser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.frameCount = 0;\r\n        this.syncFrameCount = -1;\r\n        this.countSkipFrameData = 0;\r\n        this.totalDataLength = 0;\r\n        this.bitrates = [];\r\n        this.calculateEofDuration = false;\r\n        this.buf_frame_header = Buffer.alloc(4);\r\n        this.syncPeek = {\r\n            buf: Buffer.alloc(maxPeekLen),\r\n            len: 0\r\n        };\r\n    }\r\n    /**\r\n     * Called after ID3 headers have been parsed\r\n     */\r\n    async _parse() {\r\n        this.metadata.setFormat('lossless', false);\r\n        try {\r\n            let quit = false;\r\n            while (!quit) {\r\n                await this.sync();\r\n                quit = await this.parseCommonMpegHeader();\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (err instanceof core_1.EndOfStreamError) {\r\n                debug(`End-of-stream`);\r\n                if (this.calculateEofDuration) {\r\n                    const numberOfSamples = this.frameCount * this.samplesPerFrame;\r\n                    this.metadata.setFormat('numberOfSamples', numberOfSamples);\r\n                    const duration = numberOfSamples / this.metadata.format.sampleRate;\r\n                    debug(`Calculate duration at EOF: ${duration} sec.`, duration);\r\n                    this.metadata.setFormat('duration', duration);\r\n                }\r\n            }\r\n            else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\r\n     */\r\n    finalize() {\r\n        const format = this.metadata.format;\r\n        const hasID3v1 = this.metadata.native.hasOwnProperty('ID3v1');\r\n        if (format.duration && this.tokenizer.fileInfo.size) {\r\n            const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\r\n            if (format.codecProfile && format.codecProfile[0] === 'V') {\r\n                this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\r\n            }\r\n        }\r\n        else if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\r\n            const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\r\n            const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;\r\n            this.metadata.setFormat('numberOfSamples', numberOfSamples);\r\n            const duration = numberOfSamples / format.sampleRate;\r\n            debug(\"Calculate CBR duration based on file size: %s\", duration);\r\n            this.metadata.setFormat('duration', duration);\r\n        }\r\n    }\r\n    async sync() {\r\n        let gotFirstSync = false;\r\n        while (true) {\r\n            let bo = 0;\r\n            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });\r\n            if (this.syncPeek.len <= 163) {\r\n                throw new core_1.EndOfStreamError();\r\n            }\r\n            while (true) {\r\n                if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {\r\n                    this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\r\n                    this.buf_frame_header[1] = this.syncPeek.buf[bo];\r\n                    await this.tokenizer.ignore(bo);\r\n                    debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);\r\n                    if (this.syncFrameCount === this.frameCount) {\r\n                        debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);\r\n                        this.frameCount = 0;\r\n                        this.frame_size = 0;\r\n                    }\r\n                    this.syncFrameCount = this.frameCount;\r\n                    return; // sync\r\n                }\r\n                else {\r\n                    gotFirstSync = false;\r\n                    bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\r\n                    if (bo === -1) {\r\n                        if (this.syncPeek.len < this.syncPeek.buf.length) {\r\n                            throw new core_1.EndOfStreamError();\r\n                        }\r\n                        await this.tokenizer.ignore(this.syncPeek.len);\r\n                        break; // continue with next buffer\r\n                    }\r\n                    else {\r\n                        ++bo;\r\n                        gotFirstSync = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Combined ADTS & MPEG (MP2 & MP3) header handling\r\n     * @return {Promise<boolean>} true if parser should quit\r\n     */\r\n    async parseCommonMpegHeader() {\r\n        if (this.frameCount === 0) {\r\n            this.mpegOffset = this.tokenizer.position - 1;\r\n        }\r\n        await this.tokenizer.peekBuffer(this.buf_frame_header, { offset: 1, length: 3 });\r\n        let header;\r\n        try {\r\n            header = FrameHeader.get(this.buf_frame_header, 0);\r\n        }\r\n        catch (err) {\r\n            await this.tokenizer.ignore(1);\r\n            this.metadata.addWarning('Parse error: ' + err.message);\r\n            return false; // sync\r\n        }\r\n        await this.tokenizer.ignore(3);\r\n        this.metadata.setFormat('container', header.container);\r\n        this.metadata.setFormat('codec', header.codec);\r\n        this.metadata.setFormat('lossless', false);\r\n        this.metadata.setFormat('sampleRate', header.samplingRate);\r\n        this.frameCount++;\r\n        if (header.version >= 2 && header.layer === 0) {\r\n            return this.parseAdts(header); // ADTS, usually AAC\r\n        }\r\n        else {\r\n            return this.parseAudioFrameHeader(header); // MP3\r\n        }\r\n    }\r\n    /**\r\n     * @return {Promise<boolean>} true if parser should quit\r\n     */\r\n    async parseAudioFrameHeader(header) {\r\n        this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\r\n        this.metadata.setFormat('bitrate', header.bitrate);\r\n        if (this.frameCount < 20 * 10000) {\r\n            debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\r\n        }\r\n        const slot_size = header.calcSlotSize();\r\n        if (slot_size === null) {\r\n            throw new Error('invalid slot_size');\r\n        }\r\n        const samples_per_frame = header.calcSamplesPerFrame();\r\n        debug(`samples_per_frame=${samples_per_frame}`);\r\n        const bps = samples_per_frame / 8.0;\r\n        const fsize = (bps * header.bitrate / header.samplingRate) +\r\n            ((header.padding) ? slot_size : 0);\r\n        this.frame_size = Math.floor(fsize);\r\n        this.audioFrameHeader = header;\r\n        this.bitrates.push(header.bitrate);\r\n        // xtra header only exists in first frame\r\n        if (this.frameCount === 1) {\r\n            this.offset = FrameHeader.len;\r\n            await this.skipSideInformation();\r\n            return false;\r\n        }\r\n        if (this.frameCount === 3) {\r\n            // the stream is CBR if the first 3 frame bitrates are the same\r\n            if (this.areAllSame(this.bitrates)) {\r\n                // Actual calculation will be done in finalize\r\n                this.samplesPerFrame = samples_per_frame;\r\n                this.metadata.setFormat('codecProfile', 'CBR');\r\n                if (this.tokenizer.fileInfo.size)\r\n                    return true; // Will calculate duration based on the file size\r\n            }\r\n            else if (this.metadata.format.duration) {\r\n                return true; // We already got the duration, stop processing MPEG stream any further\r\n            }\r\n            if (!this.options.duration) {\r\n                return true; // Enforce duration not enabled, stop processing entire stream\r\n            }\r\n        }\r\n        // once we know the file is VBR attach listener to end of\r\n        // stream so we can do the duration calculation when we\r\n        // have counted all the frames\r\n        if (this.options.duration && this.frameCount === 4) {\r\n            this.samplesPerFrame = samples_per_frame;\r\n            this.calculateEofDuration = true;\r\n        }\r\n        this.offset = 4;\r\n        if (header.isProtectedByCRC) {\r\n            await this.parseCrc();\r\n            return false;\r\n        }\r\n        else {\r\n            await this.skipSideInformation();\r\n            return false;\r\n        }\r\n    }\r\n    async parseAdts(header) {\r\n        const buf = Buffer.alloc(3);\r\n        await this.tokenizer.readBuffer(buf);\r\n        header.frameLength += Util_1.default.getBitAllignedNumber(buf, 0, 0, 11);\r\n        this.totalDataLength += header.frameLength;\r\n        this.samplesPerFrame = 1024;\r\n        const framesPerSec = header.samplingRate / this.samplesPerFrame;\r\n        const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\r\n        const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\r\n        this.metadata.setFormat('bitrate', bitrate);\r\n        debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);\r\n        await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);\r\n        // Consume remaining header and frame data\r\n        if (this.frameCount === 3) {\r\n            this.metadata.setFormat('codecProfile', header.codecProfile);\r\n            if (header.mp4ChannelConfig) {\r\n                this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\r\n            }\r\n            if (this.options.duration) {\r\n                this.calculateEofDuration = true;\r\n            }\r\n            else {\r\n                return true; // Stop parsing after the third frame\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    async parseCrc() {\r\n        this.crc = await this.tokenizer.readNumber(Token.INT16_BE);\r\n        this.offset += 2;\r\n        return this.skipSideInformation();\r\n    }\r\n    async skipSideInformation() {\r\n        const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();\r\n        // side information\r\n        await this.tokenizer.readToken(new Token.BufferType(sideinfo_length));\r\n        this.offset += sideinfo_length;\r\n        await this.readXtraInfoHeader();\r\n        return;\r\n    }\r\n    async readXtraInfoHeader() {\r\n        const headerTag = await this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);\r\n        this.offset += XingTag_1.InfoTagHeaderTag.len; // 12\r\n        switch (headerTag) {\r\n            case 'Info':\r\n                this.metadata.setFormat('codecProfile', 'CBR');\r\n                return this.readXingInfoHeader();\r\n            case 'Xing':\r\n                const infoTag = await this.readXingInfoHeader();\r\n                const codecProfile = getVbrCodecProfile(infoTag.vbrScale);\r\n                this.metadata.setFormat('codecProfile', codecProfile);\r\n                return null;\r\n            case 'Xtra':\r\n                // ToDo: ???\r\n                break;\r\n            case 'LAME':\r\n                const version = await this.tokenizer.readToken(XingTag_1.LameEncoderVersion);\r\n                if (this.frame_size >= this.offset + XingTag_1.LameEncoderVersion.len) {\r\n                    this.offset += XingTag_1.LameEncoderVersion.len;\r\n                    this.metadata.setFormat('tool', 'LAME ' + version);\r\n                    await this.skipFrameData(this.frame_size - this.offset);\r\n                    return null;\r\n                }\r\n                else {\r\n                    this.metadata.addWarning('Corrupt LAME header');\r\n                    break;\r\n                }\r\n            // ToDo: ???\r\n        }\r\n        // ToDo: promise duration???\r\n        const frameDataLeft = this.frame_size - this.offset;\r\n        if (frameDataLeft < 0) {\r\n            this.metadata.addWarning('Frame ' + this.frameCount + 'corrupt: negative frameDataLeft');\r\n        }\r\n        else {\r\n            await this.skipFrameData(frameDataLeft);\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\r\n     * @returns {Promise<string>}\r\n     */\r\n    async readXingInfoHeader() {\r\n        const _offset = this.tokenizer.position;\r\n        const infoTag = await XingTag_1.readXingHeader(this.tokenizer);\r\n        this.offset += this.tokenizer.position - _offset;\r\n        if (infoTag.lame) {\r\n            this.metadata.setFormat('tool', 'LAME ' + Util_1.default.stripNulls(infoTag.lame.version));\r\n            if (infoTag.lame.extended) {\r\n                // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);\r\n                this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);\r\n                if (infoTag.lame.extended.track_gain) {\r\n                    this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);\r\n                }\r\n                if (infoTag.lame.extended.album_gain) {\r\n                    this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);\r\n                }\r\n                this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);\r\n            }\r\n        }\r\n        if (infoTag.streamSize) {\r\n            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\r\n            this.metadata.setFormat('duration', duration);\r\n            debug('Get duration from Xing header: %s', this.metadata.format.duration);\r\n            return infoTag;\r\n        }\r\n        // frames field is not present\r\n        const frameDataLeft = this.frame_size - this.offset;\r\n        await this.skipFrameData(frameDataLeft);\r\n        return infoTag;\r\n    }\r\n    async skipFrameData(frameDataLeft) {\r\n        if (frameDataLeft < 0)\r\n            throw new Error('frame-data-left cannot be negative');\r\n        await this.tokenizer.ignore(frameDataLeft);\r\n        this.countSkipFrameData += frameDataLeft;\r\n    }\r\n    areAllSame(array) {\r\n        const first = array[0];\r\n        return array.every(element => {\r\n            return element === first;\r\n        });\r\n    }\r\n}\r\nexports.MpegParser = MpegParser;\r\n"]},"metadata":{},"sourceType":"script"}