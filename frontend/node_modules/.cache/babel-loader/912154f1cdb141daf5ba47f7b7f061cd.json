{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WavPack = void 0;\n\nconst Token = require(\"token-types\");\n\nconst FourCC_1 = require(\"../common/FourCC\");\n\nconst SampleRates = [6000, 8000, 9600, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000, 64000, 88200, 96000, 192000, -1];\n\nclass WavPack {\n  static isBitSet(flags, bitOffset) {\n    return WavPack.getBitAllignedNumber(flags, bitOffset, 1) === 1;\n  }\n\n  static getBitAllignedNumber(flags, bitOffset, len) {\n    return flags >>> bitOffset & 0xffffffff >>> 32 - len;\n  }\n\n}\n\nexports.WavPack = WavPack;\n/**\r\n * WavPack Block Header\r\n *\r\n * 32-byte little-endian header at the front of every WavPack block\r\n *\r\n * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 2/6: 2.0 \"Block Header\")\r\n */\n\nWavPack.BlockHeaderToken = {\n  len: 32,\n  get: (buf, off) => {\n    const flags = Token.UINT32_LE.get(buf, off + 24);\n    const res = {\n      // should equal 'wvpk'\n      BlockID: FourCC_1.FourCcToken.get(buf, off),\n      //  0x402 to 0x410 are valid for decode\n      blockSize: Token.UINT32_LE.get(buf, off + 4),\n      //  0x402 (1026) to 0x410 are valid for decode\n      version: Token.UINT16_LE.get(buf, off + 8),\n      //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)\n      totalSamples:\n      /* replace with bigint? (Token.UINT8.get(buf, off + 11) << 32) + */\n      Token.UINT32_LE.get(buf, off + 12),\n      // 40-bit block_index\n      blockIndex:\n      /* replace with bigint? (Token.UINT8.get(buf, off + 10) << 32) + */\n      Token.UINT32_LE.get(buf, off + 16),\n      // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)\n      blockSamples: Token.UINT32_LE.get(buf, off + 20),\n      // various flags for id and decoding\n      flags: {\n        bitsPerSample: (1 + WavPack.getBitAllignedNumber(flags, 0, 2)) * 8,\n        isMono: WavPack.isBitSet(flags, 2),\n        isHybrid: WavPack.isBitSet(flags, 3),\n        isJointStereo: WavPack.isBitSet(flags, 4),\n        crossChannel: WavPack.isBitSet(flags, 5),\n        hybridNoiseShaping: WavPack.isBitSet(flags, 6),\n        floatingPoint: WavPack.isBitSet(flags, 7),\n        samplingRate: SampleRates[WavPack.getBitAllignedNumber(flags, 23, 4)],\n        isDSD: WavPack.isBitSet(flags, 31)\n      },\n      // crc for actual decoded data\n      crc: new Token.BufferType(4).get(buf, off + 28)\n    };\n\n    if (res.flags.isDSD) {\n      res.totalSamples *= 8;\n    }\n\n    return res;\n  }\n};\n/**\r\n * 3.0 Metadata Sub-Blocks\r\n *  Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 4/6: 3.0 \"Metadata Sub-Block\")\r\n */\n\nWavPack.MetadataIdToken = {\n  len: 1,\n  get: (buf, off) => {\n    return {\n      functionId: WavPack.getBitAllignedNumber(buf[off], 0, 6),\n      isOptional: WavPack.isBitSet(buf[off], 5),\n      isOddSize: WavPack.isBitSet(buf[off], 6),\n      largeBlock: WavPack.isBitSet(buf[off], 7)\n    };\n  }\n};","map":{"version":3,"sources":["/Users/johnobrien/Desktop/JOB_Developer/client/node_modules/music-metadata/lib/wavpack/WavPackToken.js"],"names":["Object","defineProperty","exports","value","WavPack","Token","require","FourCC_1","SampleRates","isBitSet","flags","bitOffset","getBitAllignedNumber","len","BlockHeaderToken","get","buf","off","UINT32_LE","res","BlockID","FourCcToken","blockSize","version","UINT16_LE","totalSamples","blockIndex","blockSamples","bitsPerSample","isMono","isHybrid","isJointStereo","crossChannel","hybridNoiseShaping","floatingPoint","samplingRate","isDSD","crc","BufferType","MetadataIdToken","functionId","isOptional","isOddSize","largeBlock"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WavPack = void 0;\r\nconst Token = require(\"token-types\");\r\nconst FourCC_1 = require(\"../common/FourCC\");\r\nconst SampleRates = [6000, 8000, 9600, 11025, 12000, 16000, 22050, 24000, 32000, 44100,\r\n    48000, 64000, 88200, 96000, 192000, -1];\r\nclass WavPack {\r\n    static isBitSet(flags, bitOffset) {\r\n        return WavPack.getBitAllignedNumber(flags, bitOffset, 1) === 1;\r\n    }\r\n    static getBitAllignedNumber(flags, bitOffset, len) {\r\n        return (flags >>> bitOffset) & (0xffffffff >>> (32 - len));\r\n    }\r\n}\r\nexports.WavPack = WavPack;\r\n/**\r\n * WavPack Block Header\r\n *\r\n * 32-byte little-endian header at the front of every WavPack block\r\n *\r\n * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 2/6: 2.0 \"Block Header\")\r\n */\r\nWavPack.BlockHeaderToken = {\r\n    len: 32,\r\n    get: (buf, off) => {\r\n        const flags = Token.UINT32_LE.get(buf, off + 24);\r\n        const res = {\r\n            // should equal 'wvpk'\r\n            BlockID: FourCC_1.FourCcToken.get(buf, off),\r\n            //  0x402 to 0x410 are valid for decode\r\n            blockSize: Token.UINT32_LE.get(buf, off + 4),\r\n            //  0x402 (1026) to 0x410 are valid for decode\r\n            version: Token.UINT16_LE.get(buf, off + 8),\r\n            //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)\r\n            totalSamples: /* replace with bigint? (Token.UINT8.get(buf, off + 11) << 32) + */ Token.UINT32_LE.get(buf, off + 12),\r\n            // 40-bit block_index\r\n            blockIndex: /* replace with bigint? (Token.UINT8.get(buf, off + 10) << 32) + */ Token.UINT32_LE.get(buf, off + 16),\r\n            // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)\r\n            blockSamples: Token.UINT32_LE.get(buf, off + 20),\r\n            // various flags for id and decoding\r\n            flags: {\r\n                bitsPerSample: (1 + WavPack.getBitAllignedNumber(flags, 0, 2)) * 8,\r\n                isMono: WavPack.isBitSet(flags, 2),\r\n                isHybrid: WavPack.isBitSet(flags, 3),\r\n                isJointStereo: WavPack.isBitSet(flags, 4),\r\n                crossChannel: WavPack.isBitSet(flags, 5),\r\n                hybridNoiseShaping: WavPack.isBitSet(flags, 6),\r\n                floatingPoint: WavPack.isBitSet(flags, 7),\r\n                samplingRate: SampleRates[WavPack.getBitAllignedNumber(flags, 23, 4)],\r\n                isDSD: WavPack.isBitSet(flags, 31)\r\n            },\r\n            // crc for actual decoded data\r\n            crc: new Token.BufferType(4).get(buf, off + 28)\r\n        };\r\n        if (res.flags.isDSD) {\r\n            res.totalSamples *= 8;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n/**\r\n * 3.0 Metadata Sub-Blocks\r\n *  Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 4/6: 3.0 \"Metadata Sub-Block\")\r\n */\r\nWavPack.MetadataIdToken = {\r\n    len: 1,\r\n    get: (buf, off) => {\r\n        return {\r\n            functionId: WavPack.getBitAllignedNumber(buf[off], 0, 6),\r\n            isOptional: WavPack.isBitSet(buf[off], 5),\r\n            isOddSize: WavPack.isBitSet(buf[off], 6),\r\n            largeBlock: WavPack.isBitSet(buf[off], 7)\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}