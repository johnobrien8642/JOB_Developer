{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MatroskaParser = void 0;\n\nvar Token = require(\"token-types\");\n\nvar _debug = require(\"debug\");\n\nvar BasicParser_1 = require(\"../common/BasicParser\");\n\nvar types_1 = require(\"./types\");\n\nvar matroskaDtd = require(\"./MatroskaDtd\");\n\nvar debug = _debug('music-metadata:parser:matroska');\n/**\r\n * Extensible Binary Meta Language (EBML) parser\r\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\r\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\r\n *\r\n * WEBM VP8 AUDIO FILE\r\n */\n\n\nvar MatroskaParser = /*#__PURE__*/function (_BasicParser_1$BasicP) {\n  _inherits(MatroskaParser, _BasicParser_1$BasicP);\n\n  var _super = _createSuper(MatroskaParser);\n\n  function MatroskaParser() {\n    var _this;\n\n    _classCallCheck(this, MatroskaParser);\n\n    _this = _super.call(this);\n    _this.padding = 0;\n    _this.parserMap = new Map();\n    _this.ebmlMaxIDLength = 4;\n    _this.ebmlMaxSizeLength = 8;\n\n    _this.parserMap.set(types_1.DataType.uint, function (e) {\n      return _this.readUint(e);\n    });\n\n    _this.parserMap.set(types_1.DataType.string, function (e) {\n      return _this.readString(e);\n    });\n\n    _this.parserMap.set(types_1.DataType.binary, function (e) {\n      return _this.readBuffer(e);\n    });\n\n    _this.parserMap.set(types_1.DataType.uid, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(e) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return _this.readUint(e);\n\n              case 2:\n                _context.t0 = _context.sent;\n                return _context.abrupt(\"return\", _context.t0 === 1);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n\n    _this.parserMap.set(types_1.DataType.bool, function (e) {\n      return _this.readFlag(e);\n    });\n\n    _this.parserMap.set(types_1.DataType.float, function (e) {\n      return _this.readFloat(e);\n    });\n\n    return _this;\n  }\n  /**\r\n   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\r\n   * @param {INativeMetadataCollector} metadata Output\r\n   * @param {ITokenizer} tokenizer Input\r\n   * @param {IOptions} options Parsing options\r\n   */\n\n\n  _createClass(MatroskaParser, [{\n    key: \"init\",\n    value: function init(metadata, tokenizer, options) {\n      _get(_getPrototypeOf(MatroskaParser.prototype), \"init\", this).call(this, metadata, tokenizer, options);\n\n      return this;\n    }\n  }, {\n    key: \"parse\",\n    value: function () {\n      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this2 = this;\n\n        var matroska, info, timecodeScale, duration, audioTracks, audioTrack;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);\n\n              case 2:\n                matroska = _context2.sent;\n                this.metadata.setFormat('container', \"EBML/\".concat(matroska.ebml.docType));\n\n                if (matroska.segment) {\n                  info = matroska.segment.info;\n\n                  if (info) {\n                    timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;\n                    duration = info.duration * timecodeScale / 1000000000;\n                    this.addTag('segment:title', info.title);\n                    this.metadata.setFormat('duration', duration);\n                  }\n\n                  audioTracks = matroska.segment.tracks;\n\n                  if (audioTracks && audioTracks.entries) {\n                    audioTracks.entries.forEach(function (entry) {\n                      var stream = {\n                        codecName: entry.codecID.replace('A_', '').replace('V_', ''),\n                        codecSettings: entry.codecSettings,\n                        flagDefault: entry.flagDefault,\n                        flagLacing: entry.flagLacing,\n                        flagEnabled: entry.flagEnabled,\n                        language: entry.language,\n                        name: entry.name,\n                        type: entry.trackType,\n                        audio: entry.audio,\n                        video: entry.video\n                      };\n\n                      _this2.metadata.addStreamInfo(stream);\n                    });\n                    audioTrack = audioTracks.entries.filter(function (entry) {\n                      return entry.trackType === types_1.TrackType.audio.valueOf();\n                    }).reduce(function (acc, cur) {\n                      if (!acc) {\n                        return cur;\n                      }\n\n                      if (!acc.flagDefault && cur.flagDefault) {\n                        return cur;\n                      }\n\n                      if (cur.trackNumber && cur.trackNumber < acc.trackNumber) {\n                        return cur;\n                      }\n\n                      return acc;\n                    }, null);\n\n                    if (audioTrack) {\n                      this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));\n                      this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);\n                      this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);\n                    }\n\n                    if (matroska.segment.tags) {\n                      matroska.segment.tags.tag.forEach(function (tag) {\n                        var target = tag.target;\n                        var targetType = target.targetTypeValue ? types_1.TargetType[target.targetTypeValue] : target.targetType ? target.targetType : types_1.TargetType.album;\n                        tag.simpleTags.forEach(function (simpleTag) {\n                          var value = simpleTag.string ? simpleTag.string : simpleTag.binary;\n\n                          _this2.addTag(\"\".concat(targetType, \":\").concat(simpleTag.name), value);\n                        });\n                      });\n                    }\n\n                    if (matroska.segment.attachments) {\n                      matroska.segment.attachments.attachedFiles.filter(function (file) {\n                        return file.mimeType.startsWith('image/');\n                      }).map(function (file) {\n                        return {\n                          data: file.data,\n                          format: file.mimeType,\n                          description: file.description,\n                          name: file.name\n                        };\n                      }).forEach(function (picture) {\n                        _this2.addTag('picture', picture);\n                      });\n                    }\n                  }\n                }\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function parse() {\n        return _parse.apply(this, arguments);\n      }\n\n      return parse;\n    }()\n  }, {\n    key: \"parseContainer\",\n    value: function () {\n      var _parseContainer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(container, posDone, path) {\n        var tree, element, type, res;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                tree = {};\n\n              case 1:\n                if (!(this.tokenizer.position < posDone)) {\n                  _context3.next = 42;\n                  break;\n                }\n\n                element = void 0;\n                _context3.prev = 3;\n                _context3.next = 6;\n                return this.readElement();\n\n              case 6:\n                element = _context3.sent;\n                _context3.next = 14;\n                break;\n\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](3);\n\n                if (!(_context3.t0.message === 'End-Of-Stream')) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                return _context3.abrupt(\"break\", 42);\n\n              case 13:\n                throw _context3.t0;\n\n              case 14:\n                type = container[element.id];\n\n                if (!type) {\n                  _context3.next = 29;\n                  break;\n                }\n\n                debug(\"Element: name=\".concat(type.name, \", container=\").concat(!!type.container));\n\n                if (!type.container) {\n                  _context3.next = 24;\n                  break;\n                }\n\n                _context3.next = 20;\n                return this.parseContainer(type.container, element.len >= 0 ? this.tokenizer.position + element.len : -1, path.concat([type.name]));\n\n              case 20:\n                res = _context3.sent;\n\n                if (type.multiple) {\n                  if (!tree[type.name]) {\n                    tree[type.name] = [];\n                  }\n\n                  tree[type.name].push(res);\n                } else {\n                  tree[type.name] = res;\n                }\n\n                _context3.next = 27;\n                break;\n\n              case 24:\n                _context3.next = 26;\n                return this.parserMap.get(type.value)(element);\n\n              case 26:\n                tree[type.name] = _context3.sent;\n\n              case 27:\n                _context3.next = 40;\n                break;\n\n              case 29:\n                _context3.t1 = element.id;\n                _context3.next = _context3.t1 === 0xec ? 32 : 36;\n                break;\n\n              case 32:\n                // void\n                this.padding += element.len;\n                _context3.next = 35;\n                return this.tokenizer.ignore(element.len);\n\n              case 35:\n                return _context3.abrupt(\"break\", 40);\n\n              case 36:\n                debug(\"parseEbml: path=\".concat(path.join('/'), \", unknown element: id=\").concat(element.id.toString(16)));\n                this.padding += element.len;\n                _context3.next = 40;\n                return this.tokenizer.ignore(element.len);\n\n              case 40:\n                _context3.next = 1;\n                break;\n\n              case 42:\n                return _context3.abrupt(\"return\", tree);\n\n              case 43:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 9]]);\n      }));\n\n      function parseContainer(_x2, _x3, _x4) {\n        return _parseContainer.apply(this, arguments);\n      }\n\n      return parseContainer;\n    }()\n  }, {\n    key: \"readVintData\",\n    value: function () {\n      var _readVintData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(maxLength) {\n        var msb, mask, oc, id;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.tokenizer.peekNumber(Token.UINT8);\n\n              case 2:\n                msb = _context4.sent;\n                mask = 0x80;\n                oc = 1; // Calculate VINT_WIDTH\n\n              case 5:\n                if (!((msb & mask) === 0)) {\n                  _context4.next = 12;\n                  break;\n                }\n\n                if (!(oc > maxLength)) {\n                  _context4.next = 8;\n                  break;\n                }\n\n                throw new Error('VINT value exceeding maximum size');\n\n              case 8:\n                ++oc;\n                mask >>= 1;\n                _context4.next = 5;\n                break;\n\n              case 12:\n                id = Buffer.alloc(oc);\n                _context4.next = 15;\n                return this.tokenizer.readBuffer(id);\n\n              case 15:\n                return _context4.abrupt(\"return\", id);\n\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function readVintData(_x5) {\n        return _readVintData.apply(this, arguments);\n      }\n\n      return readVintData;\n    }()\n  }, {\n    key: \"readElement\",\n    value: function () {\n      var _readElement = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var id, lenField, nrLen;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.readVintData(this.ebmlMaxIDLength);\n\n              case 2:\n                id = _context5.sent;\n                _context5.next = 5;\n                return this.readVintData(this.ebmlMaxSizeLength);\n\n              case 5:\n                lenField = _context5.sent;\n                lenField[0] ^= 0x80 >> lenField.length - 1;\n                nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer\n\n                return _context5.abrupt(\"return\", {\n                  id: id.readUIntBE(0, id.length),\n                  len: lenField.readUIntBE(lenField.length - nrLen, nrLen)\n                });\n\n              case 9:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function readElement() {\n        return _readElement.apply(this, arguments);\n      }\n\n      return readElement;\n    }()\n  }, {\n    key: \"isMaxValue\",\n    value: function isMaxValue(vintData) {\n      if (vintData.length === this.ebmlMaxSizeLength) {\n        for (var n = 1; n < this.ebmlMaxSizeLength; ++n) {\n          if (vintData[n] !== 0xff) return false;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"readFloat\",\n    value: function () {\n      var _readFloat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(e) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.t0 = e.len;\n                _context6.next = _context6.t0 === 0 ? 3 : _context6.t0 === 4 ? 4 : _context6.t0 === 8 ? 5 : _context6.t0 === 10 ? 6 : 7;\n                break;\n\n              case 3:\n                return _context6.abrupt(\"return\", 0.0);\n\n              case 4:\n                return _context6.abrupt(\"return\", this.tokenizer.readNumber(Token.Float32_BE));\n\n              case 5:\n                return _context6.abrupt(\"return\", this.tokenizer.readNumber(Token.Float64_BE));\n\n              case 6:\n                return _context6.abrupt(\"return\", this.tokenizer.readNumber(Token.Float64_BE));\n\n              case 7:\n                throw new Error(\"Invalid IEEE-754 float length: \".concat(e.len));\n\n              case 8:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function readFloat(_x6) {\n        return _readFloat.apply(this, arguments);\n      }\n\n      return readFloat;\n    }()\n  }, {\n    key: \"readFlag\",\n    value: function () {\n      var _readFlag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(e) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.readUint(e);\n\n              case 2:\n                _context7.t0 = _context7.sent;\n                return _context7.abrupt(\"return\", _context7.t0 === 1);\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function readFlag(_x7) {\n        return _readFlag.apply(this, arguments);\n      }\n\n      return readFlag;\n    }()\n  }, {\n    key: \"readUint\",\n    value: function () {\n      var _readUint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(e) {\n        var buf, nrLen;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.readBuffer(e);\n\n              case 2:\n                buf = _context8.sent;\n                nrLen = Math.min(6, e.len); // JavaScript can max read 6 bytes integer\n\n                return _context8.abrupt(\"return\", buf.readUIntBE(e.len - nrLen, nrLen));\n\n              case 5:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function readUint(_x8) {\n        return _readUint.apply(this, arguments);\n      }\n\n      return readUint;\n    }()\n  }, {\n    key: \"readString\",\n    value: function () {\n      var _readString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(e) {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                return _context9.abrupt(\"return\", this.tokenizer.readToken(new Token.StringType(e.len, 'utf-8')));\n\n              case 1:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function readString(_x9) {\n        return _readString.apply(this, arguments);\n      }\n\n      return readString;\n    }()\n  }, {\n    key: \"readBuffer\",\n    value: function () {\n      var _readBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(e) {\n        var buf;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                buf = Buffer.alloc(e.len);\n                _context10.next = 3;\n                return this.tokenizer.readBuffer(buf);\n\n              case 3:\n                return _context10.abrupt(\"return\", buf);\n\n              case 4:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function readBuffer(_x10) {\n        return _readBuffer.apply(this, arguments);\n      }\n\n      return readBuffer;\n    }()\n  }, {\n    key: \"addTag\",\n    value: function addTag(tagId, value) {\n      this.metadata.addTag('matroska', tagId, value);\n    }\n  }]);\n\n  return MatroskaParser;\n}(BasicParser_1.BasicParser);\n\nexports.MatroskaParser = MatroskaParser;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/matroska/MatroskaParser.js"],"names":["Object","defineProperty","exports","value","MatroskaParser","Token","require","_debug","BasicParser_1","types_1","matroskaDtd","debug","padding","parserMap","Map","ebmlMaxIDLength","ebmlMaxSizeLength","set","DataType","uint","e","readUint","string","readString","binary","readBuffer","uid","bool","readFlag","float","readFloat","metadata","tokenizer","options","parseContainer","elements","fileInfo","size","matroska","setFormat","ebml","docType","segment","info","timecodeScale","duration","addTag","title","audioTracks","tracks","entries","forEach","entry","stream","codecName","codecID","replace","codecSettings","flagDefault","flagLacing","flagEnabled","language","name","type","trackType","audio","video","addStreamInfo","audioTrack","filter","TrackType","valueOf","reduce","acc","cur","trackNumber","samplingFrequency","channels","tags","tag","target","targetType","targetTypeValue","TargetType","album","simpleTags","simpleTag","attachments","attachedFiles","file","mimeType","startsWith","map","data","format","description","picture","container","posDone","path","tree","position","element","readElement","message","id","len","concat","res","multiple","push","get","ignore","join","toString","maxLength","peekNumber","UINT8","msb","mask","oc","Error","Buffer","alloc","readVintData","lenField","length","nrLen","Math","min","readUIntBE","vintData","n","readNumber","Float32_BE","Float64_BE","buf","readToken","StringType","tagId","BasicParser"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MatroskaParser = void 0;\r\nconst Token = require(\"token-types\");\r\nconst _debug = require(\"debug\");\r\nconst BasicParser_1 = require(\"../common/BasicParser\");\r\nconst types_1 = require(\"./types\");\r\nconst matroskaDtd = require(\"./MatroskaDtd\");\r\nconst debug = _debug('music-metadata:parser:matroska');\r\n/**\r\n * Extensible Binary Meta Language (EBML) parser\r\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\r\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\r\n *\r\n * WEBM VP8 AUDIO FILE\r\n */\r\nclass MatroskaParser extends BasicParser_1.BasicParser {\r\n    constructor() {\r\n        super();\r\n        this.padding = 0;\r\n        this.parserMap = new Map();\r\n        this.ebmlMaxIDLength = 4;\r\n        this.ebmlMaxSizeLength = 8;\r\n        this.parserMap.set(types_1.DataType.uint, e => this.readUint(e));\r\n        this.parserMap.set(types_1.DataType.string, e => this.readString(e));\r\n        this.parserMap.set(types_1.DataType.binary, e => this.readBuffer(e));\r\n        this.parserMap.set(types_1.DataType.uid, async (e) => await this.readUint(e) === 1);\r\n        this.parserMap.set(types_1.DataType.bool, e => this.readFlag(e));\r\n        this.parserMap.set(types_1.DataType.float, e => this.readFloat(e));\r\n    }\r\n    /**\r\n     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\r\n     * @param {INativeMetadataCollector} metadata Output\r\n     * @param {ITokenizer} tokenizer Input\r\n     * @param {IOptions} options Parsing options\r\n     */\r\n    init(metadata, tokenizer, options) {\r\n        super.init(metadata, tokenizer, options);\r\n        return this;\r\n    }\r\n    async parse() {\r\n        const matroska = await this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);\r\n        this.metadata.setFormat('container', `EBML/${matroska.ebml.docType}`);\r\n        if (matroska.segment) {\r\n            const info = matroska.segment.info;\r\n            if (info) {\r\n                const timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;\r\n                const duration = info.duration * timecodeScale / 1000000000;\r\n                this.addTag('segment:title', info.title);\r\n                this.metadata.setFormat('duration', duration);\r\n            }\r\n            const audioTracks = matroska.segment.tracks;\r\n            if (audioTracks && audioTracks.entries) {\r\n                audioTracks.entries.forEach(entry => {\r\n                    const stream = {\r\n                        codecName: entry.codecID.replace('A_', '').replace('V_', ''),\r\n                        codecSettings: entry.codecSettings,\r\n                        flagDefault: entry.flagDefault,\r\n                        flagLacing: entry.flagLacing,\r\n                        flagEnabled: entry.flagEnabled,\r\n                        language: entry.language,\r\n                        name: entry.name,\r\n                        type: entry.trackType,\r\n                        audio: entry.audio,\r\n                        video: entry.video\r\n                    };\r\n                    this.metadata.addStreamInfo(stream);\r\n                });\r\n                const audioTrack = audioTracks.entries\r\n                    .filter(entry => {\r\n                    return entry.trackType === types_1.TrackType.audio.valueOf();\r\n                })\r\n                    .reduce((acc, cur) => {\r\n                    if (!acc) {\r\n                        return cur;\r\n                    }\r\n                    if (!acc.flagDefault && cur.flagDefault) {\r\n                        return cur;\r\n                    }\r\n                    if (cur.trackNumber && cur.trackNumber < acc.trackNumber) {\r\n                        return cur;\r\n                    }\r\n                    return acc;\r\n                }, null);\r\n                if (audioTrack) {\r\n                    this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));\r\n                    this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);\r\n                    this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);\r\n                }\r\n                if (matroska.segment.tags) {\r\n                    matroska.segment.tags.tag.forEach(tag => {\r\n                        const target = tag.target;\r\n                        const targetType = target.targetTypeValue ? types_1.TargetType[target.targetTypeValue] : (target.targetType ? target.targetType : types_1.TargetType.album);\r\n                        tag.simpleTags.forEach(simpleTag => {\r\n                            const value = simpleTag.string ? simpleTag.string : simpleTag.binary;\r\n                            this.addTag(`${targetType}:${simpleTag.name}`, value);\r\n                        });\r\n                    });\r\n                }\r\n                if (matroska.segment.attachments) {\r\n                    matroska.segment.attachments.attachedFiles\r\n                        .filter(file => file.mimeType.startsWith('image/'))\r\n                        .map(file => {\r\n                        return {\r\n                            data: file.data,\r\n                            format: file.mimeType,\r\n                            description: file.description,\r\n                            name: file.name\r\n                        };\r\n                    }).forEach(picture => {\r\n                        this.addTag('picture', picture);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    async parseContainer(container, posDone, path) {\r\n        const tree = {};\r\n        while (this.tokenizer.position < posDone) {\r\n            let element;\r\n            try {\r\n                element = await this.readElement();\r\n            }\r\n            catch (error) {\r\n                if (error.message === 'End-Of-Stream') {\r\n                    break;\r\n                }\r\n                throw error;\r\n            }\r\n            const type = container[element.id];\r\n            if (type) {\r\n                debug(`Element: name=${type.name}, container=${!!type.container}`);\r\n                if (type.container) {\r\n                    const res = await this.parseContainer(type.container, element.len >= 0 ? this.tokenizer.position + element.len : -1, path.concat([type.name]));\r\n                    if (type.multiple) {\r\n                        if (!tree[type.name]) {\r\n                            tree[type.name] = [];\r\n                        }\r\n                        tree[type.name].push(res);\r\n                    }\r\n                    else {\r\n                        tree[type.name] = res;\r\n                    }\r\n                }\r\n                else {\r\n                    tree[type.name] = await this.parserMap.get(type.value)(element);\r\n                }\r\n            }\r\n            else {\r\n                switch (element.id) {\r\n                    case 0xec: // void\r\n                        this.padding += element.len;\r\n                        await this.tokenizer.ignore(element.len);\r\n                        break;\r\n                    default:\r\n                        debug(`parseEbml: path=${path.join('/')}, unknown element: id=${element.id.toString(16)}`);\r\n                        this.padding += element.len;\r\n                        await this.tokenizer.ignore(element.len);\r\n                }\r\n            }\r\n        }\r\n        return tree;\r\n    }\r\n    async readVintData(maxLength) {\r\n        const msb = await this.tokenizer.peekNumber(Token.UINT8);\r\n        let mask = 0x80;\r\n        let oc = 1;\r\n        // Calculate VINT_WIDTH\r\n        while ((msb & mask) === 0) {\r\n            if (oc > maxLength) {\r\n                throw new Error('VINT value exceeding maximum size');\r\n            }\r\n            ++oc;\r\n            mask >>= 1;\r\n        }\r\n        const id = Buffer.alloc(oc);\r\n        await this.tokenizer.readBuffer(id);\r\n        return id;\r\n    }\r\n    async readElement() {\r\n        const id = await this.readVintData(this.ebmlMaxIDLength);\r\n        const lenField = await this.readVintData(this.ebmlMaxSizeLength);\r\n        lenField[0] ^= 0x80 >> (lenField.length - 1);\r\n        const nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer\r\n        return {\r\n            id: id.readUIntBE(0, id.length),\r\n            len: lenField.readUIntBE(lenField.length - nrLen, nrLen)\r\n        };\r\n    }\r\n    isMaxValue(vintData) {\r\n        if (vintData.length === this.ebmlMaxSizeLength) {\r\n            for (let n = 1; n < this.ebmlMaxSizeLength; ++n) {\r\n                if (vintData[n] !== 0xff)\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    async readFloat(e) {\r\n        switch (e.len) {\r\n            case 0:\r\n                return 0.0;\r\n            case 4:\r\n                return this.tokenizer.readNumber(Token.Float32_BE);\r\n            case 8:\r\n                return this.tokenizer.readNumber(Token.Float64_BE);\r\n            case 10:\r\n                return this.tokenizer.readNumber(Token.Float64_BE);\r\n            default:\r\n                throw new Error(`Invalid IEEE-754 float length: ${e.len}`);\r\n        }\r\n    }\r\n    async readFlag(e) {\r\n        return (await this.readUint(e)) === 1;\r\n    }\r\n    async readUint(e) {\r\n        const buf = await this.readBuffer(e);\r\n        const nrLen = Math.min(6, e.len); // JavaScript can max read 6 bytes integer\r\n        return buf.readUIntBE(e.len - nrLen, nrLen);\r\n    }\r\n    async readString(e) {\r\n        return this.tokenizer.readToken(new Token.StringType(e.len, 'utf-8'));\r\n    }\r\n    async readBuffer(e) {\r\n        const buf = Buffer.alloc(e.len);\r\n        await this.tokenizer.readBuffer(buf);\r\n        return buf;\r\n    }\r\n    addTag(tagId, value) {\r\n        this.metadata.addTag('matroska', tagId, value);\r\n    }\r\n}\r\nexports.MatroskaParser = MatroskaParser;\r\n"]},"metadata":{},"sourceType":"script"}