{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DsfParser = void 0;\n\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\n\nconst _debug = require(\"debug\");\n\nconst DsfChunk_1 = require(\"./DsfChunk\");\n\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\n\nconst debug = _debug('music-metadata:parser:DSF');\n/**\r\n * DSF (dsd stream file) File Parser\r\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\r\n */\n\n\nclass DsfParser extends AbstractID3Parser_1.AbstractID3Parser {\n  async _parse() {\n    const p0 = this.tokenizer.position; // mark start position, normally 0\n\n    const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n    if (chunkHeader.id !== 'DSD ') throw new Error('Invalid chunk signature');\n    this.metadata.setFormat('container', 'DSF');\n    this.metadata.setFormat('lossless', true);\n    const dsdChunk = await this.tokenizer.readToken(DsfChunk_1.DsdChunk);\n\n    if (dsdChunk.metadataPointer === 0) {\n      debug(`No ID3v2 tag present`);\n    } else {\n      debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\n      await this.parseChunks(dsdChunk.fileSize - chunkHeader.size); // Jump to ID3 header\n\n      await this.tokenizer.ignore(dsdChunk.metadataPointer - this.tokenizer.position - p0);\n      return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\n    }\n  }\n\n  async parseChunks(bytesRemaining) {\n    while (bytesRemaining >= DsfChunk_1.ChunkHeader.len) {\n      const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n      debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\n\n      switch (chunkHeader.id) {\n        case 'fmt ':\n          const formatChunk = await this.tokenizer.readToken(DsfChunk_1.FormatChunk);\n          this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\n          this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\n          this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\n          this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\n          this.metadata.setFormat('duration', formatChunk.sampleCount / formatChunk.samplingFrequency);\n          const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\n          this.metadata.setFormat('bitrate', bitrate);\n          return;\n        // We got what we want, stop further processing of chunks\n\n        default:\n          this.tokenizer.ignore(chunkHeader.size - DsfChunk_1.ChunkHeader.len);\n          break;\n      }\n\n      bytesRemaining -= chunkHeader.size;\n    }\n  }\n\n}\n\nexports.DsfParser = DsfParser;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/JOB_Developer/client/node_modules/music-metadata/lib/dsf/DsfParser.js"],"names":["Object","defineProperty","exports","value","DsfParser","AbstractID3Parser_1","require","_debug","DsfChunk_1","ID3v2Parser_1","debug","AbstractID3Parser","_parse","p0","tokenizer","position","chunkHeader","readToken","ChunkHeader","id","Error","metadata","setFormat","dsdChunk","DsdChunk","metadataPointer","parseChunks","fileSize","size","ignore","ID3v2Parser","parse","options","bytesRemaining","len","formatChunk","FormatChunk","channelNum","samplingFrequency","bitsPerSample","sampleCount","bitrate"],"mappings":"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","sourcesContent":["'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DsfParser = void 0;\r\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\r\nconst _debug = require(\"debug\");\r\nconst DsfChunk_1 = require(\"./DsfChunk\");\r\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\r\nconst debug = _debug('music-metadata:parser:DSF');\r\n/**\r\n * DSF (dsd stream file) File Parser\r\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\r\n */\r\nclass DsfParser extends AbstractID3Parser_1.AbstractID3Parser {\r\n    async _parse() {\r\n        const p0 = this.tokenizer.position; // mark start position, normally 0\r\n        const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\r\n        if (chunkHeader.id !== 'DSD ')\r\n            throw new Error('Invalid chunk signature');\r\n        this.metadata.setFormat('container', 'DSF');\r\n        this.metadata.setFormat('lossless', true);\r\n        const dsdChunk = await this.tokenizer.readToken(DsfChunk_1.DsdChunk);\r\n        if (dsdChunk.metadataPointer === 0) {\r\n            debug(`No ID3v2 tag present`);\r\n        }\r\n        else {\r\n            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\r\n            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\r\n            // Jump to ID3 header\r\n            await this.tokenizer.ignore(dsdChunk.metadataPointer - this.tokenizer.position - p0);\r\n            return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\r\n        }\r\n    }\r\n    async parseChunks(bytesRemaining) {\r\n        while (bytesRemaining >= DsfChunk_1.ChunkHeader.len) {\r\n            const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\r\n            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\r\n            switch (chunkHeader.id) {\r\n                case 'fmt ':\r\n                    const formatChunk = await this.tokenizer.readToken(DsfChunk_1.FormatChunk);\r\n                    this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\r\n                    this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\r\n                    this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\r\n                    this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\r\n                    this.metadata.setFormat('duration', formatChunk.sampleCount / formatChunk.samplingFrequency);\r\n                    const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\r\n                    this.metadata.setFormat('bitrate', bitrate);\r\n                    return; // We got what we want, stop further processing of chunks\r\n                default:\r\n                    this.tokenizer.ignore(chunkHeader.size - DsfChunk_1.ChunkHeader.len);\r\n                    break;\r\n            }\r\n            bytesRemaining -= chunkHeader.size;\r\n        }\r\n    }\r\n}\r\nexports.DsfParser = DsfParser;\r\n"]},"metadata":{},"sourceType":"script"}