{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readXingHeader = exports.XingHeaderFlags = exports.LameEncoderVersion = exports.InfoTagHeaderTag = void 0;\n\nconst Token = require(\"token-types\");\n\nconst Util_1 = require(\"../common/Util\");\n\nconst ExtendedLameHeader_1 = require(\"./ExtendedLameHeader\");\n/**\r\n * Info Tag: Xing, LAME\r\n */\n\n\nexports.InfoTagHeaderTag = new Token.StringType(4, 'ascii');\n/**\r\n * LAME TAG value\r\n * Did not find any official documentation for this\r\n * Value e.g.: \"3.98.4\"\r\n */\n\nexports.LameEncoderVersion = new Token.StringType(6, 'ascii');\n/**\r\n * Info Tag\r\n * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\r\n */\n\nexports.XingHeaderFlags = {\n  len: 4,\n  get: (buf, off) => {\n    return {\n      frames: Util_1.default.isBitSet(buf, off, 31),\n      bytes: Util_1.default.isBitSet(buf, off, 30),\n      toc: Util_1.default.isBitSet(buf, off, 29),\n      vbrScale: Util_1.default.isBitSet(buf, off, 28)\n    };\n  }\n}; // /**\n//  * XING Header Tag\n//  * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n//  */\n\nasync function readXingHeader(tokenizer) {\n  const flags = await tokenizer.readToken(exports.XingHeaderFlags);\n  const xingInfoTag = {};\n\n  if (flags.frames) {\n    xingInfoTag.numFrames = await tokenizer.readToken(Token.UINT32_BE);\n  }\n\n  if (flags.bytes) {\n    xingInfoTag.streamSize = await tokenizer.readToken(Token.UINT32_BE);\n  }\n\n  if (flags.toc) {\n    xingInfoTag.toc = Buffer.alloc(100);\n    await tokenizer.readBuffer(xingInfoTag.toc);\n  }\n\n  if (flags.vbrScale) {\n    xingInfoTag.vbrScale = await tokenizer.readToken(Token.UINT32_BE);\n  }\n\n  const lameTag = await tokenizer.peekToken(new Token.StringType(4, 'ascii'));\n\n  if (lameTag === 'LAME') {\n    await tokenizer.ignore(4);\n    xingInfoTag.lame = {\n      version: await tokenizer.readToken(new Token.StringType(5, 'ascii'))\n    };\n    const match = xingInfoTag.lame.version.match(/\\d+.\\d+/g);\n\n    if (match) {\n      const majorMinorVersion = xingInfoTag.lame.version.match(/\\d+.\\d+/g)[0]; // e.g. 3.97\n\n      const version = majorMinorVersion.split('.').map(n => parseInt(n, 10));\n\n      if (version[0] >= 3 && version[1] >= 90) {\n        xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader_1.ExtendedLameHeader);\n      }\n    }\n  }\n\n  return xingInfoTag;\n}\n\nexports.readXingHeader = readXingHeader;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/JOB_Developer/client/node_modules/music-metadata/lib/mpeg/XingTag.js"],"names":["Object","defineProperty","exports","value","readXingHeader","XingHeaderFlags","LameEncoderVersion","InfoTagHeaderTag","Token","require","Util_1","ExtendedLameHeader_1","StringType","len","get","buf","off","frames","default","isBitSet","bytes","toc","vbrScale","tokenizer","flags","readToken","xingInfoTag","numFrames","UINT32_BE","streamSize","Buffer","alloc","readBuffer","lameTag","peekToken","ignore","lame","version","match","majorMinorVersion","split","map","n","parseInt","extended","ExtendedLameHeader"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.readXingHeader = exports.XingHeaderFlags = exports.LameEncoderVersion = exports.InfoTagHeaderTag = void 0;\r\nconst Token = require(\"token-types\");\r\nconst Util_1 = require(\"../common/Util\");\r\nconst ExtendedLameHeader_1 = require(\"./ExtendedLameHeader\");\r\n/**\r\n * Info Tag: Xing, LAME\r\n */\r\nexports.InfoTagHeaderTag = new Token.StringType(4, 'ascii');\r\n/**\r\n * LAME TAG value\r\n * Did not find any official documentation for this\r\n * Value e.g.: \"3.98.4\"\r\n */\r\nexports.LameEncoderVersion = new Token.StringType(6, 'ascii');\r\n/**\r\n * Info Tag\r\n * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\r\n */\r\nexports.XingHeaderFlags = {\r\n    len: 4,\r\n    get: (buf, off) => {\r\n        return {\r\n            frames: Util_1.default.isBitSet(buf, off, 31),\r\n            bytes: Util_1.default.isBitSet(buf, off, 30),\r\n            toc: Util_1.default.isBitSet(buf, off, 29),\r\n            vbrScale: Util_1.default.isBitSet(buf, off, 28)\r\n        };\r\n    }\r\n};\r\n// /**\r\n//  * XING Header Tag\r\n//  * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\r\n//  */\r\nasync function readXingHeader(tokenizer) {\r\n    const flags = await tokenizer.readToken(exports.XingHeaderFlags);\r\n    const xingInfoTag = {};\r\n    if (flags.frames) {\r\n        xingInfoTag.numFrames = await tokenizer.readToken(Token.UINT32_BE);\r\n    }\r\n    if (flags.bytes) {\r\n        xingInfoTag.streamSize = await tokenizer.readToken(Token.UINT32_BE);\r\n    }\r\n    if (flags.toc) {\r\n        xingInfoTag.toc = Buffer.alloc(100);\r\n        await tokenizer.readBuffer(xingInfoTag.toc);\r\n    }\r\n    if (flags.vbrScale) {\r\n        xingInfoTag.vbrScale = await tokenizer.readToken(Token.UINT32_BE);\r\n    }\r\n    const lameTag = await tokenizer.peekToken(new Token.StringType(4, 'ascii'));\r\n    if (lameTag === 'LAME') {\r\n        await tokenizer.ignore(4);\r\n        xingInfoTag.lame = {\r\n            version: await tokenizer.readToken(new Token.StringType(5, 'ascii'))\r\n        };\r\n        const match = xingInfoTag.lame.version.match(/\\d+.\\d+/g);\r\n        if (match) {\r\n            const majorMinorVersion = xingInfoTag.lame.version.match(/\\d+.\\d+/g)[0]; // e.g. 3.97\r\n            const version = majorMinorVersion.split('.').map(n => parseInt(n, 10));\r\n            if (version[0] >= 3 && version[1] >= 90) {\r\n                xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader_1.ExtendedLameHeader);\r\n            }\r\n        }\r\n    }\r\n    return xingInfoTag;\r\n}\r\nexports.readXingHeader = readXingHeader;\r\n"]},"metadata":{},"sourceType":"script"}