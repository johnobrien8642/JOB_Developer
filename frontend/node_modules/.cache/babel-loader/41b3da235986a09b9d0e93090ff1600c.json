{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.joinArtists = exports.MetadataCollector = void 0;\n\nvar type_1 = require(\"../type\");\n\nvar _debug = require(\"debug\");\n\nvar GenericTagTypes_1 = require(\"./GenericTagTypes\");\n\nvar CombinedTagMapper_1 = require(\"./CombinedTagMapper\");\n\nvar GenericTagMapper_1 = require(\"./GenericTagMapper\");\n\nvar Util_1 = require(\"./Util\");\n\nvar FileType = require(\"file-type/core\");\n\nvar debug = _debug('music-metadata:collector');\n\nvar TagPriority = ['matroska', 'APEv2', 'vorbis', 'ID3v2.4', 'ID3v2.3', 'ID3v2.2', 'exif', 'asf', 'iTunes', 'ID3v1'];\n/**\r\n * Provided to the parser to uodate the metadata result.\r\n * Responsible for triggering async updates\r\n */\n\nvar MetadataCollector = /*#__PURE__*/function () {\n  function MetadataCollector(opts) {\n    _classCallCheck(this, MetadataCollector);\n\n    this.opts = opts;\n    this.format = {\n      tagTypes: [],\n      trackInfo: []\n    };\n    this.native = {};\n    this.common = {\n      track: {\n        no: null,\n        of: null\n      },\n      disk: {\n        no: null,\n        of: null\n      },\n      movementIndex: {}\n    };\n    this.quality = {\n      warnings: []\n    };\n    /**\r\n     * Keeps track of origin priority for each mapped id\r\n     */\n\n    this.commonOrigin = {};\n    /**\r\n     * Maps a tag type to a priority\r\n     */\n\n    this.originPriority = {};\n    this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();\n    var priority = 1;\n\n    var _iterator = _createForOfIteratorHelper(TagPriority),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var tagType = _step.value;\n        this.originPriority[tagType] = priority++;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this.originPriority.artificial = 500; // Filled using alternative tags\n\n    this.originPriority.id3v1 = 600; // Consider worst due to field length limit\n  }\n  /**\r\n   * @returns {boolean} true if one or more tags have been found\r\n   */\n\n\n  _createClass(MetadataCollector, [{\n    key: \"hasAny\",\n    value: function hasAny() {\n      return Object.keys(this.native).length > 0;\n    }\n  }, {\n    key: \"addStreamInfo\",\n    value: function addStreamInfo(streamInfo) {\n      debug(\"streamInfo: type=\".concat(type_1.TrackType[streamInfo.type], \", codec=\").concat(streamInfo.codecName));\n      this.format.trackInfo.push(streamInfo);\n    }\n  }, {\n    key: \"setFormat\",\n    value: function setFormat(key, value) {\n      debug(\"format: \".concat(key, \" = \").concat(value));\n      this.format[key] = value; // as any to override readonly\n\n      if (this.opts.observer) {\n        this.opts.observer({\n          metadata: this,\n          tag: {\n            type: 'format',\n            id: key,\n            value: value\n          }\n        });\n      }\n    }\n  }, {\n    key: \"addTag\",\n    value: function addTag(tagType, tagId, value) {\n      debug(\"tag \".concat(tagType, \".\").concat(tagId, \" = \").concat(value));\n\n      if (!this.native[tagType]) {\n        this.format.tagTypes.push(tagType);\n        this.native[tagType] = [];\n      }\n\n      this.native[tagType].push({\n        id: tagId,\n        value: value\n      });\n      this.toCommon(tagType, tagId, value);\n    }\n  }, {\n    key: \"addWarning\",\n    value: function addWarning(warning) {\n      this.quality.warnings.push({\n        message: warning\n      });\n    }\n  }, {\n    key: \"postMap\",\n    value: function postMap(tagType, tag) {\n      var _this = this;\n\n      // Common tag (alias) found\n      // check if we need to do something special with common tag\n      // if the event has been aliased then we need to clean it before\n      // it is emitted to the user. e.g. genre (20) -> Electronic\n      switch (tag.id) {\n        case 'artist':\n          if (this.commonOrigin.artist === this.originPriority[tagType]) {\n            // Assume the artist field is used as artists\n            return this.postMap('artificial', {\n              id: 'artists',\n              value: tag.value\n            });\n          }\n\n          if (!this.common.artists) {\n            // Fill artists using artist source\n            this.setGenericTag('artificial', {\n              id: 'artists',\n              value: tag.value\n            });\n          }\n\n          break;\n\n        case 'artists':\n          if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {\n            if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {\n              // Fill artist using artists source\n              var artists = (this.common.artists || []).concat([tag.value]);\n              var value = joinArtists(artists);\n              var artistTag = {\n                id: 'artist',\n                value: value\n              };\n              this.setGenericTag('artificial', artistTag);\n            }\n          }\n\n          break;\n\n        case 'picture':\n          this.postFixPicture(tag.value).then(function (picture) {\n            if (picture !== null) {\n              tag.value = picture;\n\n              _this.setGenericTag(tagType, tag);\n            }\n          });\n          return;\n\n        case 'totaltracks':\n          this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n          return;\n\n        case 'totaldiscs':\n          this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n          return;\n\n        case 'movementTotal':\n          this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n          return;\n\n        case 'track':\n        case 'disk':\n        case 'movementIndex':\n          var of = this.common[tag.id].of; // store of value, maybe maybe overwritten\n\n          this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);\n          this.common[tag.id].of = of != null ? of : this.common[tag.id].of;\n          return;\n\n        case 'year':\n        case 'originalyear':\n          tag.value = parseInt(tag.value, 10);\n          break;\n\n        case 'date':\n          // ToDo: be more strict on 'YYYY...'\n          var year = parseInt(tag.value.substr(0, 4), 10);\n\n          if (!isNaN(year)) {\n            this.common.year = year;\n          }\n\n          break;\n\n        case 'discogs_label_id':\n        case 'discogs_release_id':\n        case 'discogs_master_release_id':\n        case 'discogs_artist_id':\n        case 'discogs_votes':\n          tag.value = typeof tag.value === 'string' ? parseInt(tag.value, 10) : tag.value;\n          break;\n\n        case 'replaygain_track_gain':\n        case 'replaygain_track_peak':\n        case 'replaygain_album_gain':\n        case 'replaygain_album_peak':\n          tag.value = Util_1.toRatio(tag.value);\n          break;\n\n        case 'replaygain_track_minmax':\n          tag.value = tag.value.split(',').map(function (v) {\n            return parseInt(v, 10);\n          });\n          break;\n\n        case 'replaygain_undo':\n          var minMix = tag.value.split(',').map(function (v) {\n            return parseInt(v, 10);\n          });\n          tag.value = {\n            leftChannel: minMix[0],\n            rightChannel: minMix[1]\n          };\n          break;\n\n        case 'gapless': // iTunes gap-less flag\n\n        case 'compilation':\n        case 'podcast':\n        case 'showMovement':\n          tag.value = tag.value === '1' || tag.value === 1; // boolean\n\n          break;\n\n        case 'isrc':\n          // Only keep unique values\n          if (this.common[tag.id] && this.common[tag.id].indexOf(tag.value) !== -1) return;\n          break;\n\n        default: // nothing to do\n\n      }\n\n      if (tag.value !== null) {\n        this.setGenericTag(tagType, tag);\n      }\n    }\n    /**\r\n     * Convert native tags to common tags\r\n     * @returns {IAudioMetadata} Native + common tags\r\n     */\n\n  }, {\n    key: \"toCommonMetadata\",\n    value: function toCommonMetadata() {\n      return {\n        format: this.format,\n        native: this.native,\n        quality: this.quality,\n        common: this.common\n      };\n    }\n    /**\r\n     * Fix some common issues with picture object\r\n     * @param pictureType\r\n     */\n\n  }, {\n    key: \"postFixPicture\",\n    value: function () {\n      var _postFixPicture = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(picture) {\n        var fileType;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(picture.data && picture.data.length > 0)) {\n                  _context.next = 13;\n                  break;\n                }\n\n                if (picture.format) {\n                  _context.next = 10;\n                  break;\n                }\n\n                _context.next = 4;\n                return FileType.fromBuffer(picture.data);\n\n              case 4:\n                fileType = _context.sent;\n\n                if (!fileType) {\n                  _context.next = 9;\n                  break;\n                }\n\n                picture.format = fileType.mime;\n                _context.next = 10;\n                break;\n\n              case 9:\n                return _context.abrupt(\"return\", null);\n\n              case 10:\n                picture.format = picture.format.toLocaleLowerCase();\n\n                switch (picture.format) {\n                  case 'image/jpg':\n                    picture.format = 'image/jpeg';\n                  // ToDo: register warning\n                }\n\n                return _context.abrupt(\"return\", picture);\n\n              case 13:\n                this.addWarning(\"Empty picture tag found\");\n                return _context.abrupt(\"return\", null);\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function postFixPicture(_x) {\n        return _postFixPicture.apply(this, arguments);\n      }\n\n      return postFixPicture;\n    }()\n    /**\r\n     * Convert native tag to common tags\r\n     */\n\n  }, {\n    key: \"toCommon\",\n    value: function toCommon(tagType, tagId, value) {\n      var tag = {\n        id: tagId,\n        value: value\n      };\n      var genericTag = this.tagMapper.mapTag(tagType, tag, this);\n\n      if (genericTag) {\n        this.postMap(tagType, genericTag);\n      }\n    }\n    /**\r\n     * Set generic tag\r\n     */\n\n  }, {\n    key: \"setGenericTag\",\n    value: function setGenericTag(tagType, tag) {\n      debug(\"common.\".concat(tag.id, \" = \").concat(tag.value));\n      var prio0 = this.commonOrigin[tag.id] || 1000;\n      var prio1 = this.originPriority[tagType];\n\n      if (GenericTagTypes_1.isSingleton(tag.id)) {\n        if (prio1 <= prio0) {\n          this.common[tag.id] = tag.value;\n          this.commonOrigin[tag.id] = prio1;\n        } else {\n          return debug(\"Ignore native tag (singleton): \".concat(tagType, \".\").concat(tag.id, \" = \").concat(tag.value));\n        }\n      } else {\n        if (prio1 === prio0) {\n          if (!GenericTagTypes_1.isUnique(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {\n            this.common[tag.id].push(tag.value);\n          } else {\n            debug(\"Ignore duplicate value: \".concat(tagType, \".\").concat(tag.id, \" = \").concat(tag.value));\n          } // no effect? this.commonOrigin[tag.id] = prio1;\n\n        } else if (prio1 < prio0) {\n          this.common[tag.id] = [tag.value];\n          this.commonOrigin[tag.id] = prio1;\n        } else {\n          return debug(\"Ignore native tag (list): \".concat(tagType, \".\").concat(tag.id, \" = \").concat(tag.value));\n        }\n      }\n\n      if (this.opts.observer) {\n        this.opts.observer({\n          metadata: this,\n          tag: {\n            type: 'common',\n            id: tag.id,\n            value: tag.value\n          }\n        });\n      } // ToDo: trigger metadata event\n\n    }\n  }]);\n\n  return MetadataCollector;\n}();\n\nexports.MetadataCollector = MetadataCollector;\n\nfunction joinArtists(artists) {\n  if (artists.length > 2) {\n    return artists.slice(0, artists.length - 1).join(', ') + ' & ' + artists[artists.length - 1];\n  }\n\n  return artists.join(' & ');\n}\n\nexports.joinArtists = joinArtists;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/common/MetadataCollector.js"],"names":["Object","defineProperty","exports","value","joinArtists","MetadataCollector","type_1","require","_debug","GenericTagTypes_1","CombinedTagMapper_1","GenericTagMapper_1","Util_1","FileType","debug","TagPriority","opts","format","tagTypes","trackInfo","native","common","track","no","of","disk","movementIndex","quality","warnings","commonOrigin","originPriority","tagMapper","CombinedTagMapper","priority","tagType","artificial","id3v1","keys","length","streamInfo","TrackType","type","codecName","push","key","observer","metadata","tag","id","tagId","toCommon","warning","message","artist","postMap","artists","setGenericTag","indexOf","concat","artistTag","postFixPicture","then","picture","CommonTagMapper","toIntOrNull","normalizeTrack","parseInt","year","substr","isNaN","toRatio","split","map","v","minMix","leftChannel","rightChannel","data","fromBuffer","fileType","mime","toLocaleLowerCase","addWarning","genericTag","mapTag","prio0","prio1","isSingleton","isUnique","slice","join"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.joinArtists = exports.MetadataCollector = void 0;\r\nconst type_1 = require(\"../type\");\r\nconst _debug = require(\"debug\");\r\nconst GenericTagTypes_1 = require(\"./GenericTagTypes\");\r\nconst CombinedTagMapper_1 = require(\"./CombinedTagMapper\");\r\nconst GenericTagMapper_1 = require(\"./GenericTagMapper\");\r\nconst Util_1 = require(\"./Util\");\r\nconst FileType = require(\"file-type/core\");\r\nconst debug = _debug('music-metadata:collector');\r\nconst TagPriority = ['matroska', 'APEv2', 'vorbis', 'ID3v2.4', 'ID3v2.3', 'ID3v2.2', 'exif', 'asf', 'iTunes', 'ID3v1'];\r\n/**\r\n * Provided to the parser to uodate the metadata result.\r\n * Responsible for triggering async updates\r\n */\r\nclass MetadataCollector {\r\n    constructor(opts) {\r\n        this.opts = opts;\r\n        this.format = {\r\n            tagTypes: [],\r\n            trackInfo: []\r\n        };\r\n        this.native = {};\r\n        this.common = {\r\n            track: { no: null, of: null },\r\n            disk: { no: null, of: null },\r\n            movementIndex: {}\r\n        };\r\n        this.quality = {\r\n            warnings: []\r\n        };\r\n        /**\r\n         * Keeps track of origin priority for each mapped id\r\n         */\r\n        this.commonOrigin = {};\r\n        /**\r\n         * Maps a tag type to a priority\r\n         */\r\n        this.originPriority = {};\r\n        this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();\r\n        let priority = 1;\r\n        for (const tagType of TagPriority) {\r\n            this.originPriority[tagType] = priority++;\r\n        }\r\n        this.originPriority.artificial = 500; // Filled using alternative tags\r\n        this.originPriority.id3v1 = 600; // Consider worst due to field length limit\r\n    }\r\n    /**\r\n     * @returns {boolean} true if one or more tags have been found\r\n     */\r\n    hasAny() {\r\n        return Object.keys(this.native).length > 0;\r\n    }\r\n    addStreamInfo(streamInfo) {\r\n        debug(`streamInfo: type=${type_1.TrackType[streamInfo.type]}, codec=${streamInfo.codecName}`);\r\n        this.format.trackInfo.push(streamInfo);\r\n    }\r\n    setFormat(key, value) {\r\n        debug(`format: ${key} = ${value}`);\r\n        this.format[key] = value; // as any to override readonly\r\n        if (this.opts.observer) {\r\n            this.opts.observer({ metadata: this, tag: { type: 'format', id: key, value } });\r\n        }\r\n    }\r\n    addTag(tagType, tagId, value) {\r\n        debug(`tag ${tagType}.${tagId} = ${value}`);\r\n        if (!this.native[tagType]) {\r\n            this.format.tagTypes.push(tagType);\r\n            this.native[tagType] = [];\r\n        }\r\n        this.native[tagType].push({ id: tagId, value });\r\n        this.toCommon(tagType, tagId, value);\r\n    }\r\n    addWarning(warning) {\r\n        this.quality.warnings.push({ message: warning });\r\n    }\r\n    postMap(tagType, tag) {\r\n        // Common tag (alias) found\r\n        // check if we need to do something special with common tag\r\n        // if the event has been aliased then we need to clean it before\r\n        // it is emitted to the user. e.g. genre (20) -> Electronic\r\n        switch (tag.id) {\r\n            case 'artist':\r\n                if (this.commonOrigin.artist === this.originPriority[tagType]) {\r\n                    // Assume the artist field is used as artists\r\n                    return this.postMap('artificial', { id: 'artists', value: tag.value });\r\n                }\r\n                if (!this.common.artists) {\r\n                    // Fill artists using artist source\r\n                    this.setGenericTag('artificial', { id: 'artists', value: tag.value });\r\n                }\r\n                break;\r\n            case 'artists':\r\n                if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {\r\n                    if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {\r\n                        // Fill artist using artists source\r\n                        const artists = (this.common.artists || []).concat([tag.value]);\r\n                        const value = joinArtists(artists);\r\n                        const artistTag = { id: 'artist', value };\r\n                        this.setGenericTag('artificial', artistTag);\r\n                    }\r\n                }\r\n                break;\r\n            case 'picture':\r\n                this.postFixPicture(tag.value).then(picture => {\r\n                    if (picture !== null) {\r\n                        tag.value = picture;\r\n                        this.setGenericTag(tagType, tag);\r\n                    }\r\n                });\r\n                return;\r\n            case 'totaltracks':\r\n                this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\r\n                return;\r\n            case 'totaldiscs':\r\n                this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\r\n                return;\r\n            case 'movementTotal':\r\n                this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\r\n                return;\r\n            case 'track':\r\n            case 'disk':\r\n            case 'movementIndex':\r\n                const of = this.common[tag.id].of; // store of value, maybe maybe overwritten\r\n                this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);\r\n                this.common[tag.id].of = of != null ? of : this.common[tag.id].of;\r\n                return;\r\n            case 'year':\r\n            case 'originalyear':\r\n                tag.value = parseInt(tag.value, 10);\r\n                break;\r\n            case 'date':\r\n                // ToDo: be more strict on 'YYYY...'\r\n                const year = parseInt(tag.value.substr(0, 4), 10);\r\n                if (!isNaN(year)) {\r\n                    this.common.year = year;\r\n                }\r\n                break;\r\n            case 'discogs_label_id':\r\n            case 'discogs_release_id':\r\n            case 'discogs_master_release_id':\r\n            case 'discogs_artist_id':\r\n            case 'discogs_votes':\r\n                tag.value = typeof tag.value === 'string' ? parseInt(tag.value, 10) : tag.value;\r\n                break;\r\n            case 'replaygain_track_gain':\r\n            case 'replaygain_track_peak':\r\n            case 'replaygain_album_gain':\r\n            case 'replaygain_album_peak':\r\n                tag.value = Util_1.toRatio(tag.value);\r\n                break;\r\n            case 'replaygain_track_minmax':\r\n                tag.value = tag.value.split(',').map(v => parseInt(v, 10));\r\n                break;\r\n            case 'replaygain_undo':\r\n                const minMix = tag.value.split(',').map(v => parseInt(v, 10));\r\n                tag.value = {\r\n                    leftChannel: minMix[0],\r\n                    rightChannel: minMix[1]\r\n                };\r\n                break;\r\n            case 'gapless': // iTunes gap-less flag\r\n            case 'compilation':\r\n            case 'podcast':\r\n            case 'showMovement':\r\n                tag.value = tag.value === '1' || tag.value === 1; // boolean\r\n                break;\r\n            case 'isrc': // Only keep unique values\r\n                if (this.common[tag.id] && this.common[tag.id].indexOf(tag.value) !== -1)\r\n                    return;\r\n                break;\r\n            default:\r\n            // nothing to do\r\n        }\r\n        if (tag.value !== null) {\r\n            this.setGenericTag(tagType, tag);\r\n        }\r\n    }\r\n    /**\r\n     * Convert native tags to common tags\r\n     * @returns {IAudioMetadata} Native + common tags\r\n     */\r\n    toCommonMetadata() {\r\n        return {\r\n            format: this.format,\r\n            native: this.native,\r\n            quality: this.quality,\r\n            common: this.common\r\n        };\r\n    }\r\n    /**\r\n     * Fix some common issues with picture object\r\n     * @param pictureType\r\n     */\r\n    async postFixPicture(picture) {\r\n        if (picture.data && picture.data.length > 0) {\r\n            if (!picture.format) {\r\n                const fileType = await FileType.fromBuffer(picture.data);\r\n                if (fileType) {\r\n                    picture.format = fileType.mime;\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n            picture.format = picture.format.toLocaleLowerCase();\r\n            switch (picture.format) {\r\n                case 'image/jpg':\r\n                    picture.format = 'image/jpeg'; // ToDo: register warning\r\n            }\r\n            return picture;\r\n        }\r\n        this.addWarning(`Empty picture tag found`);\r\n        return null;\r\n    }\r\n    /**\r\n     * Convert native tag to common tags\r\n     */\r\n    toCommon(tagType, tagId, value) {\r\n        const tag = { id: tagId, value };\r\n        const genericTag = this.tagMapper.mapTag(tagType, tag, this);\r\n        if (genericTag) {\r\n            this.postMap(tagType, genericTag);\r\n        }\r\n    }\r\n    /**\r\n     * Set generic tag\r\n     */\r\n    setGenericTag(tagType, tag) {\r\n        debug(`common.${tag.id} = ${tag.value}`);\r\n        const prio0 = this.commonOrigin[tag.id] || 1000;\r\n        const prio1 = this.originPriority[tagType];\r\n        if (GenericTagTypes_1.isSingleton(tag.id)) {\r\n            if (prio1 <= prio0) {\r\n                this.common[tag.id] = tag.value;\r\n                this.commonOrigin[tag.id] = prio1;\r\n            }\r\n            else {\r\n                return debug(`Ignore native tag (singleton): ${tagType}.${tag.id} = ${tag.value}`);\r\n            }\r\n        }\r\n        else {\r\n            if (prio1 === prio0) {\r\n                if (!GenericTagTypes_1.isUnique(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {\r\n                    this.common[tag.id].push(tag.value);\r\n                }\r\n                else {\r\n                    debug(`Ignore duplicate value: ${tagType}.${tag.id} = ${tag.value}`);\r\n                }\r\n                // no effect? this.commonOrigin[tag.id] = prio1;\r\n            }\r\n            else if (prio1 < prio0) {\r\n                this.common[tag.id] = [tag.value];\r\n                this.commonOrigin[tag.id] = prio1;\r\n            }\r\n            else {\r\n                return debug(`Ignore native tag (list): ${tagType}.${tag.id} = ${tag.value}`);\r\n            }\r\n        }\r\n        if (this.opts.observer) {\r\n            this.opts.observer({ metadata: this, tag: { type: 'common', id: tag.id, value: tag.value } });\r\n        }\r\n        // ToDo: trigger metadata event\r\n    }\r\n}\r\nexports.MetadataCollector = MetadataCollector;\r\nfunction joinArtists(artists) {\r\n    if (artists.length > 2) {\r\n        return artists.slice(0, artists.length - 1).join(', ') + ' & ' + artists[artists.length - 1];\r\n    }\r\n    return artists.join(' & ');\r\n}\r\nexports.joinArtists = joinArtists;\r\n"]},"metadata":{},"sourceType":"script"}