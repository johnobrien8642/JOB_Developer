{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isBitSet = exports.parseTagFlags = exports.TagField = exports.TagItemHeader = exports.TagFooter = exports.Header = exports.DescriptorParser = exports.DataType = void 0;\n\nconst Token = require(\"token-types\");\n\nconst FourCC_1 = require(\"../common/FourCC\");\n\nvar DataType;\n\n(function (DataType) {\n  DataType[DataType[\"text_utf8\"] = 0] = \"text_utf8\";\n  DataType[DataType[\"binary\"] = 1] = \"binary\";\n  DataType[DataType[\"external_info\"] = 2] = \"external_info\";\n  DataType[DataType[\"reserved\"] = 3] = \"reserved\";\n})(DataType = exports.DataType || (exports.DataType = {}));\n/**\r\n * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\r\n */\n\n\nexports.DescriptorParser = {\n  len: 52,\n  get: (buf, off) => {\n    return {\n      // should equal 'MAC '\n      ID: FourCC_1.FourCcToken.get(buf, off),\n      // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n      version: Token.UINT32_LE.get(buf, off + 4) / 1000,\n      // the number of descriptor bytes (allows later expansion of this header)\n      descriptorBytes: Token.UINT32_LE.get(buf, off + 8),\n      // the number of header APE_HEADER bytes\n      headerBytes: Token.UINT32_LE.get(buf, off + 12),\n      // the number of header APE_HEADER bytes\n      seekTableBytes: Token.UINT32_LE.get(buf, off + 16),\n      // the number of header data bytes (from original file)\n      headerDataBytes: Token.UINT32_LE.get(buf, off + 20),\n      // the number of bytes of APE frame data\n      apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),\n      // the high order number of APE frame data bytes\n      apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),\n      // the terminating data of the file (not including tag data)\n      terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),\n      // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n      fileMD5: new Token.BufferType(16).get(buf, off + 36)\n    };\n  }\n};\n/**\r\n * APE_HEADER: describes all of the necessary information about the APE file\r\n */\n\nexports.Header = {\n  len: 24,\n  get: (buf, off) => {\n    return {\n      // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\n      compressionLevel: Token.UINT16_LE.get(buf, off),\n      // any format flags (for future use)\n      formatFlags: Token.UINT16_LE.get(buf, off + 2),\n      // the number of audio blocks in one frame\n      blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),\n      // the number of audio blocks in the final frame\n      finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),\n      // the total number of frames\n      totalFrames: Token.UINT32_LE.get(buf, off + 12),\n      // the bits per sample (typically 16)\n      bitsPerSample: Token.UINT16_LE.get(buf, off + 16),\n      // the number of channels (1 or 2)\n      channel: Token.UINT16_LE.get(buf, off + 18),\n      // the sample rate (typically 44100)\n      sampleRate: Token.UINT32_LE.get(buf, off + 20)\n    };\n  }\n};\n/**\r\n * APE Tag Header/Footer Version 2.0\r\n * TAG: describes all the properties of the file [optional]\r\n */\n\nexports.TagFooter = {\n  len: 32,\n  get: (buf, off) => {\n    return {\n      // should equal 'APETAGEX'\n      ID: new Token.StringType(8, 'ascii').get(buf, off),\n      // equals CURRENT_APE_TAG_VERSION\n      version: Token.UINT32_LE.get(buf, off + 8),\n      // the complete size of the tag, including this footer (excludes header)\n      size: Token.UINT32_LE.get(buf, off + 12),\n      // the number of fields in the tag\n      fields: Token.UINT32_LE.get(buf, off + 16),\n      // reserved for later use (must be zero),\n      flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 20))\n    };\n  }\n};\n/**\r\n * APE Tag v2.0 Item Header\r\n */\n\nexports.TagItemHeader = {\n  len: 8,\n  get: (buf, off) => {\n    return {\n      // Length of assigned value in bytes\n      size: Token.UINT32_LE.get(buf, off),\n      // reserved for later use (must be zero),\n      flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 4))\n    };\n  }\n};\n\nconst TagField = footer => {\n  return new Token.BufferType(footer.size - exports.TagFooter.len);\n};\n\nexports.TagField = TagField;\n\nfunction parseTagFlags(flags) {\n  return {\n    containsHeader: isBitSet(flags, 31),\n    containsFooter: isBitSet(flags, 30),\n    isHeader: isBitSet(flags, 31),\n    readOnly: isBitSet(flags, 0),\n    dataType: (flags & 6) >> 1\n  };\n}\n\nexports.parseTagFlags = parseTagFlags;\n/**\r\n * @param num {number}\r\n * @param bit 0 is least significant bit (LSB)\r\n * @return {boolean} true if bit is 1; otherwise false\r\n */\n\nfunction isBitSet(num, bit) {\n  return (num & 1 << bit) !== 0;\n}\n\nexports.isBitSet = isBitSet;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/JOB_Developer/client/node_modules/music-metadata/lib/apev2/APEv2Token.js"],"names":["Object","defineProperty","exports","value","isBitSet","parseTagFlags","TagField","TagItemHeader","TagFooter","Header","DescriptorParser","DataType","Token","require","FourCC_1","len","get","buf","off","ID","FourCcToken","version","UINT32_LE","descriptorBytes","headerBytes","seekTableBytes","headerDataBytes","apeFrameDataBytes","apeFrameDataBytesHigh","terminatingDataBytes","fileMD5","BufferType","compressionLevel","UINT16_LE","formatFlags","blocksPerFrame","finalFrameBlocks","totalFrames","bitsPerSample","channel","sampleRate","StringType","size","fields","flags","footer","containsHeader","containsFooter","isHeader","readOnly","dataType","num","bit"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,QAAR,GAAmBF,OAAO,CAACG,aAAR,GAAwBH,OAAO,CAACI,QAAR,GAAmBJ,OAAO,CAACK,aAAR,GAAwBL,OAAO,CAACM,SAAR,GAAoBN,OAAO,CAACO,MAAR,GAAiBP,OAAO,CAACQ,gBAAR,GAA2BR,OAAO,CAACS,QAAR,GAAmB,KAAK,CAA9K;;AACA,MAAMC,KAAK,GAAGC,OAAO,CAAC,aAAD,CAArB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,kBAAD,CAAxB;;AACA,IAAIF,QAAJ;;AACA,CAAC,UAAUA,QAAV,EAAoB;AACjBA,EAAAA,QAAQ,CAACA,QAAQ,CAAC,WAAD,CAAR,GAAwB,CAAzB,CAAR,GAAsC,WAAtC;AACAA,EAAAA,QAAQ,CAACA,QAAQ,CAAC,QAAD,CAAR,GAAqB,CAAtB,CAAR,GAAmC,QAAnC;AACAA,EAAAA,QAAQ,CAACA,QAAQ,CAAC,eAAD,CAAR,GAA4B,CAA7B,CAAR,GAA0C,eAA1C;AACAA,EAAAA,QAAQ,CAACA,QAAQ,CAAC,UAAD,CAAR,GAAuB,CAAxB,CAAR,GAAqC,UAArC;AACH,CALD,EAKGA,QAAQ,GAAGT,OAAO,CAACS,QAAR,KAAqBT,OAAO,CAACS,QAAR,GAAmB,EAAxC,CALd;AAMA;AACA;AACA;;;AACAT,OAAO,CAACQ,gBAAR,GAA2B;AACvBK,EAAAA,GAAG,EAAE,EADkB;AAEvBC,EAAAA,GAAG,EAAE,CAACC,GAAD,EAAMC,GAAN,KAAc;AACf,WAAO;AACH;AACAC,MAAAA,EAAE,EAAEL,QAAQ,CAACM,WAAT,CAAqBJ,GAArB,CAAyBC,GAAzB,EAA8BC,GAA9B,CAFD;AAGH;AACAG,MAAAA,OAAO,EAAET,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,CAA/B,IAAoC,IAJ1C;AAKH;AACAK,MAAAA,eAAe,EAAEX,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,CAA/B,CANd;AAOH;AACAM,MAAAA,WAAW,EAAEZ,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,EAA/B,CARV;AASH;AACAO,MAAAA,cAAc,EAAEb,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,EAA/B,CAVb;AAWH;AACAQ,MAAAA,eAAe,EAAEd,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,EAA/B,CAZd;AAaH;AACAS,MAAAA,iBAAiB,EAAEf,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,EAA/B,CAdhB;AAeH;AACAU,MAAAA,qBAAqB,EAAEhB,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,EAA/B,CAhBpB;AAiBH;AACAW,MAAAA,oBAAoB,EAAEjB,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,EAA/B,CAlBnB;AAmBH;AACAY,MAAAA,OAAO,EAAE,IAAIlB,KAAK,CAACmB,UAAV,CAAqB,EAArB,EAAyBf,GAAzB,CAA6BC,GAA7B,EAAkCC,GAAG,GAAG,EAAxC;AApBN,KAAP;AAsBH;AAzBsB,CAA3B;AA2BA;AACA;AACA;;AACAhB,OAAO,CAACO,MAAR,GAAiB;AACbM,EAAAA,GAAG,EAAE,EADQ;AAEbC,EAAAA,GAAG,EAAE,CAACC,GAAD,EAAMC,GAAN,KAAc;AACf,WAAO;AACH;AACAc,MAAAA,gBAAgB,EAAEpB,KAAK,CAACqB,SAAN,CAAgBjB,GAAhB,CAAoBC,GAApB,EAAyBC,GAAzB,CAFf;AAGH;AACAgB,MAAAA,WAAW,EAAEtB,KAAK,CAACqB,SAAN,CAAgBjB,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,CAA/B,CAJV;AAKH;AACAiB,MAAAA,cAAc,EAAEvB,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,CAA/B,CANb;AAOH;AACAkB,MAAAA,gBAAgB,EAAExB,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,CAA/B,CARf;AASH;AACAmB,MAAAA,WAAW,EAAEzB,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,EAA/B,CAVV;AAWH;AACAoB,MAAAA,aAAa,EAAE1B,KAAK,CAACqB,SAAN,CAAgBjB,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,EAA/B,CAZZ;AAaH;AACAqB,MAAAA,OAAO,EAAE3B,KAAK,CAACqB,SAAN,CAAgBjB,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,EAA/B,CAdN;AAeH;AACAsB,MAAAA,UAAU,EAAE5B,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,EAA/B;AAhBT,KAAP;AAkBH;AArBY,CAAjB;AAuBA;AACA;AACA;AACA;;AACAhB,OAAO,CAACM,SAAR,GAAoB;AAChBO,EAAAA,GAAG,EAAE,EADW;AAEhBC,EAAAA,GAAG,EAAE,CAACC,GAAD,EAAMC,GAAN,KAAc;AACf,WAAO;AACH;AACAC,MAAAA,EAAE,EAAE,IAAIP,KAAK,CAAC6B,UAAV,CAAqB,CAArB,EAAwB,OAAxB,EAAiCzB,GAAjC,CAAqCC,GAArC,EAA0CC,GAA1C,CAFD;AAGH;AACAG,MAAAA,OAAO,EAAET,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,CAA/B,CAJN;AAKH;AACAwB,MAAAA,IAAI,EAAE9B,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,EAA/B,CANH;AAOH;AACAyB,MAAAA,MAAM,EAAE/B,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,EAA/B,CARL;AASH;AACA0B,MAAAA,KAAK,EAAEvC,aAAa,CAACO,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,EAA/B,CAAD;AAVjB,KAAP;AAYH;AAfe,CAApB;AAiBA;AACA;AACA;;AACAhB,OAAO,CAACK,aAAR,GAAwB;AACpBQ,EAAAA,GAAG,EAAE,CADe;AAEpBC,EAAAA,GAAG,EAAE,CAACC,GAAD,EAAMC,GAAN,KAAc;AACf,WAAO;AACH;AACAwB,MAAAA,IAAI,EAAE9B,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAzB,CAFH;AAGH;AACA0B,MAAAA,KAAK,EAAEvC,aAAa,CAACO,KAAK,CAACU,SAAN,CAAgBN,GAAhB,CAAoBC,GAApB,EAAyBC,GAAG,GAAG,CAA/B,CAAD;AAJjB,KAAP;AAMH;AATmB,CAAxB;;AAWA,MAAMZ,QAAQ,GAAGuC,MAAM,IAAI;AACvB,SAAO,IAAIjC,KAAK,CAACmB,UAAV,CAAqBc,MAAM,CAACH,IAAP,GAAcxC,OAAO,CAACM,SAAR,CAAkBO,GAArD,CAAP;AACH,CAFD;;AAGAb,OAAO,CAACI,QAAR,GAAmBA,QAAnB;;AACA,SAASD,aAAT,CAAuBuC,KAAvB,EAA8B;AAC1B,SAAO;AACHE,IAAAA,cAAc,EAAE1C,QAAQ,CAACwC,KAAD,EAAQ,EAAR,CADrB;AAEHG,IAAAA,cAAc,EAAE3C,QAAQ,CAACwC,KAAD,EAAQ,EAAR,CAFrB;AAGHI,IAAAA,QAAQ,EAAE5C,QAAQ,CAACwC,KAAD,EAAQ,EAAR,CAHf;AAIHK,IAAAA,QAAQ,EAAE7C,QAAQ,CAACwC,KAAD,EAAQ,CAAR,CAJf;AAKHM,IAAAA,QAAQ,EAAE,CAACN,KAAK,GAAG,CAAT,KAAe;AALtB,GAAP;AAOH;;AACD1C,OAAO,CAACG,aAAR,GAAwBA,aAAxB;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,QAAT,CAAkB+C,GAAlB,EAAuBC,GAAvB,EAA4B;AACxB,SAAO,CAACD,GAAG,GAAG,KAAKC,GAAZ,MAAqB,CAA5B;AACH;;AACDlD,OAAO,CAACE,QAAR,GAAmBA,QAAnB","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isBitSet = exports.parseTagFlags = exports.TagField = exports.TagItemHeader = exports.TagFooter = exports.Header = exports.DescriptorParser = exports.DataType = void 0;\r\nconst Token = require(\"token-types\");\r\nconst FourCC_1 = require(\"../common/FourCC\");\r\nvar DataType;\r\n(function (DataType) {\r\n    DataType[DataType[\"text_utf8\"] = 0] = \"text_utf8\";\r\n    DataType[DataType[\"binary\"] = 1] = \"binary\";\r\n    DataType[DataType[\"external_info\"] = 2] = \"external_info\";\r\n    DataType[DataType[\"reserved\"] = 3] = \"reserved\";\r\n})(DataType = exports.DataType || (exports.DataType = {}));\r\n/**\r\n * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\r\n */\r\nexports.DescriptorParser = {\r\n    len: 52,\r\n    get: (buf, off) => {\r\n        return {\r\n            // should equal 'MAC '\r\n            ID: FourCC_1.FourCcToken.get(buf, off),\r\n            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\r\n            version: Token.UINT32_LE.get(buf, off + 4) / 1000,\r\n            // the number of descriptor bytes (allows later expansion of this header)\r\n            descriptorBytes: Token.UINT32_LE.get(buf, off + 8),\r\n            // the number of header APE_HEADER bytes\r\n            headerBytes: Token.UINT32_LE.get(buf, off + 12),\r\n            // the number of header APE_HEADER bytes\r\n            seekTableBytes: Token.UINT32_LE.get(buf, off + 16),\r\n            // the number of header data bytes (from original file)\r\n            headerDataBytes: Token.UINT32_LE.get(buf, off + 20),\r\n            // the number of bytes of APE frame data\r\n            apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),\r\n            // the high order number of APE frame data bytes\r\n            apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),\r\n            // the terminating data of the file (not including tag data)\r\n            terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),\r\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\r\n            fileMD5: new Token.BufferType(16).get(buf, off + 36)\r\n        };\r\n    }\r\n};\r\n/**\r\n * APE_HEADER: describes all of the necessary information about the APE file\r\n */\r\nexports.Header = {\r\n    len: 24,\r\n    get: (buf, off) => {\r\n        return {\r\n            // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\r\n            compressionLevel: Token.UINT16_LE.get(buf, off),\r\n            // any format flags (for future use)\r\n            formatFlags: Token.UINT16_LE.get(buf, off + 2),\r\n            // the number of audio blocks in one frame\r\n            blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),\r\n            // the number of audio blocks in the final frame\r\n            finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),\r\n            // the total number of frames\r\n            totalFrames: Token.UINT32_LE.get(buf, off + 12),\r\n            // the bits per sample (typically 16)\r\n            bitsPerSample: Token.UINT16_LE.get(buf, off + 16),\r\n            // the number of channels (1 or 2)\r\n            channel: Token.UINT16_LE.get(buf, off + 18),\r\n            // the sample rate (typically 44100)\r\n            sampleRate: Token.UINT32_LE.get(buf, off + 20)\r\n        };\r\n    }\r\n};\r\n/**\r\n * APE Tag Header/Footer Version 2.0\r\n * TAG: describes all the properties of the file [optional]\r\n */\r\nexports.TagFooter = {\r\n    len: 32,\r\n    get: (buf, off) => {\r\n        return {\r\n            // should equal 'APETAGEX'\r\n            ID: new Token.StringType(8, 'ascii').get(buf, off),\r\n            // equals CURRENT_APE_TAG_VERSION\r\n            version: Token.UINT32_LE.get(buf, off + 8),\r\n            // the complete size of the tag, including this footer (excludes header)\r\n            size: Token.UINT32_LE.get(buf, off + 12),\r\n            // the number of fields in the tag\r\n            fields: Token.UINT32_LE.get(buf, off + 16),\r\n            // reserved for later use (must be zero),\r\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 20))\r\n        };\r\n    }\r\n};\r\n/**\r\n * APE Tag v2.0 Item Header\r\n */\r\nexports.TagItemHeader = {\r\n    len: 8,\r\n    get: (buf, off) => {\r\n        return {\r\n            // Length of assigned value in bytes\r\n            size: Token.UINT32_LE.get(buf, off),\r\n            // reserved for later use (must be zero),\r\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 4))\r\n        };\r\n    }\r\n};\r\nconst TagField = footer => {\r\n    return new Token.BufferType(footer.size - exports.TagFooter.len);\r\n};\r\nexports.TagField = TagField;\r\nfunction parseTagFlags(flags) {\r\n    return {\r\n        containsHeader: isBitSet(flags, 31),\r\n        containsFooter: isBitSet(flags, 30),\r\n        isHeader: isBitSet(flags, 31),\r\n        readOnly: isBitSet(flags, 0),\r\n        dataType: (flags & 6) >> 1\r\n    };\r\n}\r\nexports.parseTagFlags = parseTagFlags;\r\n/**\r\n * @param num {number}\r\n * @param bit 0 is least significant bit (LSB)\r\n * @return {boolean} true if bit is 1; otherwise false\r\n */\r\nfunction isBitSet(num, bit) {\r\n    return (num & 1 << bit) !== 0;\r\n}\r\nexports.isBitSet = isBitSet;\r\n"]},"metadata":{},"sourceType":"script"}