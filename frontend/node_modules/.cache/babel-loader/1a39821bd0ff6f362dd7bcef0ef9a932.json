{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VorbisParser = void 0;\n\nvar Token = require(\"token-types\");\n\nvar _debug = require(\"debug\");\n\nvar VorbisDecoder_1 = require(\"./VorbisDecoder\");\n\nvar Vorbis_1 = require(\"./Vorbis\");\n\nvar debug = _debug('music-metadata:parser:ogg:vorbis1');\n/**\r\n * Vorbis 1 Parser.\r\n * Used by OggParser\r\n */\n\n\nvar VorbisParser = /*#__PURE__*/function () {\n  function VorbisParser(metadata, options) {\n    _classCallCheck(this, VorbisParser);\n\n    this.metadata = metadata;\n    this.options = options;\n    this.pageSegments = [];\n  }\n  /**\r\n   * Vorbis 1 parser\r\n   * @param header Ogg Page Header\r\n   * @param pageData Page data\r\n   */\n\n\n  _createClass(VorbisParser, [{\n    key: \"parsePage\",\n    value: function parsePage(header, pageData) {\n      if (header.headerType.firstPage) {\n        this.parseFirstPage(header, pageData);\n      } else {\n        if (header.headerType.continued) {\n          if (this.pageSegments.length === 0) {\n            throw new Error(\"Cannot continue on previous page\");\n          }\n\n          this.pageSegments.push(pageData);\n        }\n\n        if (header.headerType.lastPage || !header.headerType.continued) {\n          // Flush page segments\n          if (this.pageSegments.length > 0) {\n            var fullPage = Buffer.concat(this.pageSegments);\n            this.parseFullPage(fullPage);\n          } // Reset page segments\n\n\n          this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n        }\n      }\n\n      if (header.headerType.lastPage) {\n        this.calculateDuration(header);\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      this.parseFullPage(Buffer.concat(this.pageSegments));\n    }\n  }, {\n    key: \"parseUserComment\",\n    value: function parseUserComment(pageData, offset) {\n      var decoder = new VorbisDecoder_1.VorbisDecoder(pageData, offset);\n      var tag = decoder.parseUserComment();\n      this.addTag(tag.key, tag.value);\n      return tag.len;\n    }\n  }, {\n    key: \"addTag\",\n    value: function addTag(id, value) {\n      if (id === 'METADATA_BLOCK_PICTURE' && typeof value === 'string') {\n        if (this.options.skipCovers) {\n          debug(\"Ignore picture\");\n          return;\n        }\n\n        value = Vorbis_1.VorbisPictureToken.fromBase64(value);\n        debug(\"Push picture: id=\".concat(id, \", format=\").concat(value.format));\n      } else {\n        debug(\"Push tag: id=\".concat(id, \", value=\").concat(value));\n      }\n\n      this.metadata.addTag('vorbis', id, value);\n    }\n  }, {\n    key: \"calculateDuration\",\n    value: function calculateDuration(header) {\n      if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n        // Calculate duration\n        this.metadata.setFormat('numberOfSamples', header.absoluteGranulePosition);\n        this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n      }\n    }\n    /**\r\n     * Parse first Ogg/Vorbis page\r\n     * @param {IPageHeader} header\r\n     * @param {Buffer} pageData\r\n     */\n\n  }, {\n    key: \"parseFirstPage\",\n    value: function parseFirstPage(header, pageData) {\n      this.metadata.setFormat('codec', 'Vorbis I');\n      debug(\"Parse first page\"); // Parse  Vorbis common header\n\n      var commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n      if (commonHeader.vorbis !== 'vorbis') throw new Error('Metadata does not look like Vorbis');\n\n      if (commonHeader.packetType === 1) {\n        var idHeader = Vorbis_1.IdentificationHeader.get(pageData, Vorbis_1.CommonHeader.len);\n        this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n        this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n        this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n        debug(\"sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s\", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n      } else throw new Error('First Ogg page should be type 1: the identification header');\n    }\n  }, {\n    key: \"parseFullPage\",\n    value: function parseFullPage(pageData) {\n      // New page\n      var commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n      debug(\"Parse full page: type=%s, byteLength=%s\", commonHeader.packetType, pageData.byteLength);\n\n      switch (commonHeader.packetType) {\n        case 3:\n          //  type 3: comment header\n          return this.parseUserCommentList(pageData, Vorbis_1.CommonHeader.len);\n\n        case 1: // type 1: the identification header\n\n        case 5:\n          // type 5: setup header type\n          break;\n        // ignore\n      }\n    }\n    /**\r\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\r\n     */\n\n  }, {\n    key: \"parseUserCommentList\",\n    value: function parseUserCommentList(pageData, offset) {\n      var strLen = Token.UINT32_LE.get(pageData, offset);\n      offset += 4; // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n\n      offset += strLen;\n      var userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n      offset += 4;\n\n      while (userCommentListLength-- > 0) {\n        offset += this.parseUserComment(pageData, offset);\n      }\n    }\n  }]);\n\n  return VorbisParser;\n}();\n\nexports.VorbisParser = VorbisParser;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js"],"names":["Object","defineProperty","exports","value","VorbisParser","Token","require","_debug","VorbisDecoder_1","Vorbis_1","debug","metadata","options","pageSegments","header","pageData","headerType","firstPage","parseFirstPage","continued","length","Error","push","lastPage","fullPage","Buffer","concat","parseFullPage","calculateDuration","offset","decoder","VorbisDecoder","tag","parseUserComment","addTag","key","len","id","skipCovers","VorbisPictureToken","fromBase64","format","sampleRate","absoluteGranulePosition","setFormat","numberOfSamples","commonHeader","CommonHeader","get","vorbis","packetType","idHeader","IdentificationHeader","bitrateNominal","channelMode","byteLength","parseUserCommentList","strLen","UINT32_LE","userCommentListLength"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.VorbisParser = void 0;\r\nconst Token = require(\"token-types\");\r\nconst _debug = require(\"debug\");\r\nconst VorbisDecoder_1 = require(\"./VorbisDecoder\");\r\nconst Vorbis_1 = require(\"./Vorbis\");\r\nconst debug = _debug('music-metadata:parser:ogg:vorbis1');\r\n/**\r\n * Vorbis 1 Parser.\r\n * Used by OggParser\r\n */\r\nclass VorbisParser {\r\n    constructor(metadata, options) {\r\n        this.metadata = metadata;\r\n        this.options = options;\r\n        this.pageSegments = [];\r\n    }\r\n    /**\r\n     * Vorbis 1 parser\r\n     * @param header Ogg Page Header\r\n     * @param pageData Page data\r\n     */\r\n    parsePage(header, pageData) {\r\n        if (header.headerType.firstPage) {\r\n            this.parseFirstPage(header, pageData);\r\n        }\r\n        else {\r\n            if (header.headerType.continued) {\r\n                if (this.pageSegments.length === 0) {\r\n                    throw new Error(\"Cannot continue on previous page\");\r\n                }\r\n                this.pageSegments.push(pageData);\r\n            }\r\n            if (header.headerType.lastPage || !header.headerType.continued) {\r\n                // Flush page segments\r\n                if (this.pageSegments.length > 0) {\r\n                    const fullPage = Buffer.concat(this.pageSegments);\r\n                    this.parseFullPage(fullPage);\r\n                }\r\n                // Reset page segments\r\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\r\n            }\r\n        }\r\n        if (header.headerType.lastPage) {\r\n            this.calculateDuration(header);\r\n        }\r\n    }\r\n    flush() {\r\n        this.parseFullPage(Buffer.concat(this.pageSegments));\r\n    }\r\n    parseUserComment(pageData, offset) {\r\n        const decoder = new VorbisDecoder_1.VorbisDecoder(pageData, offset);\r\n        const tag = decoder.parseUserComment();\r\n        this.addTag(tag.key, tag.value);\r\n        return tag.len;\r\n    }\r\n    addTag(id, value) {\r\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\r\n            if (this.options.skipCovers) {\r\n                debug(`Ignore picture`);\r\n                return;\r\n            }\r\n            value = Vorbis_1.VorbisPictureToken.fromBase64(value);\r\n            debug(`Push picture: id=${id}, format=${value.format}`);\r\n        }\r\n        else {\r\n            debug(`Push tag: id=${id}, value=${value}`);\r\n        }\r\n        this.metadata.addTag('vorbis', id, value);\r\n    }\r\n    calculateDuration(header) {\r\n        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\r\n            // Calculate duration\r\n            this.metadata.setFormat('numberOfSamples', header.absoluteGranulePosition);\r\n            this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\r\n        }\r\n    }\r\n    /**\r\n     * Parse first Ogg/Vorbis page\r\n     * @param {IPageHeader} header\r\n     * @param {Buffer} pageData\r\n     */\r\n    parseFirstPage(header, pageData) {\r\n        this.metadata.setFormat('codec', 'Vorbis I');\r\n        debug(\"Parse first page\");\r\n        // Parse  Vorbis common header\r\n        const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\r\n        if (commonHeader.vorbis !== 'vorbis')\r\n            throw new Error('Metadata does not look like Vorbis');\r\n        if (commonHeader.packetType === 1) {\r\n            const idHeader = Vorbis_1.IdentificationHeader.get(pageData, Vorbis_1.CommonHeader.len);\r\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\r\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\r\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\r\n            debug(\"sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s\", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\r\n        }\r\n        else\r\n            throw new Error('First Ogg page should be type 1: the identification header');\r\n    }\r\n    parseFullPage(pageData) {\r\n        // New page\r\n        const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\r\n        debug(\"Parse full page: type=%s, byteLength=%s\", commonHeader.packetType, pageData.byteLength);\r\n        switch (commonHeader.packetType) {\r\n            case 3: //  type 3: comment header\r\n                return this.parseUserCommentList(pageData, Vorbis_1.CommonHeader.len);\r\n            case 1: // type 1: the identification header\r\n            case 5: // type 5: setup header type\r\n                break; // ignore\r\n        }\r\n    }\r\n    /**\r\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\r\n     */\r\n    parseUserCommentList(pageData, offset) {\r\n        const strLen = Token.UINT32_LE.get(pageData, offset);\r\n        offset += 4;\r\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\r\n        offset += strLen;\r\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\r\n        offset += 4;\r\n        while (userCommentListLength-- > 0) {\r\n            offset += this.parseUserComment(pageData, offset);\r\n        }\r\n    }\r\n}\r\nexports.VorbisParser = VorbisParser;\r\n"]},"metadata":{},"sourceType":"script"}