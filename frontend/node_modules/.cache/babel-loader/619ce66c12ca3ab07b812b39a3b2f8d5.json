{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WaveParser = void 0;\n\nconst strtok3 = require(\"strtok3/lib/core\");\n\nconst Token = require(\"token-types\");\n\nconst initDebug = require(\"debug\");\n\nconst riff = require(\"../riff/RiffChunk\");\n\nconst WaveChunk = require(\"./../wav/WaveChunk\");\n\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\n\nconst Util_1 = require(\"../common/Util\");\n\nconst FourCC_1 = require(\"../common/FourCC\");\n\nconst BasicParser_1 = require(\"../common/BasicParser\");\n\nconst debug = initDebug('music-metadata:parser:RIFF');\n/**\r\n * Resource Interchange File Format (RIFF) Parser\r\n *\r\n * WAVE PCM soundfile format\r\n *\r\n * Ref:\r\n *  http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\r\n *  http://soundfile.sapp.org/doc/WaveFormat\r\n *\r\n *  ToDo: Split WAVE part from RIFF parser\r\n */\n\nclass WaveParser extends BasicParser_1.BasicParser {\n  async parse() {\n    const riffHeader = await this.tokenizer.readToken(riff.Header);\n    debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\n    if (riffHeader.chunkID !== 'RIFF') return; // Not RIFF format\n\n    return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\n      if (!(err instanceof strtok3.EndOfStreamError)) {\n        throw err;\n      }\n    });\n  }\n\n  async parseRiffChunk(chunkSize) {\n    const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n    this.metadata.setFormat('container', type);\n\n    switch (type) {\n      case 'WAVE':\n        return this.readWaveChunk(chunkSize - FourCC_1.FourCcToken.len);\n\n      default:\n        throw new Error(`Unsupported RIFF format: RIFF/${type}`);\n    }\n  }\n\n  async readWaveChunk(remaining) {\n    while (remaining >= riff.Header.len) {\n      const header = await this.tokenizer.readToken(riff.Header);\n      remaining -= riff.Header.len + header.chunkSize;\n      this.header = header;\n      debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\n\n      switch (header.chunkID) {\n        case 'LIST':\n          await this.parseListTag(header);\n          break;\n\n        case 'fact':\n          // extended Format chunk,\n          this.metadata.setFormat('lossless', false);\n          this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\n          break;\n\n        case 'fmt ':\n          // The Util Chunk, non-PCM Formats\n          const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\n          let subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];\n\n          if (!subFormat) {\n            debug('WAVE/non-PCM format=' + fmt.wFormatTag);\n            subFormat = 'non-PCM (' + fmt.wFormatTag + ')';\n          }\n\n          this.metadata.setFormat('codec', subFormat);\n          this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\n          this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\n          this.metadata.setFormat('numberOfChannels', fmt.nChannels);\n          this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\n          this.blockAlign = fmt.nBlockAlign;\n          break;\n\n        case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\n\n        case 'ID3 ':\n          // The way Mp3Tags stores ID3 meta-data\n          const id3_data = await this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\n          const rst = strtok3.fromBuffer(id3_data);\n          await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n          break;\n\n        case 'data':\n          // PCM-data\n          if (this.metadata.format.lossless !== false) {\n            this.metadata.setFormat('lossless', true);\n          }\n\n          const numberOfSamples = this.fact ? this.fact.dwSampleLength : header.chunkSize === 0xffffffff ? undefined : header.chunkSize / this.blockAlign;\n\n          if (numberOfSamples) {\n            this.metadata.setFormat('numberOfSamples', numberOfSamples);\n            this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\n          }\n\n          this.metadata.setFormat('bitrate', this.metadata.format.numberOfChannels * this.blockAlign * this.metadata.format.sampleRate); // ToDo: check me\n\n          await this.tokenizer.ignore(header.chunkSize);\n          break;\n\n        default:\n          debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n          this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\n          await this.tokenizer.ignore(header.chunkSize);\n      }\n\n      if (this.header.chunkSize % 2 === 1) {\n        debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\n\n        await this.tokenizer.ignore(1);\n      }\n    }\n  }\n\n  async parseListTag(listHeader) {\n    const listType = await this.tokenizer.readToken(new Token.StringType(4, 'binary'));\n    debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\n\n    switch (listType) {\n      case 'INFO':\n        return this.parseRiffInfoTags(listHeader.chunkSize - 4);\n\n      case 'adtl':\n      default:\n        this.metadata.addWarning('Ignore chunk: RIFF/WAVE/LIST/' + listType);\n        debug('Ignoring chunkID=RIFF/WAVE/LIST/' + listType);\n        return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\n    }\n  }\n\n  async parseRiffInfoTags(chunkSize) {\n    while (chunkSize >= 8) {\n      const header = await this.tokenizer.readToken(riff.Header);\n      const valueToken = new riff.ListInfoTagValue(header);\n      const value = await this.tokenizer.readToken(valueToken);\n      this.addTag(header.chunkID, Util_1.default.stripNulls(value));\n      chunkSize -= 8 + valueToken.len;\n    }\n\n    if (chunkSize !== 0) {\n      throw Error('Illegal remaining size: ' + chunkSize);\n    }\n  }\n\n  addTag(id, value) {\n    this.metadata.addTag('exif', id, value);\n  }\n\n}\n\nexports.WaveParser = WaveParser;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/wav/WaveParser.js"],"names":["Object","defineProperty","exports","value","WaveParser","strtok3","require","Token","initDebug","riff","WaveChunk","ID3v2Parser_1","Util_1","FourCC_1","BasicParser_1","debug","BasicParser","parse","riffHeader","tokenizer","readToken","Header","position","chunkID","parseRiffChunk","chunkSize","catch","err","EndOfStreamError","type","FourCcToken","metadata","setFormat","readWaveChunk","len","Error","remaining","header","parseListTag","fact","FactChunk","fmt","Format","subFormat","WaveFormat","wFormatTag","wBitsPerSample","nSamplesPerSec","nChannels","nBlockAlign","blockAlign","id3_data","BufferType","rst","fromBuffer","ID3v2Parser","options","format","lossless","numberOfSamples","dwSampleLength","undefined","sampleRate","numberOfChannels","ignore","addWarning","listHeader","listType","StringType","parseRiffInfoTags","then","valueToken","ListInfoTagValue","addTag","default","stripNulls","id"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WaveParser = void 0;\r\nconst strtok3 = require(\"strtok3/lib/core\");\r\nconst Token = require(\"token-types\");\r\nconst initDebug = require(\"debug\");\r\nconst riff = require(\"../riff/RiffChunk\");\r\nconst WaveChunk = require(\"./../wav/WaveChunk\");\r\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\r\nconst Util_1 = require(\"../common/Util\");\r\nconst FourCC_1 = require(\"../common/FourCC\");\r\nconst BasicParser_1 = require(\"../common/BasicParser\");\r\nconst debug = initDebug('music-metadata:parser:RIFF');\r\n/**\r\n * Resource Interchange File Format (RIFF) Parser\r\n *\r\n * WAVE PCM soundfile format\r\n *\r\n * Ref:\r\n *  http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\r\n *  http://soundfile.sapp.org/doc/WaveFormat\r\n *\r\n *  ToDo: Split WAVE part from RIFF parser\r\n */\r\nclass WaveParser extends BasicParser_1.BasicParser {\r\n    async parse() {\r\n        const riffHeader = await this.tokenizer.readToken(riff.Header);\r\n        debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\r\n        if (riffHeader.chunkID !== 'RIFF')\r\n            return; // Not RIFF format\r\n        return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\r\n            if (!(err instanceof strtok3.EndOfStreamError)) {\r\n                throw err;\r\n            }\r\n        });\r\n    }\r\n    async parseRiffChunk(chunkSize) {\r\n        const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\r\n        this.metadata.setFormat('container', type);\r\n        switch (type) {\r\n            case 'WAVE':\r\n                return this.readWaveChunk(chunkSize - FourCC_1.FourCcToken.len);\r\n            default:\r\n                throw new Error(`Unsupported RIFF format: RIFF/${type}`);\r\n        }\r\n    }\r\n    async readWaveChunk(remaining) {\r\n        while (remaining >= riff.Header.len) {\r\n            const header = await this.tokenizer.readToken(riff.Header);\r\n            remaining -= riff.Header.len + header.chunkSize;\r\n            this.header = header;\r\n            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\r\n            switch (header.chunkID) {\r\n                case 'LIST':\r\n                    await this.parseListTag(header);\r\n                    break;\r\n                case 'fact': // extended Format chunk,\r\n                    this.metadata.setFormat('lossless', false);\r\n                    this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\r\n                    break;\r\n                case 'fmt ': // The Util Chunk, non-PCM Formats\r\n                    const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\r\n                    let subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];\r\n                    if (!subFormat) {\r\n                        debug('WAVE/non-PCM format=' + fmt.wFormatTag);\r\n                        subFormat = 'non-PCM (' + fmt.wFormatTag + ')';\r\n                    }\r\n                    this.metadata.setFormat('codec', subFormat);\r\n                    this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\r\n                    this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\r\n                    this.metadata.setFormat('numberOfChannels', fmt.nChannels);\r\n                    this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\r\n                    this.blockAlign = fmt.nBlockAlign;\r\n                    break;\r\n                case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\r\n                case 'ID3 ': // The way Mp3Tags stores ID3 meta-data\r\n                    const id3_data = await this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\r\n                    const rst = strtok3.fromBuffer(id3_data);\r\n                    await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\r\n                    break;\r\n                case 'data': // PCM-data\r\n                    if (this.metadata.format.lossless !== false) {\r\n                        this.metadata.setFormat('lossless', true);\r\n                    }\r\n                    const numberOfSamples = this.fact ? this.fact.dwSampleLength : (header.chunkSize === 0xffffffff ? undefined : (header.chunkSize / this.blockAlign));\r\n                    if (numberOfSamples) {\r\n                        this.metadata.setFormat('numberOfSamples', numberOfSamples);\r\n                        this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\r\n                    }\r\n                    this.metadata.setFormat('bitrate', this.metadata.format.numberOfChannels * this.blockAlign * this.metadata.format.sampleRate); // ToDo: check me\r\n                    await this.tokenizer.ignore(header.chunkSize);\r\n                    break;\r\n                default:\r\n                    debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\r\n                    this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\r\n                    await this.tokenizer.ignore(header.chunkSize);\r\n            }\r\n            if (this.header.chunkSize % 2 === 1) {\r\n                debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\r\n                await this.tokenizer.ignore(1);\r\n            }\r\n        }\r\n    }\r\n    async parseListTag(listHeader) {\r\n        const listType = await this.tokenizer.readToken(new Token.StringType(4, 'binary'));\r\n        debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\r\n        switch (listType) {\r\n            case 'INFO':\r\n                return this.parseRiffInfoTags(listHeader.chunkSize - 4);\r\n            case 'adtl':\r\n            default:\r\n                this.metadata.addWarning('Ignore chunk: RIFF/WAVE/LIST/' + listType);\r\n                debug('Ignoring chunkID=RIFF/WAVE/LIST/' + listType);\r\n                return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\r\n        }\r\n    }\r\n    async parseRiffInfoTags(chunkSize) {\r\n        while (chunkSize >= 8) {\r\n            const header = await this.tokenizer.readToken(riff.Header);\r\n            const valueToken = new riff.ListInfoTagValue(header);\r\n            const value = await this.tokenizer.readToken(valueToken);\r\n            this.addTag(header.chunkID, Util_1.default.stripNulls(value));\r\n            chunkSize -= (8 + valueToken.len);\r\n        }\r\n        if (chunkSize !== 0) {\r\n            throw Error('Illegal remaining size: ' + chunkSize);\r\n        }\r\n    }\r\n    addTag(id, value) {\r\n        this.metadata.addTag('exif', id, value);\r\n    }\r\n}\r\nexports.WaveParser = WaveParser;\r\n"]},"metadata":{},"sourceType":"script"}