{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toRatio = exports.dbToRatio = exports.ratioToDb = void 0;\n\nvar Windows1292Decoder_1 = require(\"./Windows1292Decoder\");\n\nvar Util = /*#__PURE__*/function () {\n  function Util() {\n    _classCallCheck(this, Util);\n  }\n\n  _createClass(Util, null, [{\n    key: \"findZero\",\n    value:\n    /**\r\n     *\r\n     * @param buffer\r\n     * @param start\r\n     * @param end\r\n     * @param encoding // ToDo: ts.enum\r\n     * @return {number}\r\n     */\n    function findZero(buffer, start, end, encoding) {\n      var i = start;\n\n      if (encoding === 'utf16') {\n        while (buffer[i] !== 0 || buffer[i + 1] !== 0) {\n          if (i >= end) return end;\n          i += 2;\n        }\n\n        return i;\n      } else {\n        while (buffer[i] !== 0) {\n          if (i >= end) return end;\n          i++;\n        }\n\n        return i;\n      }\n    }\n  }, {\n    key: \"trimRightNull\",\n    value: function trimRightNull(x) {\n      var pos0 = x.indexOf('\\0');\n      return pos0 === -1 ? x : x.substr(0, pos0);\n    }\n  }, {\n    key: \"swapBytes\",\n    value: function swapBytes(buffer) {\n      var l = buffer.length;\n      if ((l & 1) !== 0) throw new Error('Buffer length must be even');\n\n      for (var i = 0; i < l; i += 2) {\n        var a = buffer[i];\n        buffer[i] = buffer[i + 1];\n        buffer[i + 1] = a;\n      }\n\n      return buffer;\n    }\n  }, {\n    key: \"readUTF16String\",\n    value: function readUTF16String(buffer) {\n      var offset = 0;\n\n      if (buffer[0] === 0xFE && buffer[1] === 0xFF) {\n        // big endian\n        buffer = Util.swapBytes(buffer);\n        offset = 2;\n      } else if (buffer[0] === 0xFF && buffer[1] === 0xFE) {\n        // little endian\n        offset = 2;\n      }\n\n      return buffer.toString('ucs2', offset);\n    }\n    /**\r\n     *\r\n     * @param buffer Decoder input data\r\n     * @param encoding 'utf16le' | 'utf16' | 'utf8' | 'iso-8859-1'\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"decodeString\",\n    value: function decodeString(buffer, encoding) {\n      // annoying workaround for a double BOM issue\n      // https://github.com/leetreveil/musicmetadata/issues/84\n      if (buffer[0] === 0xFF && buffer[1] === 0xFE && buffer[2] === 0xFE && buffer[3] === 0xFF) {\n        buffer = buffer.slice(2);\n      }\n\n      if (encoding === 'utf16le' || encoding === 'utf16') {\n        return Util.readUTF16String(buffer);\n      } else if (encoding === 'utf8') {\n        return buffer.toString('utf8');\n      } else if (encoding === 'iso-8859-1') {\n        return Windows1292Decoder_1.Windows1292Decoder.decode(buffer);\n      }\n\n      throw Error(encoding + ' encoding is not supported!');\n    }\n  }, {\n    key: \"stripNulls\",\n    value: function stripNulls(str) {\n      str = str.replace(/^\\x00+/g, '');\n      str = str.replace(/\\x00+$/g, '');\n      return str;\n    }\n    /**\r\n     * Read bit-aligned number start from buffer\r\n     * Total offset in bits = byteOffset * 8 + bitOffset\r\n     * @param buf Byte buffer\r\n     * @param byteOffset Starting offset in bytes\r\n     * @param bitOffset Starting offset in bits: 0 = lsb\r\n     * @param len Length of number in bits\r\n     * @return {number} decoded bit aligned number\r\n     */\n\n  }, {\n    key: \"getBitAllignedNumber\",\n    value: function getBitAllignedNumber(buf, byteOffset, bitOffset, len) {\n      var byteOff = byteOffset + ~~(bitOffset / 8);\n      var bitOff = bitOffset % 8;\n      var value = buf[byteOff];\n      value &= 0xff >> bitOff;\n      var bitsRead = 8 - bitOff;\n      var bitsLeft = len - bitsRead;\n\n      if (bitsLeft < 0) {\n        value >>= 8 - bitOff - len;\n      } else if (bitsLeft > 0) {\n        value <<= bitsLeft;\n        value |= Util.getBitAllignedNumber(buf, byteOffset, bitOffset + bitsRead, bitsLeft);\n      }\n\n      return value;\n    }\n    /**\r\n     * Read bit-aligned number start from buffer\r\n     * Total offset in bits = byteOffset * 8 + bitOffset\r\n     * @param buf Byte buffer\r\n     * @param byteOffset Starting offset in bytes\r\n     * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is least significant bit\r\n     * @return {number} decoded bit aligned number\r\n     */\n\n  }, {\n    key: \"isBitSet\",\n    value: function isBitSet(buf, byteOffset, bitOffset) {\n      return Util.getBitAllignedNumber(buf, byteOffset, bitOffset, 1) === 1;\n    }\n  }, {\n    key: \"a2hex\",\n    value: function a2hex(str) {\n      var arr = [];\n\n      for (var i = 0, l = str.length; i < l; i++) {\n        var hex = Number(str.charCodeAt(i)).toString(16);\n        arr.push(hex.length === 1 ? '0' + hex : hex);\n      }\n\n      return arr.join(' ');\n    }\n  }]);\n\n  return Util;\n}();\n\nexports.default = Util;\nUtil.strtokBITSET = {\n  get: function get(buf, off, bit) {\n    return (buf[off] & 1 << bit) !== 0;\n  },\n  len: 1\n};\n/**\r\n * Convert power ratio to DB\r\n * ratio: [0..1]\r\n */\n\nfunction ratioToDb(ratio) {\n  return 10 * Math.log10(ratio);\n}\n\nexports.ratioToDb = ratioToDb;\n/**\r\n * Convert dB to ratio\r\n * db Decibels\r\n */\n\nfunction dbToRatio(dB) {\n  return Math.pow(10, dB / 10);\n}\n\nexports.dbToRatio = dbToRatio;\n/**\r\n * Convert replay gain to ratio and Decibel\r\n * @param value string holding a ratio like '0.034' or '-7.54 dB'\r\n */\n\nfunction toRatio(value) {\n  var ps = value.split(' ').map(function (p) {\n    return p.trim().toLowerCase();\n  }); // @ts-ignore\n\n  if (ps.length >= 1) {\n    var v = parseFloat(ps[0]);\n\n    if (ps.length === 2 && ps[1] === 'db') {\n      return {\n        dB: v,\n        ratio: dbToRatio(v)\n      };\n    } else {\n      return {\n        dB: ratioToDb(v),\n        ratio: v\n      };\n    }\n  }\n}\n\nexports.toRatio = toRatio;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/common/Util.js"],"names":["Object","defineProperty","exports","value","toRatio","dbToRatio","ratioToDb","Windows1292Decoder_1","require","Util","buffer","start","end","encoding","i","x","pos0","indexOf","substr","l","length","Error","a","offset","swapBytes","toString","slice","readUTF16String","Windows1292Decoder","decode","str","replace","buf","byteOffset","bitOffset","len","byteOff","bitOff","bitsRead","bitsLeft","getBitAllignedNumber","arr","hex","Number","charCodeAt","push","join","default","strtokBITSET","get","off","bit","ratio","Math","log10","dB","pow","ps","split","map","p","trim","toLowerCase","v","parseFloat"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.toRatio = exports.dbToRatio = exports.ratioToDb = void 0;\r\nconst Windows1292Decoder_1 = require(\"./Windows1292Decoder\");\r\nclass Util {\r\n    /**\r\n     *\r\n     * @param buffer\r\n     * @param start\r\n     * @param end\r\n     * @param encoding // ToDo: ts.enum\r\n     * @return {number}\r\n     */\r\n    static findZero(buffer, start, end, encoding) {\r\n        let i = start;\r\n        if (encoding === 'utf16') {\r\n            while (buffer[i] !== 0 || buffer[i + 1] !== 0) {\r\n                if (i >= end)\r\n                    return end;\r\n                i += 2;\r\n            }\r\n            return i;\r\n        }\r\n        else {\r\n            while (buffer[i] !== 0) {\r\n                if (i >= end)\r\n                    return end;\r\n                i++;\r\n            }\r\n            return i;\r\n        }\r\n    }\r\n    static trimRightNull(x) {\r\n        const pos0 = x.indexOf('\\0');\r\n        return pos0 === -1 ? x : x.substr(0, pos0);\r\n    }\r\n    static swapBytes(buffer) {\r\n        const l = buffer.length;\r\n        if ((l & 1) !== 0)\r\n            throw new Error('Buffer length must be even');\r\n        for (let i = 0; i < l; i += 2) {\r\n            const a = buffer[i];\r\n            buffer[i] = buffer[i + 1];\r\n            buffer[i + 1] = a;\r\n        }\r\n        return buffer;\r\n    }\r\n    static readUTF16String(buffer) {\r\n        let offset = 0;\r\n        if (buffer[0] === 0xFE && buffer[1] === 0xFF) { // big endian\r\n            buffer = Util.swapBytes(buffer);\r\n            offset = 2;\r\n        }\r\n        else if (buffer[0] === 0xFF && buffer[1] === 0xFE) { // little endian\r\n            offset = 2;\r\n        }\r\n        return buffer.toString('ucs2', offset);\r\n    }\r\n    /**\r\n     *\r\n     * @param buffer Decoder input data\r\n     * @param encoding 'utf16le' | 'utf16' | 'utf8' | 'iso-8859-1'\r\n     * @return {string}\r\n     */\r\n    static decodeString(buffer, encoding) {\r\n        // annoying workaround for a double BOM issue\r\n        // https://github.com/leetreveil/musicmetadata/issues/84\r\n        if (buffer[0] === 0xFF && buffer[1] === 0xFE && buffer[2] === 0xFE && buffer[3] === 0xFF) {\r\n            buffer = buffer.slice(2);\r\n        }\r\n        if (encoding === 'utf16le' || encoding === 'utf16') {\r\n            return Util.readUTF16String(buffer);\r\n        }\r\n        else if (encoding === 'utf8') {\r\n            return buffer.toString('utf8');\r\n        }\r\n        else if (encoding === 'iso-8859-1') {\r\n            return Windows1292Decoder_1.Windows1292Decoder.decode(buffer);\r\n        }\r\n        throw Error(encoding + ' encoding is not supported!');\r\n    }\r\n    static stripNulls(str) {\r\n        str = str.replace(/^\\x00+/g, '');\r\n        str = str.replace(/\\x00+$/g, '');\r\n        return str;\r\n    }\r\n    /**\r\n     * Read bit-aligned number start from buffer\r\n     * Total offset in bits = byteOffset * 8 + bitOffset\r\n     * @param buf Byte buffer\r\n     * @param byteOffset Starting offset in bytes\r\n     * @param bitOffset Starting offset in bits: 0 = lsb\r\n     * @param len Length of number in bits\r\n     * @return {number} decoded bit aligned number\r\n     */\r\n    static getBitAllignedNumber(buf, byteOffset, bitOffset, len) {\r\n        const byteOff = byteOffset + ~~(bitOffset / 8);\r\n        const bitOff = bitOffset % 8;\r\n        let value = buf[byteOff];\r\n        value &= 0xff >> bitOff;\r\n        const bitsRead = 8 - bitOff;\r\n        const bitsLeft = len - bitsRead;\r\n        if (bitsLeft < 0) {\r\n            value >>= (8 - bitOff - len);\r\n        }\r\n        else if (bitsLeft > 0) {\r\n            value <<= bitsLeft;\r\n            value |= Util.getBitAllignedNumber(buf, byteOffset, bitOffset + bitsRead, bitsLeft);\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * Read bit-aligned number start from buffer\r\n     * Total offset in bits = byteOffset * 8 + bitOffset\r\n     * @param buf Byte buffer\r\n     * @param byteOffset Starting offset in bytes\r\n     * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is least significant bit\r\n     * @return {number} decoded bit aligned number\r\n     */\r\n    static isBitSet(buf, byteOffset, bitOffset) {\r\n        return Util.getBitAllignedNumber(buf, byteOffset, bitOffset, 1) === 1;\r\n    }\r\n    static a2hex(str) {\r\n        const arr = [];\r\n        for (let i = 0, l = str.length; i < l; i++) {\r\n            const hex = Number(str.charCodeAt(i)).toString(16);\r\n            arr.push(hex.length === 1 ? '0' + hex : hex);\r\n        }\r\n        return arr.join(' ');\r\n    }\r\n}\r\nexports.default = Util;\r\nUtil.strtokBITSET = {\r\n    get: (buf, off, bit) => {\r\n        return (buf[off] & (1 << bit)) !== 0;\r\n    },\r\n    len: 1\r\n};\r\n/**\r\n * Convert power ratio to DB\r\n * ratio: [0..1]\r\n */\r\nfunction ratioToDb(ratio) {\r\n    return 10 * Math.log10(ratio);\r\n}\r\nexports.ratioToDb = ratioToDb;\r\n/**\r\n * Convert dB to ratio\r\n * db Decibels\r\n */\r\nfunction dbToRatio(dB) {\r\n    return Math.pow(10, dB / 10);\r\n}\r\nexports.dbToRatio = dbToRatio;\r\n/**\r\n * Convert replay gain to ratio and Decibel\r\n * @param value string holding a ratio like '0.034' or '-7.54 dB'\r\n */\r\nfunction toRatio(value) {\r\n    const ps = value.split(' ').map(p => p.trim().toLowerCase());\r\n    // @ts-ignore\r\n    if (ps.length >= 1) {\r\n        const v = parseFloat(ps[0]);\r\n        if (ps.length === 2 && ps[1] === 'db') {\r\n            return {\r\n                dB: v,\r\n                ratio: dbToRatio(v)\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                dB: ratioToDb(v),\r\n                ratio: v\r\n            };\r\n        }\r\n    }\r\n}\r\nexports.toRatio = toRatio;\r\n"]},"metadata":{},"sourceType":"script"}