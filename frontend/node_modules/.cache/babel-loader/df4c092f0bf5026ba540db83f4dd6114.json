{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scanAppendingHeaders = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = exports.parseStream = void 0;\n\nvar strtok3 = require(\"strtok3/lib/core\");\n\nvar ParserFactory_1 = require(\"./ParserFactory\");\n\nvar RandomBufferReader_1 = require(\"./common/RandomBufferReader\");\n\nvar APEv2Parser_1 = require(\"./apev2/APEv2Parser\");\n\nvar ID3v1Parser_1 = require(\"./id3v1/ID3v1Parser\");\n\nvar Lyrics3_1 = require(\"./lyrics3/Lyrics3\");\n/**\r\n * Parse audio from Node Stream.Readable\r\n * @param stream - Stream to read the audio track from\r\n * @param options - Parsing options\r\n * @param fileInfo - File information object or MIME-type string\r\n * @returns Metadata\r\n */\n\n\nfunction parseStream(stream, fileInfo) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return parseFromTokenizer(strtok3.fromStream(stream, typeof fileInfo === 'string' ? {\n    mimeType: fileInfo\n  } : fileInfo), options);\n}\n\nexports.parseStream = parseStream;\n/**\r\n * Parse audio from Node Buffer\r\n * @param buf - Buffer holding audio data\r\n * @param fileInfo - File information object or MIME-type string\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n * Ref: https://github.com/Borewit/strtok3/blob/e6938c81ff685074d5eb3064a11c0b03ca934c1d/src/index.ts#L15\r\n */\n\nfunction parseBuffer(_x, _x2) {\n  return _parseBuffer.apply(this, arguments);\n}\n\nfunction _parseBuffer() {\n  _parseBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(buf, fileInfo) {\n    var options,\n        bufferReader,\n        tokenizer,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n            bufferReader = new RandomBufferReader_1.RandomBufferReader(buf);\n            _context.next = 4;\n            return scanAppendingHeaders(bufferReader, options);\n\n          case 4:\n            tokenizer = strtok3.fromBuffer(buf, typeof fileInfo === 'string' ? {\n              mimeType: fileInfo\n            } : fileInfo);\n            return _context.abrupt(\"return\", parseFromTokenizer(tokenizer, options));\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parseBuffer.apply(this, arguments);\n}\n\nexports.parseBuffer = parseBuffer;\n/**\r\n * Parse audio from ITokenizer source\r\n * @param tokenizer - Audio source implementing the tokenizer interface\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\n\nfunction parseFromTokenizer(tokenizer, options) {\n  return ParserFactory_1.ParserFactory.parseOnContentType(tokenizer, options);\n}\n\nexports.parseFromTokenizer = parseFromTokenizer;\n/**\r\n * Create a dictionary ordered by their tag id (key)\r\n * @param nativeTags list of tags\r\n * @returns tags indexed by id\r\n */\n\nfunction orderTags(nativeTags) {\n  var tags = {};\n\n  var _iterator = _createForOfIteratorHelper(nativeTags),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var tag = _step.value;\n      (tags[tag.id] = tags[tag.id] || []).push(tag.value);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return tags;\n}\n\nexports.orderTags = orderTags;\n/**\r\n * Convert rating to 1-5 star rating\r\n * @param rating: Normalized rating [0..1] (common.rating[n].rating)\r\n * @returns Number of stars: 1, 2, 3, 4 or 5 stars\r\n */\n\nfunction ratingToStars(rating) {\n  return rating === undefined ? 0 : 1 + Math.round(rating * 4);\n}\n\nexports.ratingToStars = ratingToStars;\n/**\r\n * Select most likely cover image.\r\n * @param pictures Usually metadata.common.picture\r\n * @return Cover image, if any, otherwise null\r\n */\n\nfunction selectCover(pictures) {\n  return pictures ? pictures.reduce(function (acc, cur) {\n    if (cur.name && cur.name.toLowerCase() in ['front', 'cover', 'cover (front)']) return cur;\n    return acc;\n  }) : null;\n}\n\nexports.selectCover = selectCover;\n\nfunction scanAppendingHeaders(_x3) {\n  return _scanAppendingHeaders.apply(this, arguments);\n}\n\nfunction _scanAppendingHeaders() {\n  _scanAppendingHeaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(randomReader) {\n    var options,\n        apeOffset,\n        lyricsLen,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n            apeOffset = randomReader.fileSize;\n            _context2.next = 4;\n            return ID3v1Parser_1.hasID3v1Header(randomReader);\n\n          case 4:\n            if (!_context2.sent) {\n              _context2.next = 10;\n              break;\n            }\n\n            apeOffset -= 128;\n            _context2.next = 8;\n            return Lyrics3_1.getLyricsHeaderLength(randomReader);\n\n          case 8:\n            lyricsLen = _context2.sent;\n            apeOffset -= lyricsLen;\n\n          case 10:\n            _context2.next = 12;\n            return APEv2Parser_1.APEv2Parser.findApeFooterOffset(randomReader, apeOffset);\n\n          case 12:\n            options.apeHeader = _context2.sent;\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _scanAppendingHeaders.apply(this, arguments);\n}\n\nexports.scanAppendingHeaders = scanAppendingHeaders;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/core.js"],"names":["Object","defineProperty","exports","value","scanAppendingHeaders","selectCover","ratingToStars","orderTags","parseFromTokenizer","parseBuffer","parseStream","strtok3","require","ParserFactory_1","RandomBufferReader_1","APEv2Parser_1","ID3v1Parser_1","Lyrics3_1","stream","fileInfo","options","fromStream","mimeType","buf","bufferReader","RandomBufferReader","tokenizer","fromBuffer","ParserFactory","parseOnContentType","nativeTags","tags","tag","id","push","rating","undefined","Math","round","pictures","reduce","acc","cur","name","toLowerCase","randomReader","apeOffset","fileSize","hasID3v1Header","getLyricsHeaderLength","lyricsLen","APEv2Parser","findApeFooterOffset","apeHeader"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.scanAppendingHeaders = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = exports.parseStream = void 0;\r\nconst strtok3 = require(\"strtok3/lib/core\");\r\nconst ParserFactory_1 = require(\"./ParserFactory\");\r\nconst RandomBufferReader_1 = require(\"./common/RandomBufferReader\");\r\nconst APEv2Parser_1 = require(\"./apev2/APEv2Parser\");\r\nconst ID3v1Parser_1 = require(\"./id3v1/ID3v1Parser\");\r\nconst Lyrics3_1 = require(\"./lyrics3/Lyrics3\");\r\n/**\r\n * Parse audio from Node Stream.Readable\r\n * @param stream - Stream to read the audio track from\r\n * @param options - Parsing options\r\n * @param fileInfo - File information object or MIME-type string\r\n * @returns Metadata\r\n */\r\nfunction parseStream(stream, fileInfo, options = {}) {\r\n    return parseFromTokenizer(strtok3.fromStream(stream, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo), options);\r\n}\r\nexports.parseStream = parseStream;\r\n/**\r\n * Parse audio from Node Buffer\r\n * @param buf - Buffer holding audio data\r\n * @param fileInfo - File information object or MIME-type string\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n * Ref: https://github.com/Borewit/strtok3/blob/e6938c81ff685074d5eb3064a11c0b03ca934c1d/src/index.ts#L15\r\n */\r\nasync function parseBuffer(buf, fileInfo, options = {}) {\r\n    const bufferReader = new RandomBufferReader_1.RandomBufferReader(buf);\r\n    await scanAppendingHeaders(bufferReader, options);\r\n    const tokenizer = strtok3.fromBuffer(buf, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo);\r\n    return parseFromTokenizer(tokenizer, options);\r\n}\r\nexports.parseBuffer = parseBuffer;\r\n/**\r\n * Parse audio from ITokenizer source\r\n * @param tokenizer - Audio source implementing the tokenizer interface\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nfunction parseFromTokenizer(tokenizer, options) {\r\n    return ParserFactory_1.ParserFactory.parseOnContentType(tokenizer, options);\r\n}\r\nexports.parseFromTokenizer = parseFromTokenizer;\r\n/**\r\n * Create a dictionary ordered by their tag id (key)\r\n * @param nativeTags list of tags\r\n * @returns tags indexed by id\r\n */\r\nfunction orderTags(nativeTags) {\r\n    const tags = {};\r\n    for (const tag of nativeTags) {\r\n        (tags[tag.id] = (tags[tag.id] || [])).push(tag.value);\r\n    }\r\n    return tags;\r\n}\r\nexports.orderTags = orderTags;\r\n/**\r\n * Convert rating to 1-5 star rating\r\n * @param rating: Normalized rating [0..1] (common.rating[n].rating)\r\n * @returns Number of stars: 1, 2, 3, 4 or 5 stars\r\n */\r\nfunction ratingToStars(rating) {\r\n    return rating === undefined ? 0 : 1 + Math.round(rating * 4);\r\n}\r\nexports.ratingToStars = ratingToStars;\r\n/**\r\n * Select most likely cover image.\r\n * @param pictures Usually metadata.common.picture\r\n * @return Cover image, if any, otherwise null\r\n */\r\nfunction selectCover(pictures) {\r\n    return pictures ? pictures.reduce((acc, cur) => {\r\n        if (cur.name && cur.name.toLowerCase() in ['front', 'cover', 'cover (front)'])\r\n            return cur;\r\n        return acc;\r\n    }) : null;\r\n}\r\nexports.selectCover = selectCover;\r\nasync function scanAppendingHeaders(randomReader, options = {}) {\r\n    let apeOffset = randomReader.fileSize;\r\n    if (await ID3v1Parser_1.hasID3v1Header(randomReader)) {\r\n        apeOffset -= 128;\r\n        const lyricsLen = await Lyrics3_1.getLyricsHeaderLength(randomReader);\r\n        apeOffset -= lyricsLen;\r\n    }\r\n    options.apeHeader = await APEv2Parser_1.APEv2Parser.findApeFooterOffset(randomReader, apeOffset);\r\n}\r\nexports.scanAppendingHeaders = scanAppendingHeaders;\r\n"]},"metadata":{},"sourceType":"script"}