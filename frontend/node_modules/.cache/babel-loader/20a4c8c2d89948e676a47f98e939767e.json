{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchFromUrl = exports.parseBlob = exports.parseReadableStream = exports.parseNodeStream = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = void 0;\n\nconst initDebug = require(\"debug\");\n\nconst mm = require(\"music-metadata/lib/core\");\n\nconst readable_web_to_node_stream_1 = require(\"readable-web-to-node-stream\");\n\nconst toBuffer = require(\"typedarray-to-buffer\");\n\nconst debug = initDebug('music-metadata-browser:main');\n\nvar core_1 = require(\"music-metadata/lib/core\");\n\nObject.defineProperty(exports, \"parseBuffer\", {\n  enumerable: true,\n  get: function () {\n    return core_1.parseBuffer;\n  }\n});\nObject.defineProperty(exports, \"parseFromTokenizer\", {\n  enumerable: true,\n  get: function () {\n    return core_1.parseFromTokenizer;\n  }\n});\nObject.defineProperty(exports, \"orderTags\", {\n  enumerable: true,\n  get: function () {\n    return core_1.orderTags;\n  }\n});\nObject.defineProperty(exports, \"ratingToStars\", {\n  enumerable: true,\n  get: function () {\n    return core_1.ratingToStars;\n  }\n});\nObject.defineProperty(exports, \"selectCover\", {\n  enumerable: true,\n  get: function () {\n    return core_1.selectCover;\n  }\n});\n/**\r\n * Parse audio Stream\r\n * @param stream - ReadableStream\r\n * @param contentType - MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\n\nexports.parseNodeStream = mm.parseStream;\n/**\r\n * Parse Web API ReadableStream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\r\n * @param stream - ReadableStream\r\n * @param fileInfo FileInfo object or MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\n\nasync function parseReadableStream(stream, fileInfo, options) {\n  const ns = new readable_web_to_node_stream_1.ReadableWebToNodeStream(stream);\n  const res = await exports.parseNodeStream(ns, typeof fileInfo === 'string' ? {\n    mimeType: fileInfo\n  } : fileInfo, options);\n  await ns.close();\n  return res;\n}\n\nexports.parseReadableStream = parseReadableStream;\n/**\r\n * Parse Web API File\r\n * @param blob - Blob to parse\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\n\nasync function parseBlob(blob, options) {\n  const buf = await convertBlobToBuffer(blob);\n  const fileInfo = {\n    mimeType: blob.type,\n    size: blob.size\n  };\n\n  if (blob.name) {\n    fileInfo.path = blob.name;\n  }\n\n  return mm.parseBuffer(buf, {\n    mimeType: blob.type,\n    size: blob.size\n  }, options);\n}\n\nexports.parseBlob = parseBlob;\n/**\r\n * Parse fetched file, using the Web Fetch API\r\n * @param audioTrackUrl - URL to download the audio track from\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\n\nasync function fetchFromUrl(audioTrackUrl, options) {\n  const response = await fetch(audioTrackUrl);\n  const fileInfo = {\n    size: parseInt(response.headers.get('Content-Length'), 10),\n    mimeType: response.headers.get('Content-Type')\n  };\n\n  if (response.ok) {\n    if (response.body) {\n      const res = await this.parseReadableStream(response.body, fileInfo, options);\n      debug('Closing HTTP-readable-stream...');\n\n      if (!response.body.locked) {\n        // Prevent error in Firefox\n        await response.body.cancel();\n      }\n\n      debug('HTTP-readable-stream closed.');\n      return res;\n    } else {\n      // Fall back on Blob\n      return this.parseBlob(await response.blob(), options);\n    }\n  } else {\n    throw new Error(`HTTP error status=${response.status}: ${response.statusText}`);\n  }\n}\n\nexports.fetchFromUrl = fetchFromUrl;\n/**\r\n * Convert Web API File to Node Buffer\r\n * @param blob - Web API Blob\r\n * @returns Metadata\r\n */\n\nfunction convertBlobToBuffer(blob) {\n  return new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n\n    fileReader.onloadend = event => {\n      let data = event.target.result;\n\n      if (data instanceof ArrayBuffer) {\n        data = toBuffer(new Uint8Array(event.target.result));\n      }\n\n      resolve(data);\n    };\n\n    fileReader.onerror = error => {\n      reject(new Error(error.type));\n    };\n\n    fileReader.onabort = error => {\n      reject(new Error(error.type));\n    };\n\n    fileReader.readAsArrayBuffer(blob);\n  });\n}","map":{"version":3,"sources":["/Users/johnobrien/Desktop/JOB_Developer/client/node_modules/music-metadata-browser/lib/index.js"],"names":["Object","defineProperty","exports","value","fetchFromUrl","parseBlob","parseReadableStream","parseNodeStream","selectCover","ratingToStars","orderTags","parseFromTokenizer","parseBuffer","initDebug","require","mm","readable_web_to_node_stream_1","toBuffer","debug","core_1","enumerable","get","parseStream","stream","fileInfo","options","ns","ReadableWebToNodeStream","res","mimeType","close","blob","buf","convertBlobToBuffer","type","size","name","path","audioTrackUrl","response","fetch","parseInt","headers","ok","body","locked","cancel","Error","status","statusText","Promise","resolve","reject","fileReader","FileReader","onloadend","event","data","target","result","ArrayBuffer","Uint8Array","onerror","error","onabort","readAsArrayBuffer"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.fetchFromUrl = exports.parseBlob = exports.parseReadableStream = exports.parseNodeStream = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = void 0;\r\nconst initDebug = require(\"debug\");\r\nconst mm = require(\"music-metadata/lib/core\");\r\nconst readable_web_to_node_stream_1 = require(\"readable-web-to-node-stream\");\r\nconst toBuffer = require(\"typedarray-to-buffer\");\r\nconst debug = initDebug('music-metadata-browser:main');\r\nvar core_1 = require(\"music-metadata/lib/core\");\r\nObject.defineProperty(exports, \"parseBuffer\", { enumerable: true, get: function () { return core_1.parseBuffer; } });\r\nObject.defineProperty(exports, \"parseFromTokenizer\", { enumerable: true, get: function () { return core_1.parseFromTokenizer; } });\r\nObject.defineProperty(exports, \"orderTags\", { enumerable: true, get: function () { return core_1.orderTags; } });\r\nObject.defineProperty(exports, \"ratingToStars\", { enumerable: true, get: function () { return core_1.ratingToStars; } });\r\nObject.defineProperty(exports, \"selectCover\", { enumerable: true, get: function () { return core_1.selectCover; } });\r\n/**\r\n * Parse audio Stream\r\n * @param stream - ReadableStream\r\n * @param contentType - MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nexports.parseNodeStream = mm.parseStream;\r\n/**\r\n * Parse Web API ReadableStream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\r\n * @param stream - ReadableStream\r\n * @param fileInfo FileInfo object or MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nasync function parseReadableStream(stream, fileInfo, options) {\r\n    const ns = new readable_web_to_node_stream_1.ReadableWebToNodeStream(stream);\r\n    const res = await exports.parseNodeStream(ns, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo, options);\r\n    await ns.close();\r\n    return res;\r\n}\r\nexports.parseReadableStream = parseReadableStream;\r\n/**\r\n * Parse Web API File\r\n * @param blob - Blob to parse\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nasync function parseBlob(blob, options) {\r\n    const buf = await convertBlobToBuffer(blob);\r\n    const fileInfo = { mimeType: blob.type, size: blob.size };\r\n    if (blob.name) {\r\n        fileInfo.path = blob.name;\r\n    }\r\n    return mm.parseBuffer(buf, { mimeType: blob.type, size: blob.size }, options);\r\n}\r\nexports.parseBlob = parseBlob;\r\n/**\r\n * Parse fetched file, using the Web Fetch API\r\n * @param audioTrackUrl - URL to download the audio track from\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nasync function fetchFromUrl(audioTrackUrl, options) {\r\n    const response = await fetch(audioTrackUrl);\r\n    const fileInfo = {\r\n        size: parseInt(response.headers.get('Content-Length'), 10),\r\n        mimeType: response.headers.get('Content-Type')\r\n    };\r\n    if (response.ok) {\r\n        if (response.body) {\r\n            const res = await this.parseReadableStream(response.body, fileInfo, options);\r\n            debug('Closing HTTP-readable-stream...');\r\n            if (!response.body.locked) { // Prevent error in Firefox\r\n                await response.body.cancel();\r\n            }\r\n            debug('HTTP-readable-stream closed.');\r\n            return res;\r\n        }\r\n        else {\r\n            // Fall back on Blob\r\n            return this.parseBlob(await response.blob(), options);\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(`HTTP error status=${response.status}: ${response.statusText}`);\r\n    }\r\n}\r\nexports.fetchFromUrl = fetchFromUrl;\r\n/**\r\n * Convert Web API File to Node Buffer\r\n * @param blob - Web API Blob\r\n * @returns Metadata\r\n */\r\nfunction convertBlobToBuffer(blob) {\r\n    return new Promise((resolve, reject) => {\r\n        const fileReader = new FileReader();\r\n        fileReader.onloadend = event => {\r\n            let data = event.target.result;\r\n            if (data instanceof ArrayBuffer) {\r\n                data = toBuffer(new Uint8Array(event.target.result));\r\n            }\r\n            resolve(data);\r\n        };\r\n        fileReader.onerror = error => {\r\n            reject(new Error(error.type));\r\n        };\r\n        fileReader.onabort = error => {\r\n            reject(new Error(error.type));\r\n        };\r\n        fileReader.readAsArrayBuffer(blob);\r\n    });\r\n}\r\n"]},"metadata":{},"sourceType":"script"}