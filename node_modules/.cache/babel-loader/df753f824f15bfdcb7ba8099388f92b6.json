{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamReader = exports.EndOfStreamError = void 0;\n\nconst EndOfFileStream_1 = require(\"./EndOfFileStream\");\n\nvar EndOfFileStream_2 = require(\"./EndOfFileStream\");\n\nObject.defineProperty(exports, \"EndOfStreamError\", {\n  enumerable: true,\n  get: function () {\n    return EndOfFileStream_2.EndOfStreamError;\n  }\n});\n\nclass Deferred {\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.reject = reject;\n      this.resolve = resolve;\n    });\n  }\n\n}\n\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\n\nclass StreamReader {\n  constructor(s) {\n    this.s = s;\n    this.endOfStream = false;\n    /**\n     * Store peeked data\n     * @type {Array}\n     */\n\n    this.peekQueue = [];\n\n    if (!s.read || !s.once) {\n      throw new Error('Expected an instance of stream.Readable');\n    }\n\n    this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));\n    this.s.once('error', err => this.reject(err));\n    this.s.once('close', () => this.reject(new Error('Stream closed')));\n  }\n  /**\n   * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\n   * @param buffer - Buffer to store data read from stream in\n   * @param offset - Offset buffer\n   * @param length - Number of bytes to read\n   * @returns Number of bytes peeked\n   */\n\n\n  async peek(buffer, offset, length) {\n    const bytesRead = await this.read(buffer, offset, length);\n    this.peekQueue.push(buffer.slice(offset, offset + bytesRead)); // Put read data back to peek buffer\n\n    return bytesRead;\n  }\n  /**\n   * Read chunk from stream\n   * @param buffer - Target buffer to store data read from stream in\n   * @param offset - Offset of target buffer\n   * @param length - Number of bytes to read\n   * @returns Number of bytes read\n   */\n\n\n  async read(buffer, offset, length) {\n    if (length === 0) {\n      return 0;\n    }\n\n    if (this.peekQueue.length === 0 && this.endOfStream) {\n      throw new EndOfFileStream_1.EndOfStreamError();\n    }\n\n    let remaining = length;\n    let bytesRead = 0; // consume peeked data first\n\n    while (this.peekQueue.length > 0 && remaining > 0) {\n      const peekData = this.peekQueue.pop(); // Front of queue\n\n      const lenCopy = Math.min(peekData.length, remaining);\n      peekData.copy(buffer, offset + bytesRead, 0, lenCopy);\n      bytesRead += lenCopy;\n      remaining -= lenCopy;\n\n      if (lenCopy < peekData.length) {\n        // remainder back to queue\n        this.peekQueue.push(peekData.slice(lenCopy));\n      }\n    } // continue reading from stream if required\n\n\n    while (remaining > 0 && !this.endOfStream) {\n      const reqLen = Math.min(remaining, maxStreamReadSize);\n      const chunkLen = await this._read(buffer, offset + bytesRead, reqLen);\n      bytesRead += chunkLen;\n      if (chunkLen < reqLen) break;\n      remaining -= chunkLen;\n    }\n\n    return bytesRead;\n  }\n  /**\n   * Read chunk from stream\n   * @param buffer Buffer to store data read from stream in\n   * @param offset Offset buffer\n   * @param length Number of bytes to read\n   * @returns Number of bytes read\n   */\n\n\n  async _read(buffer, offset, length) {\n    if (this.request) throw new Error('Concurrent read operation?');\n    const readBuffer = this.s.read(length);\n\n    if (readBuffer) {\n      readBuffer.copy(buffer, offset);\n      return readBuffer.length;\n    } else {\n      this.request = {\n        buffer,\n        offset,\n        length,\n        deferred: new Deferred()\n      };\n      this.s.once('readable', () => {\n        this.tryRead();\n      });\n      return this.request.deferred.promise.then(n => {\n        this.request = null;\n        return n;\n      }, err => {\n        this.request = null;\n        throw err;\n      });\n    }\n  }\n\n  tryRead() {\n    const readBuffer = this.s.read(this.request.length);\n\n    if (readBuffer) {\n      readBuffer.copy(this.request.buffer, this.request.offset);\n      this.request.deferred.resolve(readBuffer.length);\n    } else {\n      this.s.once('readable', () => {\n        this.tryRead();\n      });\n    }\n  }\n\n  reject(err) {\n    this.endOfStream = true;\n\n    if (this.request) {\n      this.request.deferred.reject(err);\n      this.request = null;\n    }\n  }\n\n}\n\nexports.StreamReader = StreamReader;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/JOB_Developer/client/node_modules/peek-readable/lib/index.js"],"names":["Object","defineProperty","exports","value","StreamReader","EndOfStreamError","EndOfFileStream_1","require","EndOfFileStream_2","enumerable","get","Deferred","constructor","promise","Promise","resolve","reject","maxStreamReadSize","s","endOfStream","peekQueue","read","once","Error","err","peek","buffer","offset","length","bytesRead","push","slice","remaining","peekData","pop","lenCopy","Math","min","copy","reqLen","chunkLen","_read","request","readBuffer","deferred","tryRead","then","n"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StreamReader = exports.EndOfStreamError = void 0;\nconst EndOfFileStream_1 = require(\"./EndOfFileStream\");\nvar EndOfFileStream_2 = require(\"./EndOfFileStream\");\nObject.defineProperty(exports, \"EndOfStreamError\", { enumerable: true, get: function () { return EndOfFileStream_2.EndOfStreamError; } });\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\nclass StreamReader {\n    constructor(s) {\n        this.s = s;\n        this.endOfStream = false;\n        /**\n         * Store peeked data\n         * @type {Array}\n         */\n        this.peekQueue = [];\n        if (!s.read || !s.once) {\n            throw new Error('Expected an instance of stream.Readable');\n        }\n        this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));\n        this.s.once('error', err => this.reject(err));\n        this.s.once('close', () => this.reject(new Error('Stream closed')));\n    }\n    /**\n     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\n     * @param buffer - Buffer to store data read from stream in\n     * @param offset - Offset buffer\n     * @param length - Number of bytes to read\n     * @returns Number of bytes peeked\n     */\n    async peek(buffer, offset, length) {\n        const bytesRead = await this.read(buffer, offset, length);\n        this.peekQueue.push(buffer.slice(offset, offset + bytesRead)); // Put read data back to peek buffer\n        return bytesRead;\n    }\n    /**\n     * Read chunk from stream\n     * @param buffer - Target buffer to store data read from stream in\n     * @param offset - Offset of target buffer\n     * @param length - Number of bytes to read\n     * @returns Number of bytes read\n     */\n    async read(buffer, offset, length) {\n        if (length === 0) {\n            return 0;\n        }\n        if (this.peekQueue.length === 0 && this.endOfStream) {\n            throw new EndOfFileStream_1.EndOfStreamError();\n        }\n        let remaining = length;\n        let bytesRead = 0;\n        // consume peeked data first\n        while (this.peekQueue.length > 0 && remaining > 0) {\n            const peekData = this.peekQueue.pop(); // Front of queue\n            const lenCopy = Math.min(peekData.length, remaining);\n            peekData.copy(buffer, offset + bytesRead, 0, lenCopy);\n            bytesRead += lenCopy;\n            remaining -= lenCopy;\n            if (lenCopy < peekData.length) {\n                // remainder back to queue\n                this.peekQueue.push(peekData.slice(lenCopy));\n            }\n        }\n        // continue reading from stream if required\n        while (remaining > 0 && !this.endOfStream) {\n            const reqLen = Math.min(remaining, maxStreamReadSize);\n            const chunkLen = await this._read(buffer, offset + bytesRead, reqLen);\n            bytesRead += chunkLen;\n            if (chunkLen < reqLen)\n                break;\n            remaining -= chunkLen;\n        }\n        return bytesRead;\n    }\n    /**\n     * Read chunk from stream\n     * @param buffer Buffer to store data read from stream in\n     * @param offset Offset buffer\n     * @param length Number of bytes to read\n     * @returns Number of bytes read\n     */\n    async _read(buffer, offset, length) {\n        if (this.request)\n            throw new Error('Concurrent read operation?');\n        const readBuffer = this.s.read(length);\n        if (readBuffer) {\n            readBuffer.copy(buffer, offset);\n            return readBuffer.length;\n        }\n        else {\n            this.request = {\n                buffer,\n                offset,\n                length,\n                deferred: new Deferred()\n            };\n            this.s.once('readable', () => {\n                this.tryRead();\n            });\n            return this.request.deferred.promise.then(n => {\n                this.request = null;\n                return n;\n            }, err => {\n                this.request = null;\n                throw err;\n            });\n        }\n    }\n    tryRead() {\n        const readBuffer = this.s.read(this.request.length);\n        if (readBuffer) {\n            readBuffer.copy(this.request.buffer, this.request.offset);\n            this.request.deferred.resolve(readBuffer.length);\n        }\n        else {\n            this.s.once('readable', () => {\n                this.tryRead();\n            });\n        }\n    }\n    reject(err) {\n        this.endOfStream = true;\n        if (this.request) {\n            this.request.deferred.reject(err);\n            this.request = null;\n        }\n    }\n}\nexports.StreamReader = StreamReader;\n"]},"metadata":{},"sourceType":"script"}