{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WaveParser = void 0;\n\nvar strtok3 = require(\"strtok3/lib/core\");\n\nvar Token = require(\"token-types\");\n\nvar initDebug = require(\"debug\");\n\nvar riff = require(\"../riff/RiffChunk\");\n\nvar WaveChunk = require(\"./../wav/WaveChunk\");\n\nvar ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\n\nvar Util_1 = require(\"../common/Util\");\n\nvar FourCC_1 = require(\"../common/FourCC\");\n\nvar BasicParser_1 = require(\"../common/BasicParser\");\n\nvar debug = initDebug('music-metadata:parser:RIFF');\n/**\r\n * Resource Interchange File Format (RIFF) Parser\r\n *\r\n * WAVE PCM soundfile format\r\n *\r\n * Ref:\r\n *  http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\r\n *  http://soundfile.sapp.org/doc/WaveFormat\r\n *\r\n *  ToDo: Split WAVE part from RIFF parser\r\n */\n\nvar WaveParser = /*#__PURE__*/function (_BasicParser_1$BasicP) {\n  _inherits(WaveParser, _BasicParser_1$BasicP);\n\n  var _super = _createSuper(WaveParser);\n\n  function WaveParser() {\n    _classCallCheck(this, WaveParser);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(WaveParser, [{\n    key: \"parse\",\n    value: function () {\n      var _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var riffHeader;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.tokenizer.readToken(riff.Header);\n\n              case 2:\n                riffHeader = _context.sent;\n                debug(\"pos=\".concat(this.tokenizer.position, \", parse: chunkID=\").concat(riffHeader.chunkID));\n\n                if (!(riffHeader.chunkID !== 'RIFF')) {\n                  _context.next = 6;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 6:\n                return _context.abrupt(\"return\", this.parseRiffChunk(riffHeader.chunkSize).catch(function (err) {\n                  if (!(err instanceof strtok3.EndOfStreamError)) {\n                    throw err;\n                  }\n                }));\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function parse() {\n        return _parse.apply(this, arguments);\n      }\n\n      return parse;\n    }()\n  }, {\n    key: \"parseRiffChunk\",\n    value: function () {\n      var _parseRiffChunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(chunkSize) {\n        var type;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.tokenizer.readToken(FourCC_1.FourCcToken);\n\n              case 2:\n                type = _context2.sent;\n                this.metadata.setFormat('container', type);\n                _context2.t0 = type;\n                _context2.next = _context2.t0 === 'WAVE' ? 7 : 8;\n                break;\n\n              case 7:\n                return _context2.abrupt(\"return\", this.readWaveChunk(chunkSize - FourCC_1.FourCcToken.len));\n\n              case 8:\n                throw new Error(\"Unsupported RIFF format: RIFF/\".concat(type));\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function parseRiffChunk(_x) {\n        return _parseRiffChunk.apply(this, arguments);\n      }\n\n      return parseRiffChunk;\n    }()\n  }, {\n    key: \"readWaveChunk\",\n    value: function () {\n      var _readWaveChunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(remaining) {\n        var header, fmt, subFormat, id3_data, rst, numberOfSamples;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(remaining >= riff.Header.len)) {\n                  _context3.next = 54;\n                  break;\n                }\n\n                _context3.next = 3;\n                return this.tokenizer.readToken(riff.Header);\n\n              case 3:\n                header = _context3.sent;\n                remaining -= riff.Header.len + header.chunkSize;\n                this.header = header;\n                debug(\"pos=\".concat(this.tokenizer.position, \", readChunk: chunkID=RIFF/WAVE/\").concat(header.chunkID));\n                _context3.t0 = header.chunkID;\n                _context3.next = _context3.t0 === 'LIST' ? 10 : _context3.t0 === 'fact' ? 13 : _context3.t0 === 'fmt ' ? 18 : _context3.t0 === 'id3 ' ? 30 : _context3.t0 === 'ID3 ' ? 30 : _context3.t0 === 'data' ? 37 : 44;\n                break;\n\n              case 10:\n                _context3.next = 12;\n                return this.parseListTag(header);\n\n              case 12:\n                return _context3.abrupt(\"break\", 48);\n\n              case 13:\n                // extended Format chunk,\n                this.metadata.setFormat('lossless', false);\n                _context3.next = 16;\n                return this.tokenizer.readToken(new WaveChunk.FactChunk(header));\n\n              case 16:\n                this.fact = _context3.sent;\n                return _context3.abrupt(\"break\", 48);\n\n              case 18:\n                _context3.next = 20;\n                return this.tokenizer.readToken(new WaveChunk.Format(header));\n\n              case 20:\n                fmt = _context3.sent;\n                subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];\n\n                if (!subFormat) {\n                  debug('WAVE/non-PCM format=' + fmt.wFormatTag);\n                  subFormat = 'non-PCM (' + fmt.wFormatTag + ')';\n                }\n\n                this.metadata.setFormat('codec', subFormat);\n                this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\n                this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\n                this.metadata.setFormat('numberOfChannels', fmt.nChannels);\n                this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\n                this.blockAlign = fmt.nBlockAlign;\n                return _context3.abrupt(\"break\", 48);\n\n              case 30:\n                _context3.next = 32;\n                return this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\n\n              case 32:\n                id3_data = _context3.sent;\n                rst = strtok3.fromBuffer(id3_data);\n                _context3.next = 36;\n                return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n\n              case 36:\n                return _context3.abrupt(\"break\", 48);\n\n              case 37:\n                // PCM-data\n                if (this.metadata.format.lossless !== false) {\n                  this.metadata.setFormat('lossless', true);\n                }\n\n                numberOfSamples = this.fact ? this.fact.dwSampleLength : header.chunkSize === 0xffffffff ? undefined : header.chunkSize / this.blockAlign;\n\n                if (numberOfSamples) {\n                  this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                  this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\n                }\n\n                this.metadata.setFormat('bitrate', this.metadata.format.numberOfChannels * this.blockAlign * this.metadata.format.sampleRate); // ToDo: check me\n\n                _context3.next = 43;\n                return this.tokenizer.ignore(header.chunkSize);\n\n              case 43:\n                return _context3.abrupt(\"break\", 48);\n\n              case 44:\n                debug(\"Ignore chunk: RIFF/\".concat(header.chunkID, \" of \").concat(header.chunkSize, \" bytes\"));\n                this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\n                _context3.next = 48;\n                return this.tokenizer.ignore(header.chunkSize);\n\n              case 48:\n                if (!(this.header.chunkSize % 2 === 1)) {\n                  _context3.next = 52;\n                  break;\n                }\n\n                debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\n\n                _context3.next = 52;\n                return this.tokenizer.ignore(1);\n\n              case 52:\n                _context3.next = 0;\n                break;\n\n              case 54:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function readWaveChunk(_x2) {\n        return _readWaveChunk.apply(this, arguments);\n      }\n\n      return readWaveChunk;\n    }()\n  }, {\n    key: \"parseListTag\",\n    value: function () {\n      var _parseListTag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(listHeader) {\n        var listType;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.tokenizer.readToken(new Token.StringType(4, 'binary'));\n\n              case 2:\n                listType = _context4.sent;\n                debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\n                _context4.t0 = listType;\n                _context4.next = _context4.t0 === 'INFO' ? 7 : _context4.t0 === 'adtl' ? 8 : 8;\n                break;\n\n              case 7:\n                return _context4.abrupt(\"return\", this.parseRiffInfoTags(listHeader.chunkSize - 4));\n\n              case 8:\n                this.metadata.addWarning('Ignore chunk: RIFF/WAVE/LIST/' + listType);\n                debug('Ignoring chunkID=RIFF/WAVE/LIST/' + listType);\n                return _context4.abrupt(\"return\", this.tokenizer.ignore(listHeader.chunkSize - 4).then());\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function parseListTag(_x3) {\n        return _parseListTag.apply(this, arguments);\n      }\n\n      return parseListTag;\n    }()\n  }, {\n    key: \"parseRiffInfoTags\",\n    value: function () {\n      var _parseRiffInfoTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(chunkSize) {\n        var header, valueToken, value;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(chunkSize >= 8)) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                _context5.next = 3;\n                return this.tokenizer.readToken(riff.Header);\n\n              case 3:\n                header = _context5.sent;\n                valueToken = new riff.ListInfoTagValue(header);\n                _context5.next = 7;\n                return this.tokenizer.readToken(valueToken);\n\n              case 7:\n                value = _context5.sent;\n                this.addTag(header.chunkID, Util_1.default.stripNulls(value));\n                chunkSize -= 8 + valueToken.len;\n                _context5.next = 0;\n                break;\n\n              case 12:\n                if (!(chunkSize !== 0)) {\n                  _context5.next = 14;\n                  break;\n                }\n\n                throw Error('Illegal remaining size: ' + chunkSize);\n\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function parseRiffInfoTags(_x4) {\n        return _parseRiffInfoTags.apply(this, arguments);\n      }\n\n      return parseRiffInfoTags;\n    }()\n  }, {\n    key: \"addTag\",\n    value: function addTag(id, value) {\n      this.metadata.addTag('exif', id, value);\n    }\n  }]);\n\n  return WaveParser;\n}(BasicParser_1.BasicParser);\n\nexports.WaveParser = WaveParser;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/wav/WaveParser.js"],"names":["Object","defineProperty","exports","value","WaveParser","strtok3","require","Token","initDebug","riff","WaveChunk","ID3v2Parser_1","Util_1","FourCC_1","BasicParser_1","debug","tokenizer","readToken","Header","riffHeader","position","chunkID","parseRiffChunk","chunkSize","catch","err","EndOfStreamError","FourCcToken","type","metadata","setFormat","readWaveChunk","len","Error","remaining","header","parseListTag","FactChunk","fact","Format","fmt","subFormat","WaveFormat","wFormatTag","wBitsPerSample","nSamplesPerSec","nChannels","nBlockAlign","blockAlign","BufferType","id3_data","rst","fromBuffer","ID3v2Parser","parse","options","format","lossless","numberOfSamples","dwSampleLength","undefined","sampleRate","numberOfChannels","ignore","addWarning","listHeader","StringType","listType","parseRiffInfoTags","then","valueToken","ListInfoTagValue","addTag","default","stripNulls","id","BasicParser"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WaveParser = void 0;\r\nconst strtok3 = require(\"strtok3/lib/core\");\r\nconst Token = require(\"token-types\");\r\nconst initDebug = require(\"debug\");\r\nconst riff = require(\"../riff/RiffChunk\");\r\nconst WaveChunk = require(\"./../wav/WaveChunk\");\r\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\r\nconst Util_1 = require(\"../common/Util\");\r\nconst FourCC_1 = require(\"../common/FourCC\");\r\nconst BasicParser_1 = require(\"../common/BasicParser\");\r\nconst debug = initDebug('music-metadata:parser:RIFF');\r\n/**\r\n * Resource Interchange File Format (RIFF) Parser\r\n *\r\n * WAVE PCM soundfile format\r\n *\r\n * Ref:\r\n *  http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\r\n *  http://soundfile.sapp.org/doc/WaveFormat\r\n *\r\n *  ToDo: Split WAVE part from RIFF parser\r\n */\r\nclass WaveParser extends BasicParser_1.BasicParser {\r\n    async parse() {\r\n        const riffHeader = await this.tokenizer.readToken(riff.Header);\r\n        debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\r\n        if (riffHeader.chunkID !== 'RIFF')\r\n            return; // Not RIFF format\r\n        return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\r\n            if (!(err instanceof strtok3.EndOfStreamError)) {\r\n                throw err;\r\n            }\r\n        });\r\n    }\r\n    async parseRiffChunk(chunkSize) {\r\n        const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\r\n        this.metadata.setFormat('container', type);\r\n        switch (type) {\r\n            case 'WAVE':\r\n                return this.readWaveChunk(chunkSize - FourCC_1.FourCcToken.len);\r\n            default:\r\n                throw new Error(`Unsupported RIFF format: RIFF/${type}`);\r\n        }\r\n    }\r\n    async readWaveChunk(remaining) {\r\n        while (remaining >= riff.Header.len) {\r\n            const header = await this.tokenizer.readToken(riff.Header);\r\n            remaining -= riff.Header.len + header.chunkSize;\r\n            this.header = header;\r\n            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\r\n            switch (header.chunkID) {\r\n                case 'LIST':\r\n                    await this.parseListTag(header);\r\n                    break;\r\n                case 'fact': // extended Format chunk,\r\n                    this.metadata.setFormat('lossless', false);\r\n                    this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\r\n                    break;\r\n                case 'fmt ': // The Util Chunk, non-PCM Formats\r\n                    const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\r\n                    let subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];\r\n                    if (!subFormat) {\r\n                        debug('WAVE/non-PCM format=' + fmt.wFormatTag);\r\n                        subFormat = 'non-PCM (' + fmt.wFormatTag + ')';\r\n                    }\r\n                    this.metadata.setFormat('codec', subFormat);\r\n                    this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\r\n                    this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\r\n                    this.metadata.setFormat('numberOfChannels', fmt.nChannels);\r\n                    this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\r\n                    this.blockAlign = fmt.nBlockAlign;\r\n                    break;\r\n                case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\r\n                case 'ID3 ': // The way Mp3Tags stores ID3 meta-data\r\n                    const id3_data = await this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\r\n                    const rst = strtok3.fromBuffer(id3_data);\r\n                    await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\r\n                    break;\r\n                case 'data': // PCM-data\r\n                    if (this.metadata.format.lossless !== false) {\r\n                        this.metadata.setFormat('lossless', true);\r\n                    }\r\n                    const numberOfSamples = this.fact ? this.fact.dwSampleLength : (header.chunkSize === 0xffffffff ? undefined : (header.chunkSize / this.blockAlign));\r\n                    if (numberOfSamples) {\r\n                        this.metadata.setFormat('numberOfSamples', numberOfSamples);\r\n                        this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\r\n                    }\r\n                    this.metadata.setFormat('bitrate', this.metadata.format.numberOfChannels * this.blockAlign * this.metadata.format.sampleRate); // ToDo: check me\r\n                    await this.tokenizer.ignore(header.chunkSize);\r\n                    break;\r\n                default:\r\n                    debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\r\n                    this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\r\n                    await this.tokenizer.ignore(header.chunkSize);\r\n            }\r\n            if (this.header.chunkSize % 2 === 1) {\r\n                debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\r\n                await this.tokenizer.ignore(1);\r\n            }\r\n        }\r\n    }\r\n    async parseListTag(listHeader) {\r\n        const listType = await this.tokenizer.readToken(new Token.StringType(4, 'binary'));\r\n        debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\r\n        switch (listType) {\r\n            case 'INFO':\r\n                return this.parseRiffInfoTags(listHeader.chunkSize - 4);\r\n            case 'adtl':\r\n            default:\r\n                this.metadata.addWarning('Ignore chunk: RIFF/WAVE/LIST/' + listType);\r\n                debug('Ignoring chunkID=RIFF/WAVE/LIST/' + listType);\r\n                return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\r\n        }\r\n    }\r\n    async parseRiffInfoTags(chunkSize) {\r\n        while (chunkSize >= 8) {\r\n            const header = await this.tokenizer.readToken(riff.Header);\r\n            const valueToken = new riff.ListInfoTagValue(header);\r\n            const value = await this.tokenizer.readToken(valueToken);\r\n            this.addTag(header.chunkID, Util_1.default.stripNulls(value));\r\n            chunkSize -= (8 + valueToken.len);\r\n        }\r\n        if (chunkSize !== 0) {\r\n            throw Error('Illegal remaining size: ' + chunkSize);\r\n        }\r\n    }\r\n    addTag(id, value) {\r\n        this.metadata.addTag('exif', id, value);\r\n    }\r\n}\r\nexports.WaveParser = WaveParser;\r\n"]},"metadata":{},"sourceType":"script"}