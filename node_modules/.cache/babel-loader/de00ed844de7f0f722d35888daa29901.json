{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchFromUrl = exports.parseBlob = exports.parseReadableStream = exports.parseNodeStream = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = void 0;\n\nvar initDebug = require(\"debug\");\n\nvar mm = require(\"music-metadata/lib/core\");\n\nvar readable_web_to_node_stream_1 = require(\"readable-web-to-node-stream\");\n\nvar toBuffer = require(\"typedarray-to-buffer\");\n\nvar debug = initDebug('music-metadata-browser:main');\n\nvar core_1 = require(\"music-metadata/lib/core\");\n\nObject.defineProperty(exports, \"parseBuffer\", {\n  enumerable: true,\n  get: function get() {\n    return core_1.parseBuffer;\n  }\n});\nObject.defineProperty(exports, \"parseFromTokenizer\", {\n  enumerable: true,\n  get: function get() {\n    return core_1.parseFromTokenizer;\n  }\n});\nObject.defineProperty(exports, \"orderTags\", {\n  enumerable: true,\n  get: function get() {\n    return core_1.orderTags;\n  }\n});\nObject.defineProperty(exports, \"ratingToStars\", {\n  enumerable: true,\n  get: function get() {\n    return core_1.ratingToStars;\n  }\n});\nObject.defineProperty(exports, \"selectCover\", {\n  enumerable: true,\n  get: function get() {\n    return core_1.selectCover;\n  }\n});\n/**\r\n * Parse audio Stream\r\n * @param stream - ReadableStream\r\n * @param contentType - MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\n\nexports.parseNodeStream = mm.parseStream;\n/**\r\n * Parse Web API ReadableStream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\r\n * @param stream - ReadableStream\r\n * @param fileInfo FileInfo object or MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\n\nfunction parseReadableStream(_x, _x2, _x3) {\n  return _parseReadableStream.apply(this, arguments);\n}\n\nfunction _parseReadableStream() {\n  _parseReadableStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(stream, fileInfo, options) {\n    var ns, res;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            ns = new readable_web_to_node_stream_1.ReadableWebToNodeStream(stream);\n            _context.next = 3;\n            return exports.parseNodeStream(ns, typeof fileInfo === 'string' ? {\n              mimeType: fileInfo\n            } : fileInfo, options);\n\n          case 3:\n            res = _context.sent;\n            _context.next = 6;\n            return ns.close();\n\n          case 6:\n            return _context.abrupt(\"return\", res);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parseReadableStream.apply(this, arguments);\n}\n\nexports.parseReadableStream = parseReadableStream;\n/**\r\n * Parse Web API File\r\n * @param blob - Blob to parse\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\n\nfunction parseBlob(_x4, _x5) {\n  return _parseBlob.apply(this, arguments);\n}\n\nfunction _parseBlob() {\n  _parseBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(blob, options) {\n    var buf, fileInfo;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return convertBlobToBuffer(blob);\n\n          case 2:\n            buf = _context2.sent;\n            fileInfo = {\n              mimeType: blob.type,\n              size: blob.size\n            };\n\n            if (blob.name) {\n              fileInfo.path = blob.name;\n            }\n\n            return _context2.abrupt(\"return\", mm.parseBuffer(buf, {\n              mimeType: blob.type,\n              size: blob.size\n            }, options));\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _parseBlob.apply(this, arguments);\n}\n\nexports.parseBlob = parseBlob;\n/**\r\n * Parse fetched file, using the Web Fetch API\r\n * @param audioTrackUrl - URL to download the audio track from\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\n\nfunction fetchFromUrl(_x6, _x7) {\n  return _fetchFromUrl.apply(this, arguments);\n}\n\nfunction _fetchFromUrl() {\n  _fetchFromUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(audioTrackUrl, options) {\n    var response, fileInfo, res;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return fetch(audioTrackUrl);\n\n          case 2:\n            response = _context3.sent;\n            fileInfo = {\n              size: parseInt(response.headers.get('Content-Length'), 10),\n              mimeType: response.headers.get('Content-Type')\n            };\n\n            if (!response.ok) {\n              _context3.next = 25;\n              break;\n            }\n\n            if (!response.body) {\n              _context3.next = 17;\n              break;\n            }\n\n            _context3.next = 8;\n            return this.parseReadableStream(response.body, fileInfo, options);\n\n          case 8:\n            res = _context3.sent;\n            debug('Closing HTTP-readable-stream...');\n\n            if (response.body.locked) {\n              _context3.next = 13;\n              break;\n            }\n\n            _context3.next = 13;\n            return response.body.cancel();\n\n          case 13:\n            debug('HTTP-readable-stream closed.');\n            return _context3.abrupt(\"return\", res);\n\n          case 17:\n            _context3.t0 = this;\n            _context3.next = 20;\n            return response.blob();\n\n          case 20:\n            _context3.t1 = _context3.sent;\n            _context3.t2 = options;\n            return _context3.abrupt(\"return\", _context3.t0.parseBlob.call(_context3.t0, _context3.t1, _context3.t2));\n\n          case 23:\n            _context3.next = 26;\n            break;\n\n          case 25:\n            throw new Error(\"HTTP error status=\".concat(response.status, \": \").concat(response.statusText));\n\n          case 26:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, this);\n  }));\n  return _fetchFromUrl.apply(this, arguments);\n}\n\nexports.fetchFromUrl = fetchFromUrl;\n/**\r\n * Convert Web API File to Node Buffer\r\n * @param blob - Web API Blob\r\n * @returns Metadata\r\n */\n\nfunction convertBlobToBuffer(blob) {\n  return new Promise(function (resolve, reject) {\n    var fileReader = new FileReader();\n\n    fileReader.onloadend = function (event) {\n      var data = event.target.result;\n\n      if (data instanceof ArrayBuffer) {\n        data = toBuffer(new Uint8Array(event.target.result));\n      }\n\n      resolve(data);\n    };\n\n    fileReader.onerror = function (error) {\n      reject(new Error(error.type));\n    };\n\n    fileReader.onabort = function (error) {\n      reject(new Error(error.type));\n    };\n\n    fileReader.readAsArrayBuffer(blob);\n  });\n}","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata-browser/lib/index.js"],"names":["Object","defineProperty","exports","value","fetchFromUrl","parseBlob","parseReadableStream","parseNodeStream","selectCover","ratingToStars","orderTags","parseFromTokenizer","parseBuffer","initDebug","require","mm","readable_web_to_node_stream_1","toBuffer","debug","core_1","enumerable","get","parseStream","stream","fileInfo","options","ns","ReadableWebToNodeStream","mimeType","res","close","blob","convertBlobToBuffer","buf","type","size","name","path","audioTrackUrl","fetch","response","parseInt","headers","ok","body","locked","cancel","Error","status","statusText","Promise","resolve","reject","fileReader","FileReader","onloadend","event","data","target","result","ArrayBuffer","Uint8Array","onerror","error","onabort","readAsArrayBuffer"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.fetchFromUrl = exports.parseBlob = exports.parseReadableStream = exports.parseNodeStream = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = void 0;\r\nconst initDebug = require(\"debug\");\r\nconst mm = require(\"music-metadata/lib/core\");\r\nconst readable_web_to_node_stream_1 = require(\"readable-web-to-node-stream\");\r\nconst toBuffer = require(\"typedarray-to-buffer\");\r\nconst debug = initDebug('music-metadata-browser:main');\r\nvar core_1 = require(\"music-metadata/lib/core\");\r\nObject.defineProperty(exports, \"parseBuffer\", { enumerable: true, get: function () { return core_1.parseBuffer; } });\r\nObject.defineProperty(exports, \"parseFromTokenizer\", { enumerable: true, get: function () { return core_1.parseFromTokenizer; } });\r\nObject.defineProperty(exports, \"orderTags\", { enumerable: true, get: function () { return core_1.orderTags; } });\r\nObject.defineProperty(exports, \"ratingToStars\", { enumerable: true, get: function () { return core_1.ratingToStars; } });\r\nObject.defineProperty(exports, \"selectCover\", { enumerable: true, get: function () { return core_1.selectCover; } });\r\n/**\r\n * Parse audio Stream\r\n * @param stream - ReadableStream\r\n * @param contentType - MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nexports.parseNodeStream = mm.parseStream;\r\n/**\r\n * Parse Web API ReadableStream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\r\n * @param stream - ReadableStream\r\n * @param fileInfo FileInfo object or MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nasync function parseReadableStream(stream, fileInfo, options) {\r\n    const ns = new readable_web_to_node_stream_1.ReadableWebToNodeStream(stream);\r\n    const res = await exports.parseNodeStream(ns, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo, options);\r\n    await ns.close();\r\n    return res;\r\n}\r\nexports.parseReadableStream = parseReadableStream;\r\n/**\r\n * Parse Web API File\r\n * @param blob - Blob to parse\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nasync function parseBlob(blob, options) {\r\n    const buf = await convertBlobToBuffer(blob);\r\n    const fileInfo = { mimeType: blob.type, size: blob.size };\r\n    if (blob.name) {\r\n        fileInfo.path = blob.name;\r\n    }\r\n    return mm.parseBuffer(buf, { mimeType: blob.type, size: blob.size }, options);\r\n}\r\nexports.parseBlob = parseBlob;\r\n/**\r\n * Parse fetched file, using the Web Fetch API\r\n * @param audioTrackUrl - URL to download the audio track from\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nasync function fetchFromUrl(audioTrackUrl, options) {\r\n    const response = await fetch(audioTrackUrl);\r\n    const fileInfo = {\r\n        size: parseInt(response.headers.get('Content-Length'), 10),\r\n        mimeType: response.headers.get('Content-Type')\r\n    };\r\n    if (response.ok) {\r\n        if (response.body) {\r\n            const res = await this.parseReadableStream(response.body, fileInfo, options);\r\n            debug('Closing HTTP-readable-stream...');\r\n            if (!response.body.locked) { // Prevent error in Firefox\r\n                await response.body.cancel();\r\n            }\r\n            debug('HTTP-readable-stream closed.');\r\n            return res;\r\n        }\r\n        else {\r\n            // Fall back on Blob\r\n            return this.parseBlob(await response.blob(), options);\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(`HTTP error status=${response.status}: ${response.statusText}`);\r\n    }\r\n}\r\nexports.fetchFromUrl = fetchFromUrl;\r\n/**\r\n * Convert Web API File to Node Buffer\r\n * @param blob - Web API Blob\r\n * @returns Metadata\r\n */\r\nfunction convertBlobToBuffer(blob) {\r\n    return new Promise((resolve, reject) => {\r\n        const fileReader = new FileReader();\r\n        fileReader.onloadend = event => {\r\n            let data = event.target.result;\r\n            if (data instanceof ArrayBuffer) {\r\n                data = toBuffer(new Uint8Array(event.target.result));\r\n            }\r\n            resolve(data);\r\n        };\r\n        fileReader.onerror = error => {\r\n            reject(new Error(error.type));\r\n        };\r\n        fileReader.onabort = error => {\r\n            reject(new Error(error.type));\r\n        };\r\n        fileReader.readAsArrayBuffer(blob);\r\n    });\r\n}\r\n"]},"metadata":{},"sourceType":"script"}