{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DsfParser = void 0;\n\nvar AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\n\nvar _debug = require(\"debug\");\n\nvar DsfChunk_1 = require(\"./DsfChunk\");\n\nvar ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\n\nvar debug = _debug('music-metadata:parser:DSF');\n/**\r\n * DSF (dsd stream file) File Parser\r\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\r\n */\n\n\nvar DsfParser = /*#__PURE__*/function (_AbstractID3Parser_1$) {\n  _inherits(DsfParser, _AbstractID3Parser_1$);\n\n  var _super = _createSuper(DsfParser);\n\n  function DsfParser() {\n    _classCallCheck(this, DsfParser);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(DsfParser, [{\n    key: \"_parse\",\n    value: function () {\n      var _parse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var p0, chunkHeader, dsdChunk;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                p0 = this.tokenizer.position; // mark start position, normally 0\n\n                _context.next = 3;\n                return this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n\n              case 3:\n                chunkHeader = _context.sent;\n\n                if (!(chunkHeader.id !== 'DSD ')) {\n                  _context.next = 6;\n                  break;\n                }\n\n                throw new Error('Invalid chunk signature');\n\n              case 6:\n                this.metadata.setFormat('container', 'DSF');\n                this.metadata.setFormat('lossless', true);\n                _context.next = 10;\n                return this.tokenizer.readToken(DsfChunk_1.DsdChunk);\n\n              case 10:\n                dsdChunk = _context.sent;\n\n                if (!(dsdChunk.metadataPointer === 0)) {\n                  _context.next = 15;\n                  break;\n                }\n\n                debug(\"No ID3v2 tag present\");\n                _context.next = 21;\n                break;\n\n              case 15:\n                debug(\"expect ID3v2 at offset=\".concat(dsdChunk.metadataPointer));\n                _context.next = 18;\n                return this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\n\n              case 18:\n                _context.next = 20;\n                return this.tokenizer.ignore(dsdChunk.metadataPointer - this.tokenizer.position - p0);\n\n              case 20:\n                return _context.abrupt(\"return\", new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options));\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _parse() {\n        return _parse2.apply(this, arguments);\n      }\n\n      return _parse;\n    }()\n  }, {\n    key: \"parseChunks\",\n    value: function () {\n      var _parseChunks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(bytesRemaining) {\n        var chunkHeader, formatChunk, bitrate;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(bytesRemaining >= DsfChunk_1.ChunkHeader.len)) {\n                  _context2.next = 24;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n\n              case 3:\n                chunkHeader = _context2.sent;\n                debug(\"Parsing chunk name=\".concat(chunkHeader.id, \" size=\").concat(chunkHeader.size));\n                _context2.t0 = chunkHeader.id;\n                _context2.next = _context2.t0 === 'fmt ' ? 8 : 19;\n                break;\n\n              case 8:\n                _context2.next = 10;\n                return this.tokenizer.readToken(DsfChunk_1.FormatChunk);\n\n              case 10:\n                formatChunk = _context2.sent;\n                this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\n                this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\n                this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\n                this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\n                this.metadata.setFormat('duration', formatChunk.sampleCount / formatChunk.samplingFrequency);\n                bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\n                this.metadata.setFormat('bitrate', bitrate);\n                return _context2.abrupt(\"return\");\n\n              case 19:\n                this.tokenizer.ignore(chunkHeader.size - DsfChunk_1.ChunkHeader.len);\n                return _context2.abrupt(\"break\", 21);\n\n              case 21:\n                bytesRemaining -= chunkHeader.size;\n                _context2.next = 0;\n                break;\n\n              case 24:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function parseChunks(_x) {\n        return _parseChunks.apply(this, arguments);\n      }\n\n      return parseChunks;\n    }()\n  }]);\n\n  return DsfParser;\n}(AbstractID3Parser_1.AbstractID3Parser);\n\nexports.DsfParser = DsfParser;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/dsf/DsfParser.js"],"names":["Object","defineProperty","exports","value","DsfParser","AbstractID3Parser_1","require","_debug","DsfChunk_1","ID3v2Parser_1","debug","p0","tokenizer","position","readToken","ChunkHeader","chunkHeader","id","Error","metadata","setFormat","DsdChunk","dsdChunk","metadataPointer","parseChunks","fileSize","size","ignore","ID3v2Parser","parse","options","bytesRemaining","len","FormatChunk","formatChunk","channelNum","samplingFrequency","bitsPerSample","sampleCount","bitrate","AbstractID3Parser"],"mappings":"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","sourcesContent":["'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DsfParser = void 0;\r\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\r\nconst _debug = require(\"debug\");\r\nconst DsfChunk_1 = require(\"./DsfChunk\");\r\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\r\nconst debug = _debug('music-metadata:parser:DSF');\r\n/**\r\n * DSF (dsd stream file) File Parser\r\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\r\n */\r\nclass DsfParser extends AbstractID3Parser_1.AbstractID3Parser {\r\n    async _parse() {\r\n        const p0 = this.tokenizer.position; // mark start position, normally 0\r\n        const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\r\n        if (chunkHeader.id !== 'DSD ')\r\n            throw new Error('Invalid chunk signature');\r\n        this.metadata.setFormat('container', 'DSF');\r\n        this.metadata.setFormat('lossless', true);\r\n        const dsdChunk = await this.tokenizer.readToken(DsfChunk_1.DsdChunk);\r\n        if (dsdChunk.metadataPointer === 0) {\r\n            debug(`No ID3v2 tag present`);\r\n        }\r\n        else {\r\n            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\r\n            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\r\n            // Jump to ID3 header\r\n            await this.tokenizer.ignore(dsdChunk.metadataPointer - this.tokenizer.position - p0);\r\n            return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\r\n        }\r\n    }\r\n    async parseChunks(bytesRemaining) {\r\n        while (bytesRemaining >= DsfChunk_1.ChunkHeader.len) {\r\n            const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\r\n            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\r\n            switch (chunkHeader.id) {\r\n                case 'fmt ':\r\n                    const formatChunk = await this.tokenizer.readToken(DsfChunk_1.FormatChunk);\r\n                    this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\r\n                    this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\r\n                    this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\r\n                    this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\r\n                    this.metadata.setFormat('duration', formatChunk.sampleCount / formatChunk.samplingFrequency);\r\n                    const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\r\n                    this.metadata.setFormat('bitrate', bitrate);\r\n                    return; // We got what we want, stop further processing of chunks\r\n                default:\r\n                    this.tokenizer.ignore(chunkHeader.size - DsfChunk_1.ChunkHeader.len);\r\n                    break;\r\n            }\r\n            bytesRemaining -= chunkHeader.size;\r\n        }\r\n    }\r\n}\r\nexports.DsfParser = DsfParser;\r\n"]},"metadata":{},"sourceType":"script"}