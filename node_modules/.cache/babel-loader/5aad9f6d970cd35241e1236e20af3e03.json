{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FlacParser = void 0;\n\nvar Util_1 = require(\"../common/Util\");\n\nvar Token = require(\"token-types\");\n\nvar Vorbis_1 = require(\"../ogg/vorbis/Vorbis\");\n\nvar AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\n\nvar FourCC_1 = require(\"../common/FourCC\");\n\nvar _debug = require(\"debug\");\n\nvar VorbisParser_1 = require(\"../ogg/vorbis/VorbisParser\");\n\nvar VorbisDecoder_1 = require(\"../ogg/vorbis/VorbisDecoder\");\n\nvar debug = _debug('music-metadata:parser:FLAC');\n/**\r\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\r\n * ref: https://xiph.org/flac/format.html#metadata_block\r\n */\n\n\nvar BlockType;\n\n(function (BlockType) {\n  BlockType[BlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\n  BlockType[BlockType[\"PADDING\"] = 1] = \"PADDING\";\n  BlockType[BlockType[\"APPLICATION\"] = 2] = \"APPLICATION\";\n  BlockType[BlockType[\"SEEKTABLE\"] = 3] = \"SEEKTABLE\";\n  BlockType[BlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\n  BlockType[BlockType[\"CUESHEET\"] = 5] = \"CUESHEET\";\n  BlockType[BlockType[\"PICTURE\"] = 6] = \"PICTURE\";\n})(BlockType || (BlockType = {}));\n\nvar FlacParser = /*#__PURE__*/function (_AbstractID3Parser_1$) {\n  _inherits(FlacParser, _AbstractID3Parser_1$);\n\n  var _super = _createSuper(FlacParser);\n\n  function FlacParser() {\n    var _this;\n\n    _classCallCheck(this, FlacParser);\n\n    _this = _super.apply(this, arguments);\n    _this.padding = 0;\n    return _this;\n  }\n  /**\r\n   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\r\n   * @param {INativeMetadataCollector} metadata Output\r\n   * @param {ITokenizer} tokenizer Input\r\n   * @param {IOptions} options Parsing options\r\n   */\n\n\n  _createClass(FlacParser, [{\n    key: \"init\",\n    value: function init(metadata, tokenizer, options) {\n      _get(_getPrototypeOf(FlacParser.prototype), \"init\", this).call(this, metadata, tokenizer, options);\n\n      this.vorbisParser = new VorbisParser_1.VorbisParser(metadata, options);\n      return this;\n    }\n  }, {\n    key: \"_parse\",\n    value: function () {\n      var _parse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var fourCC, blockHeader, dataSize;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.tokenizer.readToken(FourCC_1.FourCcToken);\n\n              case 2:\n                fourCC = _context.sent;\n\n                if (!(fourCC.toString() !== 'fLaC')) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new Error('Invalid FLAC preamble');\n\n              case 5:\n                _context.next = 7;\n                return this.tokenizer.readToken(Metadata.BlockHeader);\n\n              case 7:\n                blockHeader = _context.sent;\n                _context.next = 10;\n                return this.parseDataBlock(blockHeader);\n\n              case 10:\n                if (!blockHeader.lastBlock) {\n                  _context.next = 5;\n                  break;\n                }\n\n              case 11:\n                if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n                  dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n                  this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n                }\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _parse() {\n        return _parse2.apply(this, arguments);\n      }\n\n      return _parse;\n    }()\n  }, {\n    key: \"parseDataBlock\",\n    value: function parseDataBlock(blockHeader) {\n      debug(\"blockHeader type=\".concat(blockHeader.type, \", length=\").concat(blockHeader.length));\n\n      switch (blockHeader.type) {\n        case BlockType.STREAMINFO:\n          return this.parseBlockStreamInfo(blockHeader.length);\n\n        case BlockType.PADDING:\n          this.padding += blockHeader.length;\n          break;\n\n        case BlockType.APPLICATION:\n          break;\n\n        case BlockType.SEEKTABLE:\n          break;\n\n        case BlockType.VORBIS_COMMENT:\n          return this.parseComment(blockHeader.length);\n\n        case BlockType.CUESHEET:\n          break;\n\n        case BlockType.PICTURE:\n          return this.parsePicture(blockHeader.length).then();\n\n        default:\n          this.metadata.addWarning('Unknown block type: ' + blockHeader.type);\n      } // Ignore data block\n\n\n      return this.tokenizer.ignore(blockHeader.length).then();\n    }\n    /**\r\n     * Parse STREAMINFO\r\n     */\n\n  }, {\n    key: \"parseBlockStreamInfo\",\n    value: function () {\n      var _parseBlockStreamInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(dataLen) {\n        var streamInfo;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(dataLen !== Metadata.BlockStreamInfo.len)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error('Unexpected block-stream-info length');\n\n              case 2:\n                _context2.next = 4;\n                return this.tokenizer.readToken(Metadata.BlockStreamInfo);\n\n              case 4:\n                streamInfo = _context2.sent;\n                this.metadata.setFormat('container', 'FLAC');\n                this.metadata.setFormat('codec', 'FLAC');\n                this.metadata.setFormat('lossless', true);\n                this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n                this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n                this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n\n                if (streamInfo.totalSamples > 0) {\n                  this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n                }\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function parseBlockStreamInfo(_x) {\n        return _parseBlockStreamInfo.apply(this, arguments);\n      }\n\n      return parseBlockStreamInfo;\n    }()\n    /**\r\n     * Parse VORBIS_COMMENT\r\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\r\n     */\n\n  }, {\n    key: \"parseComment\",\n    value: function () {\n      var _parseComment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(dataLen) {\n        var data, decoder, commentListLength, i, tag;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.tokenizer.readToken(new Token.BufferType(dataLen));\n\n              case 2:\n                data = _context3.sent;\n                decoder = new VorbisDecoder_1.VorbisDecoder(data, 0);\n                decoder.readStringUtf8(); // vendor (skip)\n\n                commentListLength = decoder.readInt32();\n\n                for (i = 0; i < commentListLength; i++) {\n                  tag = decoder.parseUserComment();\n                  this.vorbisParser.addTag(tag.key, tag.value);\n                }\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function parseComment(_x2) {\n        return _parseComment.apply(this, arguments);\n      }\n\n      return parseComment;\n    }()\n  }, {\n    key: \"parsePicture\",\n    value: function () {\n      var _parsePicture = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(dataLen) {\n        var picture;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this.options.skipCovers) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", this.tokenizer.ignore(dataLen));\n\n              case 4:\n                _context4.next = 6;\n                return this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(dataLen));\n\n              case 6:\n                picture = _context4.sent;\n                this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function parsePicture(_x3) {\n        return _parsePicture.apply(this, arguments);\n      }\n\n      return parsePicture;\n    }()\n  }]);\n\n  return FlacParser;\n}(AbstractID3Parser_1.AbstractID3Parser);\n\nexports.FlacParser = FlacParser;\n\nvar Metadata = function Metadata() {\n  _classCallCheck(this, Metadata);\n};\n\nMetadata.BlockHeader = {\n  len: 4,\n  get: function get(buf, off) {\n    return {\n      lastBlock: Util_1.default.strtokBITSET.get(buf, off, 7),\n      type: Util_1.default.getBitAllignedNumber(buf, off, 1, 7),\n      length: Token.UINT24_BE.get(buf, off + 1)\n    };\n  }\n};\n/**\r\n * METADATA_BLOCK_DATA\r\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\r\n */\n\nMetadata.BlockStreamInfo = {\n  len: 34,\n  get: function get(buf, off) {\n    return {\n      // The minimum block size (in samples) used in the stream.\n      minimumBlockSize: Token.UINT16_BE.get(buf, off),\n      // The maximum block size (in samples) used in the stream.\n      // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n      maximumBlockSize: Token.UINT16_BE.get(buf, off + 2) / 1000,\n      // The minimum frame size (in bytes) used in the stream.\n      // May be 0 to imply the value is not known.\n      minimumFrameSize: Token.UINT24_BE.get(buf, off + 4),\n      // The maximum frame size (in bytes) used in the stream.\n      // May be 0 to imply the value is not known.\n      maximumFrameSize: Token.UINT24_BE.get(buf, off + 7),\n      // Sample rate in Hz. Though 20 bits are available,\n      // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n      // Also, a value of 0 is invalid.\n      sampleRate: Token.UINT24_BE.get(buf, off + 10) >> 4,\n      // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n      // (number of channels)-1. FLAC supports from 1 to 8 channels\n      channels: Util_1.default.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n      // bits per sample)-1.\n      // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n      bitsPerSample: Util_1.default.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n      // Total samples in stream.\n      // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n      // A value of zero here means the number of total samples is unknown.\n      totalSamples: Util_1.default.getBitAllignedNumber(buf, off + 13, 4, 36),\n      // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n      fileMD5: new Token.BufferType(16).get(buf, off + 18)\n    };\n  }\n};","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/flac/FlacParser.js"],"names":["Object","defineProperty","exports","value","FlacParser","Util_1","require","Token","Vorbis_1","AbstractID3Parser_1","FourCC_1","_debug","VorbisParser_1","VorbisDecoder_1","debug","BlockType","arguments","padding","metadata","tokenizer","options","vorbisParser","VorbisParser","readToken","FourCcToken","fourCC","toString","Error","Metadata","BlockHeader","blockHeader","parseDataBlock","lastBlock","fileInfo","size","format","duration","dataSize","position","setFormat","type","length","STREAMINFO","parseBlockStreamInfo","PADDING","APPLICATION","SEEKTABLE","VORBIS_COMMENT","parseComment","CUESHEET","PICTURE","parsePicture","then","addWarning","ignore","dataLen","BlockStreamInfo","len","streamInfo","channels","bitsPerSample","sampleRate","totalSamples","BufferType","data","decoder","VorbisDecoder","readStringUtf8","commentListLength","readInt32","i","tag","parseUserComment","addTag","key","skipCovers","VorbisPictureToken","picture","AbstractID3Parser","get","buf","off","default","strtokBITSET","getBitAllignedNumber","UINT24_BE","minimumBlockSize","UINT16_BE","maximumBlockSize","minimumFrameSize","maximumFrameSize","fileMD5"],"mappings":"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","sourcesContent":["'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FlacParser = void 0;\r\nconst Util_1 = require(\"../common/Util\");\r\nconst Token = require(\"token-types\");\r\nconst Vorbis_1 = require(\"../ogg/vorbis/Vorbis\");\r\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\r\nconst FourCC_1 = require(\"../common/FourCC\");\r\nconst _debug = require(\"debug\");\r\nconst VorbisParser_1 = require(\"../ogg/vorbis/VorbisParser\");\r\nconst VorbisDecoder_1 = require(\"../ogg/vorbis/VorbisDecoder\");\r\nconst debug = _debug('music-metadata:parser:FLAC');\r\n/**\r\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\r\n * ref: https://xiph.org/flac/format.html#metadata_block\r\n */\r\nvar BlockType;\r\n(function (BlockType) {\r\n    BlockType[BlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\r\n    BlockType[BlockType[\"PADDING\"] = 1] = \"PADDING\";\r\n    BlockType[BlockType[\"APPLICATION\"] = 2] = \"APPLICATION\";\r\n    BlockType[BlockType[\"SEEKTABLE\"] = 3] = \"SEEKTABLE\";\r\n    BlockType[BlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\r\n    BlockType[BlockType[\"CUESHEET\"] = 5] = \"CUESHEET\";\r\n    BlockType[BlockType[\"PICTURE\"] = 6] = \"PICTURE\";\r\n})(BlockType || (BlockType = {}));\r\nclass FlacParser extends AbstractID3Parser_1.AbstractID3Parser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.padding = 0;\r\n    }\r\n    /**\r\n     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\r\n     * @param {INativeMetadataCollector} metadata Output\r\n     * @param {ITokenizer} tokenizer Input\r\n     * @param {IOptions} options Parsing options\r\n     */\r\n    init(metadata, tokenizer, options) {\r\n        super.init(metadata, tokenizer, options);\r\n        this.vorbisParser = new VorbisParser_1.VorbisParser(metadata, options);\r\n        return this;\r\n    }\r\n    async _parse() {\r\n        const fourCC = await this.tokenizer.readToken(FourCC_1.FourCcToken);\r\n        if (fourCC.toString() !== 'fLaC') {\r\n            throw new Error('Invalid FLAC preamble');\r\n        }\r\n        let blockHeader;\r\n        do {\r\n            // Read block header\r\n            blockHeader = await this.tokenizer.readToken(Metadata.BlockHeader);\r\n            // Parse block data\r\n            await this.parseDataBlock(blockHeader);\r\n        } while (!blockHeader.lastBlock);\r\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\r\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\r\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\r\n        }\r\n    }\r\n    parseDataBlock(blockHeader) {\r\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\r\n        switch (blockHeader.type) {\r\n            case BlockType.STREAMINFO:\r\n                return this.parseBlockStreamInfo(blockHeader.length);\r\n            case BlockType.PADDING:\r\n                this.padding += blockHeader.length;\r\n                break;\r\n            case BlockType.APPLICATION:\r\n                break;\r\n            case BlockType.SEEKTABLE:\r\n                break;\r\n            case BlockType.VORBIS_COMMENT:\r\n                return this.parseComment(blockHeader.length);\r\n            case BlockType.CUESHEET:\r\n                break;\r\n            case BlockType.PICTURE:\r\n                return this.parsePicture(blockHeader.length).then();\r\n            default:\r\n                this.metadata.addWarning('Unknown block type: ' + blockHeader.type);\r\n        }\r\n        // Ignore data block\r\n        return this.tokenizer.ignore(blockHeader.length).then();\r\n    }\r\n    /**\r\n     * Parse STREAMINFO\r\n     */\r\n    async parseBlockStreamInfo(dataLen) {\r\n        if (dataLen !== Metadata.BlockStreamInfo.len)\r\n            throw new Error('Unexpected block-stream-info length');\r\n        const streamInfo = await this.tokenizer.readToken(Metadata.BlockStreamInfo);\r\n        this.metadata.setFormat('container', 'FLAC');\r\n        this.metadata.setFormat('codec', 'FLAC');\r\n        this.metadata.setFormat('lossless', true);\r\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\r\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\r\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\r\n        if (streamInfo.totalSamples > 0) {\r\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\r\n        }\r\n    }\r\n    /**\r\n     * Parse VORBIS_COMMENT\r\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\r\n     */\r\n    async parseComment(dataLen) {\r\n        const data = await this.tokenizer.readToken(new Token.BufferType(dataLen));\r\n        const decoder = new VorbisDecoder_1.VorbisDecoder(data, 0);\r\n        decoder.readStringUtf8(); // vendor (skip)\r\n        const commentListLength = decoder.readInt32();\r\n        for (let i = 0; i < commentListLength; i++) {\r\n            const tag = decoder.parseUserComment();\r\n            this.vorbisParser.addTag(tag.key, tag.value);\r\n        }\r\n    }\r\n    async parsePicture(dataLen) {\r\n        if (this.options.skipCovers) {\r\n            return this.tokenizer.ignore(dataLen);\r\n        }\r\n        else {\r\n            const picture = await this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(dataLen));\r\n            this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);\r\n        }\r\n    }\r\n}\r\nexports.FlacParser = FlacParser;\r\nclass Metadata {\r\n}\r\nMetadata.BlockHeader = {\r\n    len: 4,\r\n    get: (buf, off) => {\r\n        return {\r\n            lastBlock: Util_1.default.strtokBITSET.get(buf, off, 7),\r\n            type: Util_1.default.getBitAllignedNumber(buf, off, 1, 7),\r\n            length: Token.UINT24_BE.get(buf, off + 1)\r\n        };\r\n    }\r\n};\r\n/**\r\n * METADATA_BLOCK_DATA\r\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\r\n */\r\nMetadata.BlockStreamInfo = {\r\n    len: 34,\r\n    get: (buf, off) => {\r\n        return {\r\n            // The minimum block size (in samples) used in the stream.\r\n            minimumBlockSize: Token.UINT16_BE.get(buf, off),\r\n            // The maximum block size (in samples) used in the stream.\r\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\r\n            maximumBlockSize: Token.UINT16_BE.get(buf, off + 2) / 1000,\r\n            // The minimum frame size (in bytes) used in the stream.\r\n            // May be 0 to imply the value is not known.\r\n            minimumFrameSize: Token.UINT24_BE.get(buf, off + 4),\r\n            // The maximum frame size (in bytes) used in the stream.\r\n            // May be 0 to imply the value is not known.\r\n            maximumFrameSize: Token.UINT24_BE.get(buf, off + 7),\r\n            // Sample rate in Hz. Though 20 bits are available,\r\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\r\n            // Also, a value of 0 is invalid.\r\n            sampleRate: Token.UINT24_BE.get(buf, off + 10) >> 4,\r\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\r\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\r\n            channels: Util_1.default.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\r\n            // bits per sample)-1.\r\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\r\n            bitsPerSample: Util_1.default.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\r\n            // Total samples in stream.\r\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\r\n            // A value of zero here means the number of total samples is unknown.\r\n            totalSamples: Util_1.default.getBitAllignedNumber(buf, off + 13, 4, 36),\r\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\r\n            fileMD5: new Token.BufferType(16).get(buf, off + 18)\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}