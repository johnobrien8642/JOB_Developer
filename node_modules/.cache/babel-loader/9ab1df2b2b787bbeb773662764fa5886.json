{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.APEv2Parser = void 0;\n\nconst initDebug = require(\"debug\");\n\nconst strtok3 = require(\"strtok3/lib/core\");\n\nconst Util_1 = require(\"../common/Util\");\n\nconst BasicParser_1 = require(\"../common/BasicParser\");\n\nconst APEv2Token_1 = require(\"./APEv2Token\");\n\nconst token_types_1 = require(\"token-types\");\n\nconst debug = initDebug('music-metadata:parser:APEv2');\nconst tagFormat = 'APEv2';\nconst preamble = 'APETAGEX';\n\nclass APEv2Parser extends BasicParser_1.BasicParser {\n  constructor() {\n    super(...arguments);\n    this.ape = {};\n  }\n\n  static tryParseApeHeader(metadata, tokenizer, options) {\n    const apeParser = new APEv2Parser();\n    apeParser.init(metadata, tokenizer, options);\n    return apeParser.tryParseApeHeader();\n  }\n  /**\r\n   * Calculate the media file duration\r\n   * @param ah ApeHeader\r\n   * @return {number} duration in seconds\r\n   */\n\n\n  static calculateDuration(ah) {\n    let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n    duration += ah.finalFrameBlocks;\n    return duration / ah.sampleRate;\n  }\n  /**\r\n   * Calculates the APEv1 / APEv2 first field offset\r\n   * @param reader\r\n   * @param offset\r\n   */\n\n\n  static async findApeFooterOffset(reader, offset) {\n    // Search for APE footer header at the end of the file\n    const apeBuf = Buffer.alloc(APEv2Token_1.TagFooter.len);\n    await reader.randomRead(apeBuf, 0, APEv2Token_1.TagFooter.len, offset - APEv2Token_1.TagFooter.len);\n    const tagFooter = APEv2Token_1.TagFooter.get(apeBuf, 0);\n\n    if (tagFooter.ID === 'APETAGEX') {\n      debug(`APE footer header at offset=${offset}`);\n      return {\n        footer: tagFooter,\n        offset: offset - tagFooter.size\n      };\n    }\n  }\n\n  static parseTagFooter(metadata, buffer, options) {\n    const footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);\n    if (footer.ID !== preamble) throw new Error('Unexpected APEv2 Footer ID preamble value.');\n    strtok3.fromBuffer(buffer);\n    const apeParser = new APEv2Parser();\n    apeParser.init(metadata, strtok3.fromBuffer(buffer), options);\n    return apeParser.parseTags(footer);\n  }\n  /**\r\n   * Parse APEv1 / APEv2 header if header signature found\r\n   */\n\n\n  async tryParseApeHeader() {\n    if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {\n      debug(`No APEv2 header found, end-of-file reached`);\n      return;\n    }\n\n    const footer = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);\n\n    if (footer.ID === preamble) {\n      await this.tokenizer.ignore(APEv2Token_1.TagFooter.len);\n      return this.parseTags(footer);\n    } else {\n      debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\n\n      if (this.tokenizer.fileInfo.size) {\n        // Try to read the APEv2 header using just the footer-header\n        const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\n\n        const buffer = Buffer.alloc(remaining);\n        await this.tokenizer.readBuffer(buffer);\n        return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\n      }\n    }\n  }\n\n  async parse() {\n    const descriptor = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);\n    if (descriptor.ID !== 'MAC ') throw new Error('Unexpected descriptor ID');\n    this.ape.descriptor = descriptor;\n    const lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len;\n    const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\n    await this.tokenizer.ignore(header.forwardBytes);\n    return this.tryParseApeHeader();\n  }\n\n  async parseTags(footer) {\n    const keyBuffer = Buffer.alloc(256); // maximum tag key length\n\n    let bytesRemaining = footer.size - APEv2Token_1.TagFooter.len;\n    debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\n\n    for (let i = 0; i < footer.fields; i++) {\n      if (bytesRemaining < APEv2Token_1.TagItemHeader.len) {\n        this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\n        break;\n      } // Only APEv2 tag has tag item headers\n\n\n      const tagItemHeader = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);\n      bytesRemaining -= APEv2Token_1.TagItemHeader.len + tagItemHeader.size;\n      await this.tokenizer.peekBuffer(keyBuffer, {\n        length: Math.min(keyBuffer.length, bytesRemaining)\n      });\n      let zero = Util_1.default.findZero(keyBuffer, 0, keyBuffer.length);\n      const key = await this.tokenizer.readToken(new token_types_1.StringType(zero, 'ascii'));\n      await this.tokenizer.ignore(1);\n      bytesRemaining -= key.length + 1;\n\n      switch (tagItemHeader.flags.dataType) {\n        case APEv2Token_1.DataType.text_utf8:\n          {\n            // utf-8 textstring\n            const value = await this.tokenizer.readToken(new token_types_1.StringType(tagItemHeader.size, 'utf8'));\n            const values = value.split(/\\x00/g);\n            /*jshint loopfunc:true */\n\n            for (const val of values) {\n              this.metadata.addTag(tagFormat, key, val);\n            }\n\n            break;\n          }\n\n        case APEv2Token_1.DataType.binary:\n          // binary (probably artwork)\n          if (this.options.skipCovers) {\n            await this.tokenizer.ignore(tagItemHeader.size);\n          } else {\n            const picData = Buffer.alloc(tagItemHeader.size);\n            await this.tokenizer.readBuffer(picData);\n            zero = Util_1.default.findZero(picData, 0, picData.length);\n            const description = picData.toString('utf8', 0, zero);\n            const data = Buffer.from(picData.slice(zero + 1));\n            this.metadata.addTag(tagFormat, key, {\n              description,\n              data\n            });\n          }\n\n          break;\n\n        case APEv2Token_1.DataType.external_info:\n          debug(`Ignore external info ${key}`);\n          await this.tokenizer.ignore(tagItemHeader.size);\n          break;\n\n        default:\n          throw new Error(`Unexpected data-type: ${tagItemHeader.flags.dataType}`);\n      }\n    }\n  }\n\n  async parseDescriptorExpansion(lenExp) {\n    await this.tokenizer.ignore(lenExp);\n    return this.parseHeader();\n  }\n\n  async parseHeader() {\n    const header = await this.tokenizer.readToken(APEv2Token_1.Header); // ToDo before\n\n    this.metadata.setFormat('lossless', true);\n    this.metadata.setFormat('container', 'Monkey\\'s Audio');\n    this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\n    this.metadata.setFormat('sampleRate', header.sampleRate);\n    this.metadata.setFormat('numberOfChannels', header.channel);\n    this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\n    return {\n      forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n    };\n  }\n\n}\n\nexports.APEv2Parser = APEv2Parser;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/apev2/APEv2Parser.js"],"names":["Object","defineProperty","exports","value","APEv2Parser","initDebug","require","strtok3","Util_1","BasicParser_1","APEv2Token_1","token_types_1","debug","tagFormat","preamble","BasicParser","constructor","arguments","ape","tryParseApeHeader","metadata","tokenizer","options","apeParser","init","calculateDuration","ah","duration","totalFrames","blocksPerFrame","finalFrameBlocks","sampleRate","findApeFooterOffset","reader","offset","apeBuf","Buffer","alloc","TagFooter","len","randomRead","tagFooter","get","ID","footer","size","parseTagFooter","buffer","length","Error","fromBuffer","parseTags","fileInfo","position","peekToken","ignore","remaining","readBuffer","parse","descriptor","readToken","DescriptorParser","lenExp","descriptorBytes","header","parseDescriptorExpansion","parseHeader","forwardBytes","keyBuffer","bytesRemaining","i","fields","TagItemHeader","addWarning","tagItemHeader","peekBuffer","Math","min","zero","default","findZero","key","StringType","flags","dataType","DataType","text_utf8","values","split","val","addTag","binary","skipCovers","picData","description","toString","data","from","slice","external_info","Header","setFormat","bitsPerSample","channel","seekTableBytes","headerDataBytes","apeFrameDataBytes","terminatingDataBytes"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,WAAR,GAAsB,KAAK,CAA3B;;AACA,MAAMC,SAAS,GAAGC,OAAO,CAAC,OAAD,CAAzB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,kBAAD,CAAvB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,gBAAD,CAAtB;;AACA,MAAMG,aAAa,GAAGH,OAAO,CAAC,uBAAD,CAA7B;;AACA,MAAMI,YAAY,GAAGJ,OAAO,CAAC,cAAD,CAA5B;;AACA,MAAMK,aAAa,GAAGL,OAAO,CAAC,aAAD,CAA7B;;AACA,MAAMM,KAAK,GAAGP,SAAS,CAAC,6BAAD,CAAvB;AACA,MAAMQ,SAAS,GAAG,OAAlB;AACA,MAAMC,QAAQ,GAAG,UAAjB;;AACA,MAAMV,WAAN,SAA0BK,aAAa,CAACM,WAAxC,CAAoD;AAChDC,EAAAA,WAAW,GAAG;AACV,UAAM,GAAGC,SAAT;AACA,SAAKC,GAAL,GAAW,EAAX;AACH;;AACuB,SAAjBC,iBAAiB,CAACC,QAAD,EAAWC,SAAX,EAAsBC,OAAtB,EAA+B;AACnD,UAAMC,SAAS,GAAG,IAAInB,WAAJ,EAAlB;AACAmB,IAAAA,SAAS,CAACC,IAAV,CAAeJ,QAAf,EAAyBC,SAAzB,EAAoCC,OAApC;AACA,WAAOC,SAAS,CAACJ,iBAAV,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AAC4B,SAAjBM,iBAAiB,CAACC,EAAD,EAAK;AACzB,QAAIC,QAAQ,GAAGD,EAAE,CAACE,WAAH,GAAiB,CAAjB,GAAqBF,EAAE,CAACG,cAAH,IAAqBH,EAAE,CAACE,WAAH,GAAiB,CAAtC,CAArB,GAAgE,CAA/E;AACAD,IAAAA,QAAQ,IAAID,EAAE,CAACI,gBAAf;AACA,WAAOH,QAAQ,GAAGD,EAAE,CAACK,UAArB;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACoC,eAAnBC,mBAAmB,CAACC,MAAD,EAASC,MAAT,EAAiB;AAC7C;AACA,UAAMC,MAAM,GAAGC,MAAM,CAACC,KAAP,CAAa3B,YAAY,CAAC4B,SAAb,CAAuBC,GAApC,CAAf;AACA,UAAMN,MAAM,CAACO,UAAP,CAAkBL,MAAlB,EAA0B,CAA1B,EAA6BzB,YAAY,CAAC4B,SAAb,CAAuBC,GAApD,EAAyDL,MAAM,GAAGxB,YAAY,CAAC4B,SAAb,CAAuBC,GAAzF,CAAN;AACA,UAAME,SAAS,GAAG/B,YAAY,CAAC4B,SAAb,CAAuBI,GAAvB,CAA2BP,MAA3B,EAAmC,CAAnC,CAAlB;;AACA,QAAIM,SAAS,CAACE,EAAV,KAAiB,UAArB,EAAiC;AAC7B/B,MAAAA,KAAK,CAAE,+BAA8BsB,MAAO,EAAvC,CAAL;AACA,aAAO;AAAEU,QAAAA,MAAM,EAAEH,SAAV;AAAqBP,QAAAA,MAAM,EAAEA,MAAM,GAAGO,SAAS,CAACI;AAAhD,OAAP;AACH;AACJ;;AACoB,SAAdC,cAAc,CAAC1B,QAAD,EAAW2B,MAAX,EAAmBzB,OAAnB,EAA4B;AAC7C,UAAMsB,MAAM,GAAGlC,YAAY,CAAC4B,SAAb,CAAuBI,GAAvB,CAA2BK,MAA3B,EAAmCA,MAAM,CAACC,MAAP,GAAgBtC,YAAY,CAAC4B,SAAb,CAAuBC,GAA1E,CAAf;AACA,QAAIK,MAAM,CAACD,EAAP,KAAc7B,QAAlB,EACI,MAAM,IAAImC,KAAJ,CAAU,4CAAV,CAAN;AACJ1C,IAAAA,OAAO,CAAC2C,UAAR,CAAmBH,MAAnB;AACA,UAAMxB,SAAS,GAAG,IAAInB,WAAJ,EAAlB;AACAmB,IAAAA,SAAS,CAACC,IAAV,CAAeJ,QAAf,EAAyBb,OAAO,CAAC2C,UAAR,CAAmBH,MAAnB,CAAzB,EAAqDzB,OAArD;AACA,WAAOC,SAAS,CAAC4B,SAAV,CAAoBP,MAApB,CAAP;AACH;AACD;AACJ;AACA;;;AAC2B,QAAjBzB,iBAAiB,GAAG;AACtB,QAAI,KAAKE,SAAL,CAAe+B,QAAf,CAAwBP,IAAxB,IAAgC,KAAKxB,SAAL,CAAe+B,QAAf,CAAwBP,IAAxB,GAA+B,KAAKxB,SAAL,CAAegC,QAA9C,GAAyD3C,YAAY,CAAC4B,SAAb,CAAuBC,GAApH,EAAyH;AACrH3B,MAAAA,KAAK,CAAE,4CAAF,CAAL;AACA;AACH;;AACD,UAAMgC,MAAM,GAAG,MAAM,KAAKvB,SAAL,CAAeiC,SAAf,CAAyB5C,YAAY,CAAC4B,SAAtC,CAArB;;AACA,QAAIM,MAAM,CAACD,EAAP,KAAc7B,QAAlB,EAA4B;AACxB,YAAM,KAAKO,SAAL,CAAekC,MAAf,CAAsB7C,YAAY,CAAC4B,SAAb,CAAuBC,GAA7C,CAAN;AACA,aAAO,KAAKY,SAAL,CAAeP,MAAf,CAAP;AACH,KAHD,MAIK;AACDhC,MAAAA,KAAK,CAAE,oCAAmC,KAAKS,SAAL,CAAegC,QAAS,EAA7D,CAAL;;AACA,UAAI,KAAKhC,SAAL,CAAe+B,QAAf,CAAwBP,IAA5B,EAAkC;AAC9B;AACA,cAAMW,SAAS,GAAG,KAAKnC,SAAL,CAAe+B,QAAf,CAAwBP,IAAxB,GAA+B,KAAKxB,SAAL,CAAegC,QAAhE,CAF8B,CAE4C;;AAC1E,cAAMN,MAAM,GAAGX,MAAM,CAACC,KAAP,CAAamB,SAAb,CAAf;AACA,cAAM,KAAKnC,SAAL,CAAeoC,UAAf,CAA0BV,MAA1B,CAAN;AACA,eAAO3C,WAAW,CAAC0C,cAAZ,CAA2B,KAAK1B,QAAhC,EAA0C2B,MAA1C,EAAkD,KAAKzB,OAAvD,CAAP;AACH;AACJ;AACJ;;AACU,QAALoC,KAAK,GAAG;AACV,UAAMC,UAAU,GAAG,MAAM,KAAKtC,SAAL,CAAeuC,SAAf,CAAyBlD,YAAY,CAACmD,gBAAtC,CAAzB;AACA,QAAIF,UAAU,CAAChB,EAAX,KAAkB,MAAtB,EACI,MAAM,IAAIM,KAAJ,CAAU,0BAAV,CAAN;AACJ,SAAK/B,GAAL,CAASyC,UAAT,GAAsBA,UAAtB;AACA,UAAMG,MAAM,GAAGH,UAAU,CAACI,eAAX,GAA6BrD,YAAY,CAACmD,gBAAb,CAA8BtB,GAA1E;AACA,UAAMyB,MAAM,GAAG,OAAOF,MAAM,GAAG,CAAT,GAAa,KAAKG,wBAAL,CAA8BH,MAA9B,CAAb,GAAqD,KAAKI,WAAL,EAA5D,CAAf;AACA,UAAM,KAAK7C,SAAL,CAAekC,MAAf,CAAsBS,MAAM,CAACG,YAA7B,CAAN;AACA,WAAO,KAAKhD,iBAAL,EAAP;AACH;;AACc,QAATgC,SAAS,CAACP,MAAD,EAAS;AACpB,UAAMwB,SAAS,GAAGhC,MAAM,CAACC,KAAP,CAAa,GAAb,CAAlB,CADoB,CACiB;;AACrC,QAAIgC,cAAc,GAAGzB,MAAM,CAACC,IAAP,GAAcnC,YAAY,CAAC4B,SAAb,CAAuBC,GAA1D;AACA3B,IAAAA,KAAK,CAAE,4BAA2B,KAAKS,SAAL,CAAegC,QAAS,UAASgB,cAAe,EAA7E,CAAL;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1B,MAAM,CAAC2B,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpC,UAAID,cAAc,GAAG3D,YAAY,CAAC8D,aAAb,CAA2BjC,GAAhD,EAAqD;AACjD,aAAKnB,QAAL,CAAcqD,UAAd,CAA0B,qBAAoB7B,MAAM,CAAC2B,MAAP,GAAgBD,CAAE,iDAAhE;AACA;AACH,OAJmC,CAKpC;;;AACA,YAAMI,aAAa,GAAG,MAAM,KAAKrD,SAAL,CAAeuC,SAAf,CAAyBlD,YAAY,CAAC8D,aAAtC,CAA5B;AACAH,MAAAA,cAAc,IAAI3D,YAAY,CAAC8D,aAAb,CAA2BjC,GAA3B,GAAiCmC,aAAa,CAAC7B,IAAjE;AACA,YAAM,KAAKxB,SAAL,CAAesD,UAAf,CAA0BP,SAA1B,EAAqC;AAAEpB,QAAAA,MAAM,EAAE4B,IAAI,CAACC,GAAL,CAAST,SAAS,CAACpB,MAAnB,EAA2BqB,cAA3B;AAAV,OAArC,CAAN;AACA,UAAIS,IAAI,GAAGtE,MAAM,CAACuE,OAAP,CAAeC,QAAf,CAAwBZ,SAAxB,EAAmC,CAAnC,EAAsCA,SAAS,CAACpB,MAAhD,CAAX;AACA,YAAMiC,GAAG,GAAG,MAAM,KAAK5D,SAAL,CAAeuC,SAAf,CAAyB,IAAIjD,aAAa,CAACuE,UAAlB,CAA6BJ,IAA7B,EAAmC,OAAnC,CAAzB,CAAlB;AACA,YAAM,KAAKzD,SAAL,CAAekC,MAAf,CAAsB,CAAtB,CAAN;AACAc,MAAAA,cAAc,IAAIY,GAAG,CAACjC,MAAJ,GAAa,CAA/B;;AACA,cAAQ0B,aAAa,CAACS,KAAd,CAAoBC,QAA5B;AACI,aAAK1E,YAAY,CAAC2E,QAAb,CAAsBC,SAA3B;AAAsC;AAAE;AACpC,kBAAMnF,KAAK,GAAG,MAAM,KAAKkB,SAAL,CAAeuC,SAAf,CAAyB,IAAIjD,aAAa,CAACuE,UAAlB,CAA6BR,aAAa,CAAC7B,IAA3C,EAAiD,MAAjD,CAAzB,CAApB;AACA,kBAAM0C,MAAM,GAAGpF,KAAK,CAACqF,KAAN,CAAY,OAAZ,CAAf;AACA;;AACA,iBAAK,MAAMC,GAAX,IAAkBF,MAAlB,EAA0B;AACtB,mBAAKnE,QAAL,CAAcsE,MAAd,CAAqB7E,SAArB,EAAgCoE,GAAhC,EAAqCQ,GAArC;AACH;;AACD;AACH;;AACD,aAAK/E,YAAY,CAAC2E,QAAb,CAAsBM,MAA3B;AAAmC;AAC/B,cAAI,KAAKrE,OAAL,CAAasE,UAAjB,EAA6B;AACzB,kBAAM,KAAKvE,SAAL,CAAekC,MAAf,CAAsBmB,aAAa,CAAC7B,IAApC,CAAN;AACH,WAFD,MAGK;AACD,kBAAMgD,OAAO,GAAGzD,MAAM,CAACC,KAAP,CAAaqC,aAAa,CAAC7B,IAA3B,CAAhB;AACA,kBAAM,KAAKxB,SAAL,CAAeoC,UAAf,CAA0BoC,OAA1B,CAAN;AACAf,YAAAA,IAAI,GAAGtE,MAAM,CAACuE,OAAP,CAAeC,QAAf,CAAwBa,OAAxB,EAAiC,CAAjC,EAAoCA,OAAO,CAAC7C,MAA5C,CAAP;AACA,kBAAM8C,WAAW,GAAGD,OAAO,CAACE,QAAR,CAAiB,MAAjB,EAAyB,CAAzB,EAA4BjB,IAA5B,CAApB;AACA,kBAAMkB,IAAI,GAAG5D,MAAM,CAAC6D,IAAP,CAAYJ,OAAO,CAACK,KAAR,CAAcpB,IAAI,GAAG,CAArB,CAAZ,CAAb;AACA,iBAAK1D,QAAL,CAAcsE,MAAd,CAAqB7E,SAArB,EAAgCoE,GAAhC,EAAqC;AACjCa,cAAAA,WADiC;AAEjCE,cAAAA;AAFiC,aAArC;AAIH;;AACD;;AACJ,aAAKtF,YAAY,CAAC2E,QAAb,CAAsBc,aAA3B;AACIvF,UAAAA,KAAK,CAAE,wBAAuBqE,GAAI,EAA7B,CAAL;AACA,gBAAM,KAAK5D,SAAL,CAAekC,MAAf,CAAsBmB,aAAa,CAAC7B,IAApC,CAAN;AACA;;AACJ;AACI,gBAAM,IAAII,KAAJ,CAAW,yBAAwByB,aAAa,CAACS,KAAd,CAAoBC,QAAS,EAAhE,CAAN;AA/BR;AAiCH;AACJ;;AAC6B,QAAxBnB,wBAAwB,CAACH,MAAD,EAAS;AACnC,UAAM,KAAKzC,SAAL,CAAekC,MAAf,CAAsBO,MAAtB,CAAN;AACA,WAAO,KAAKI,WAAL,EAAP;AACH;;AACgB,QAAXA,WAAW,GAAG;AAChB,UAAMF,MAAM,GAAG,MAAM,KAAK3C,SAAL,CAAeuC,SAAf,CAAyBlD,YAAY,CAAC0F,MAAtC,CAArB,CADgB,CAEhB;;AACA,SAAKhF,QAAL,CAAciF,SAAd,CAAwB,UAAxB,EAAoC,IAApC;AACA,SAAKjF,QAAL,CAAciF,SAAd,CAAwB,WAAxB,EAAqC,iBAArC;AACA,SAAKjF,QAAL,CAAciF,SAAd,CAAwB,eAAxB,EAAyCrC,MAAM,CAACsC,aAAhD;AACA,SAAKlF,QAAL,CAAciF,SAAd,CAAwB,YAAxB,EAAsCrC,MAAM,CAACjC,UAA7C;AACA,SAAKX,QAAL,CAAciF,SAAd,CAAwB,kBAAxB,EAA4CrC,MAAM,CAACuC,OAAnD;AACA,SAAKnF,QAAL,CAAciF,SAAd,CAAwB,UAAxB,EAAoCjG,WAAW,CAACqB,iBAAZ,CAA8BuC,MAA9B,CAApC;AACA,WAAO;AACHG,MAAAA,YAAY,EAAE,KAAKjD,GAAL,CAASyC,UAAT,CAAoB6C,cAApB,GAAqC,KAAKtF,GAAL,CAASyC,UAAT,CAAoB8C,eAAzD,GACV,KAAKvF,GAAL,CAASyC,UAAT,CAAoB+C,iBADV,GAC8B,KAAKxF,GAAL,CAASyC,UAAT,CAAoBgD;AAF7D,KAAP;AAIH;;AAnJ+C;;AAqJpDzG,OAAO,CAACE,WAAR,GAAsBA,WAAtB","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.APEv2Parser = void 0;\r\nconst initDebug = require(\"debug\");\r\nconst strtok3 = require(\"strtok3/lib/core\");\r\nconst Util_1 = require(\"../common/Util\");\r\nconst BasicParser_1 = require(\"../common/BasicParser\");\r\nconst APEv2Token_1 = require(\"./APEv2Token\");\r\nconst token_types_1 = require(\"token-types\");\r\nconst debug = initDebug('music-metadata:parser:APEv2');\r\nconst tagFormat = 'APEv2';\r\nconst preamble = 'APETAGEX';\r\nclass APEv2Parser extends BasicParser_1.BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.ape = {};\r\n    }\r\n    static tryParseApeHeader(metadata, tokenizer, options) {\r\n        const apeParser = new APEv2Parser();\r\n        apeParser.init(metadata, tokenizer, options);\r\n        return apeParser.tryParseApeHeader();\r\n    }\r\n    /**\r\n     * Calculate the media file duration\r\n     * @param ah ApeHeader\r\n     * @return {number} duration in seconds\r\n     */\r\n    static calculateDuration(ah) {\r\n        let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\r\n        duration += ah.finalFrameBlocks;\r\n        return duration / ah.sampleRate;\r\n    }\r\n    /**\r\n     * Calculates the APEv1 / APEv2 first field offset\r\n     * @param reader\r\n     * @param offset\r\n     */\r\n    static async findApeFooterOffset(reader, offset) {\r\n        // Search for APE footer header at the end of the file\r\n        const apeBuf = Buffer.alloc(APEv2Token_1.TagFooter.len);\r\n        await reader.randomRead(apeBuf, 0, APEv2Token_1.TagFooter.len, offset - APEv2Token_1.TagFooter.len);\r\n        const tagFooter = APEv2Token_1.TagFooter.get(apeBuf, 0);\r\n        if (tagFooter.ID === 'APETAGEX') {\r\n            debug(`APE footer header at offset=${offset}`);\r\n            return { footer: tagFooter, offset: offset - tagFooter.size };\r\n        }\r\n    }\r\n    static parseTagFooter(metadata, buffer, options) {\r\n        const footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);\r\n        if (footer.ID !== preamble)\r\n            throw new Error('Unexpected APEv2 Footer ID preamble value.');\r\n        strtok3.fromBuffer(buffer);\r\n        const apeParser = new APEv2Parser();\r\n        apeParser.init(metadata, strtok3.fromBuffer(buffer), options);\r\n        return apeParser.parseTags(footer);\r\n    }\r\n    /**\r\n     * Parse APEv1 / APEv2 header if header signature found\r\n     */\r\n    async tryParseApeHeader() {\r\n        if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {\r\n            debug(`No APEv2 header found, end-of-file reached`);\r\n            return;\r\n        }\r\n        const footer = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);\r\n        if (footer.ID === preamble) {\r\n            await this.tokenizer.ignore(APEv2Token_1.TagFooter.len);\r\n            return this.parseTags(footer);\r\n        }\r\n        else {\r\n            debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\r\n            if (this.tokenizer.fileInfo.size) {\r\n                // Try to read the APEv2 header using just the footer-header\r\n                const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\r\n                const buffer = Buffer.alloc(remaining);\r\n                await this.tokenizer.readBuffer(buffer);\r\n                return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\r\n            }\r\n        }\r\n    }\r\n    async parse() {\r\n        const descriptor = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);\r\n        if (descriptor.ID !== 'MAC ')\r\n            throw new Error('Unexpected descriptor ID');\r\n        this.ape.descriptor = descriptor;\r\n        const lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len;\r\n        const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\r\n        await this.tokenizer.ignore(header.forwardBytes);\r\n        return this.tryParseApeHeader();\r\n    }\r\n    async parseTags(footer) {\r\n        const keyBuffer = Buffer.alloc(256); // maximum tag key length\r\n        let bytesRemaining = footer.size - APEv2Token_1.TagFooter.len;\r\n        debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\r\n        for (let i = 0; i < footer.fields; i++) {\r\n            if (bytesRemaining < APEv2Token_1.TagItemHeader.len) {\r\n                this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\r\n                break;\r\n            }\r\n            // Only APEv2 tag has tag item headers\r\n            const tagItemHeader = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);\r\n            bytesRemaining -= APEv2Token_1.TagItemHeader.len + tagItemHeader.size;\r\n            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });\r\n            let zero = Util_1.default.findZero(keyBuffer, 0, keyBuffer.length);\r\n            const key = await this.tokenizer.readToken(new token_types_1.StringType(zero, 'ascii'));\r\n            await this.tokenizer.ignore(1);\r\n            bytesRemaining -= key.length + 1;\r\n            switch (tagItemHeader.flags.dataType) {\r\n                case APEv2Token_1.DataType.text_utf8: { // utf-8 textstring\r\n                    const value = await this.tokenizer.readToken(new token_types_1.StringType(tagItemHeader.size, 'utf8'));\r\n                    const values = value.split(/\\x00/g);\r\n                    /*jshint loopfunc:true */\r\n                    for (const val of values) {\r\n                        this.metadata.addTag(tagFormat, key, val);\r\n                    }\r\n                    break;\r\n                }\r\n                case APEv2Token_1.DataType.binary: // binary (probably artwork)\r\n                    if (this.options.skipCovers) {\r\n                        await this.tokenizer.ignore(tagItemHeader.size);\r\n                    }\r\n                    else {\r\n                        const picData = Buffer.alloc(tagItemHeader.size);\r\n                        await this.tokenizer.readBuffer(picData);\r\n                        zero = Util_1.default.findZero(picData, 0, picData.length);\r\n                        const description = picData.toString('utf8', 0, zero);\r\n                        const data = Buffer.from(picData.slice(zero + 1));\r\n                        this.metadata.addTag(tagFormat, key, {\r\n                            description,\r\n                            data\r\n                        });\r\n                    }\r\n                    break;\r\n                case APEv2Token_1.DataType.external_info:\r\n                    debug(`Ignore external info ${key}`);\r\n                    await this.tokenizer.ignore(tagItemHeader.size);\r\n                    break;\r\n                default:\r\n                    throw new Error(`Unexpected data-type: ${tagItemHeader.flags.dataType}`);\r\n            }\r\n        }\r\n    }\r\n    async parseDescriptorExpansion(lenExp) {\r\n        await this.tokenizer.ignore(lenExp);\r\n        return this.parseHeader();\r\n    }\r\n    async parseHeader() {\r\n        const header = await this.tokenizer.readToken(APEv2Token_1.Header);\r\n        // ToDo before\r\n        this.metadata.setFormat('lossless', true);\r\n        this.metadata.setFormat('container', 'Monkey\\'s Audio');\r\n        this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\r\n        this.metadata.setFormat('sampleRate', header.sampleRate);\r\n        this.metadata.setFormat('numberOfChannels', header.channel);\r\n        this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\r\n        return {\r\n            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +\r\n                this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\r\n        };\r\n    }\r\n}\r\nexports.APEv2Parser = APEv2Parser;\r\n"]},"metadata":{},"sourceType":"script"}