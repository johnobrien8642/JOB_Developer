{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReadStreamTokenizer = void 0;\n\nvar AbstractTokenizer_1 = require(\"./AbstractTokenizer\");\n\nvar peek_readable_1 = require(\"peek-readable\"); // import * as _debug from 'debug';\n// const debug = _debug('strtok3:ReadStreamTokenizer');\n\n\nvar maxBufferSize = 256000;\n\nvar ReadStreamTokenizer = /*#__PURE__*/function (_AbstractTokenizer_1$) {\n  _inherits(ReadStreamTokenizer, _AbstractTokenizer_1$);\n\n  var _super = _createSuper(ReadStreamTokenizer);\n\n  function ReadStreamTokenizer(stream, fileInfo) {\n    var _this;\n\n    _classCallCheck(this, ReadStreamTokenizer);\n\n    _this = _super.call(this, fileInfo);\n    _this.streamReader = new peek_readable_1.StreamReader(stream);\n    return _this;\n  }\n  /**\n   * Get file information, an HTTP-client may implement this doing a HEAD request\n   * @return Promise with file information\n   */\n\n\n  _createClass(ReadStreamTokenizer, [{\n    key: \"getFileInfo\",\n    value: function () {\n      var _getFileInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.fileInfo);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getFileInfo() {\n        return _getFileInfo.apply(this, arguments);\n      }\n\n      return getFileInfo;\n    }()\n    /**\n     * Read buffer from tokenizer\n     * @param buffer - Target buffer to fill with data read from the tokenizer-stream\n     * @param options - Read behaviour options\n     * @returns Promise with number of bytes read\n     */\n\n  }, {\n    key: \"readBuffer\",\n    value: function () {\n      var _readBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(buffer, options) {\n        var offset, length, skipBytes, bytesRead;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // const _offset = position ? position : this.position;\n                // debug(`readBuffer ${_offset}...${_offset + length - 1}`);\n                offset = 0;\n                length = buffer.length;\n\n                if (!options) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                if (Number.isInteger(options.length)) {\n                  length = options.length;\n                } else {\n                  length -= options.offset || 0;\n                }\n\n                if (!options.position) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                skipBytes = options.position - this.position;\n\n                if (!(skipBytes > 0)) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                _context2.next = 9;\n                return this.ignore(skipBytes);\n\n              case 9:\n                return _context2.abrupt(\"return\", this.readBuffer(buffer, options));\n\n              case 12:\n                if (!(skipBytes < 0)) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\n\n              case 14:\n                if (options.offset) {\n                  offset = options.offset;\n                }\n\n              case 15:\n                if (!(length === 0)) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", 0);\n\n              case 17:\n                _context2.next = 19;\n                return this.streamReader.read(buffer, offset, length);\n\n              case 19:\n                bytesRead = _context2.sent;\n                this.position += bytesRead;\n\n                if (!((!options || !options.mayBeLess) && bytesRead < length)) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                throw new peek_readable_1.EndOfStreamError();\n\n              case 23:\n                return _context2.abrupt(\"return\", bytesRead);\n\n              case 24:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function readBuffer(_x, _x2) {\n        return _readBuffer.apply(this, arguments);\n      }\n\n      return readBuffer;\n    }()\n    /**\n     * Peek (read ahead) buffer from tokenizer\n     * @param buffer - Target buffer to write the data read to\n     * @param options - Read behaviour options\n     * @returns Promise with number of bytes peeked\n     */\n\n  }, {\n    key: \"peekBuffer\",\n    value: function () {\n      var _peekBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(buffer, options) {\n        var offset, bytesRead, length, skipBytes, skipBuffer;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // const _offset = position ? position : this.position;\n                // debug(`peek ${_offset}...${_offset + length - 1}`);\n                offset = 0;\n                length = buffer.length;\n\n                if (!options) {\n                  _context3.next = 18;\n                  break;\n                }\n\n                if (options.offset) {\n                  offset = options.offset;\n                }\n\n                if (Number.isInteger(options.length)) {\n                  length = options.length;\n                } else {\n                  length -= options.offset || 0;\n                }\n\n                if (!options.position) {\n                  _context3.next = 18;\n                  break;\n                }\n\n                skipBytes = options.position - this.position;\n\n                if (!(skipBytes > 0)) {\n                  _context3.next = 16;\n                  break;\n                }\n\n                skipBuffer = Buffer.alloc(length + skipBytes);\n                _context3.next = 11;\n                return this.peekBuffer(skipBuffer, {\n                  mayBeLess: options.mayBeLess\n                });\n\n              case 11:\n                bytesRead = _context3.sent;\n                skipBuffer.copy(buffer, offset, skipBytes);\n                return _context3.abrupt(\"return\", bytesRead - skipBytes);\n\n              case 16:\n                if (!(skipBytes < 0)) {\n                  _context3.next = 18;\n                  break;\n                }\n\n                throw new Error('Cannot peek from a negative offset in a stream');\n\n              case 18:\n                _context3.prev = 18;\n                _context3.next = 21;\n                return this.streamReader.peek(buffer, offset, length);\n\n              case 21:\n                bytesRead = _context3.sent;\n                _context3.next = 29;\n                break;\n\n              case 24:\n                _context3.prev = 24;\n                _context3.t0 = _context3[\"catch\"](18);\n\n                if (!(options && options.mayBeLess && _context3.t0 instanceof peek_readable_1.EndOfStreamError)) {\n                  _context3.next = 28;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", 0);\n\n              case 28:\n                throw _context3.t0;\n\n              case 29:\n                if (!((!options || !options.mayBeLess) && bytesRead < length)) {\n                  _context3.next = 31;\n                  break;\n                }\n\n                throw new peek_readable_1.EndOfStreamError();\n\n              case 31:\n                return _context3.abrupt(\"return\", bytesRead);\n\n              case 32:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[18, 24]]);\n      }));\n\n      function peekBuffer(_x3, _x4) {\n        return _peekBuffer.apply(this, arguments);\n      }\n\n      return peekBuffer;\n    }()\n  }, {\n    key: \"ignore\",\n    value: function () {\n      var _ignore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(length) {\n        var bufSize, buf, totBytesRead, remaining, bytesRead;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                // debug(`ignore ${this.position}...${this.position + length - 1}`);\n                bufSize = Math.min(maxBufferSize, length);\n                buf = Buffer.alloc(bufSize);\n                totBytesRead = 0;\n\n              case 3:\n                if (!(totBytesRead < length)) {\n                  _context4.next = 13;\n                  break;\n                }\n\n                remaining = length - totBytesRead;\n                _context4.next = 7;\n                return this.readBuffer(buf, {\n                  length: Math.min(bufSize, remaining)\n                });\n\n              case 7:\n                bytesRead = _context4.sent;\n\n                if (!(bytesRead < 0)) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", bytesRead);\n\n              case 10:\n                totBytesRead += bytesRead;\n                _context4.next = 3;\n                break;\n\n              case 13:\n                return _context4.abrupt(\"return\", totBytesRead);\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function ignore(_x5) {\n        return _ignore.apply(this, arguments);\n      }\n\n      return ignore;\n    }()\n  }]);\n\n  return ReadStreamTokenizer;\n}(AbstractTokenizer_1.AbstractTokenizer);\n\nexports.ReadStreamTokenizer = ReadStreamTokenizer;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/strtok3/lib/ReadStreamTokenizer.js"],"names":["Object","defineProperty","exports","value","ReadStreamTokenizer","AbstractTokenizer_1","require","peek_readable_1","maxBufferSize","stream","fileInfo","streamReader","StreamReader","buffer","options","offset","length","Number","isInteger","position","skipBytes","ignore","readBuffer","Error","read","bytesRead","mayBeLess","EndOfStreamError","skipBuffer","Buffer","alloc","peekBuffer","copy","peek","bufSize","Math","min","buf","totBytesRead","remaining","AbstractTokenizer"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadStreamTokenizer = void 0;\nconst AbstractTokenizer_1 = require(\"./AbstractTokenizer\");\nconst peek_readable_1 = require(\"peek-readable\");\n// import * as _debug from 'debug';\n// const debug = _debug('strtok3:ReadStreamTokenizer');\nconst maxBufferSize = 256000;\nclass ReadStreamTokenizer extends AbstractTokenizer_1.AbstractTokenizer {\n    constructor(stream, fileInfo) {\n        super(fileInfo);\n        this.streamReader = new peek_readable_1.StreamReader(stream);\n    }\n    /**\n     * Get file information, an HTTP-client may implement this doing a HEAD request\n     * @return Promise with file information\n     */\n    async getFileInfo() {\n        return this.fileInfo;\n    }\n    /**\n     * Read buffer from tokenizer\n     * @param buffer - Target buffer to fill with data read from the tokenizer-stream\n     * @param options - Read behaviour options\n     * @returns Promise with number of bytes read\n     */\n    async readBuffer(buffer, options) {\n        // const _offset = position ? position : this.position;\n        // debug(`readBuffer ${_offset}...${_offset + length - 1}`);\n        let offset = 0;\n        let length = buffer.length;\n        if (options) {\n            if (Number.isInteger(options.length)) {\n                length = options.length;\n            }\n            else {\n                length -= options.offset || 0;\n            }\n            if (options.position) {\n                const skipBytes = options.position - this.position;\n                if (skipBytes > 0) {\n                    await this.ignore(skipBytes);\n                    return this.readBuffer(buffer, options);\n                }\n                else if (skipBytes < 0) {\n                    throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\n                }\n            }\n            if (options.offset) {\n                offset = options.offset;\n            }\n        }\n        if (length === 0) {\n            return 0;\n        }\n        const bytesRead = await this.streamReader.read(buffer, offset, length);\n        this.position += bytesRead;\n        if ((!options || !options.mayBeLess) && bytesRead < length) {\n            throw new peek_readable_1.EndOfStreamError();\n        }\n        return bytesRead;\n    }\n    /**\n     * Peek (read ahead) buffer from tokenizer\n     * @param buffer - Target buffer to write the data read to\n     * @param options - Read behaviour options\n     * @returns Promise with number of bytes peeked\n     */\n    async peekBuffer(buffer, options) {\n        // const _offset = position ? position : this.position;\n        // debug(`peek ${_offset}...${_offset + length - 1}`);\n        let offset = 0;\n        let bytesRead;\n        let length = buffer.length;\n        if (options) {\n            if (options.offset) {\n                offset = options.offset;\n            }\n            if (Number.isInteger(options.length)) {\n                length = options.length;\n            }\n            else {\n                length -= options.offset || 0;\n            }\n            if (options.position) {\n                const skipBytes = options.position - this.position;\n                if (skipBytes > 0) {\n                    const skipBuffer = Buffer.alloc(length + skipBytes);\n                    bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: options.mayBeLess });\n                    skipBuffer.copy(buffer, offset, skipBytes);\n                    return bytesRead - skipBytes;\n                }\n                else if (skipBytes < 0) {\n                    throw new Error('Cannot peek from a negative offset in a stream');\n                }\n            }\n        }\n        try {\n            bytesRead = await this.streamReader.peek(buffer, offset, length);\n        }\n        catch (err) {\n            if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {\n                return 0;\n            }\n            throw err;\n        }\n        if ((!options || !options.mayBeLess) && bytesRead < length) {\n            throw new peek_readable_1.EndOfStreamError();\n        }\n        return bytesRead;\n    }\n    async ignore(length) {\n        // debug(`ignore ${this.position}...${this.position + length - 1}`);\n        const bufSize = Math.min(maxBufferSize, length);\n        const buf = Buffer.alloc(bufSize);\n        let totBytesRead = 0;\n        while (totBytesRead < length) {\n            const remaining = length - totBytesRead;\n            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });\n            if (bytesRead < 0) {\n                return bytesRead;\n            }\n            totBytesRead += bytesRead;\n        }\n        return totBytesRead;\n    }\n}\nexports.ReadStreamTokenizer = ReadStreamTokenizer;\n"]},"metadata":{},"sourceType":"script"}