{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MatroskaParser = void 0;\n\nconst Token = require(\"token-types\");\n\nconst _debug = require(\"debug\");\n\nconst BasicParser_1 = require(\"../common/BasicParser\");\n\nconst types_1 = require(\"./types\");\n\nconst matroskaDtd = require(\"./MatroskaDtd\");\n\nconst debug = _debug('music-metadata:parser:matroska');\n/**\r\n * Extensible Binary Meta Language (EBML) parser\r\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\r\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\r\n *\r\n * WEBM VP8 AUDIO FILE\r\n */\n\n\nclass MatroskaParser extends BasicParser_1.BasicParser {\n  constructor() {\n    super();\n    this.padding = 0;\n    this.parserMap = new Map();\n    this.ebmlMaxIDLength = 4;\n    this.ebmlMaxSizeLength = 8;\n    this.parserMap.set(types_1.DataType.uint, e => this.readUint(e));\n    this.parserMap.set(types_1.DataType.string, e => this.readString(e));\n    this.parserMap.set(types_1.DataType.binary, e => this.readBuffer(e));\n    this.parserMap.set(types_1.DataType.uid, async e => (await this.readUint(e)) === 1);\n    this.parserMap.set(types_1.DataType.bool, e => this.readFlag(e));\n    this.parserMap.set(types_1.DataType.float, e => this.readFloat(e));\n  }\n  /**\r\n   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\r\n   * @param {INativeMetadataCollector} metadata Output\r\n   * @param {ITokenizer} tokenizer Input\r\n   * @param {IOptions} options Parsing options\r\n   */\n\n\n  init(metadata, tokenizer, options) {\n    super.init(metadata, tokenizer, options);\n    return this;\n  }\n\n  async parse() {\n    const matroska = await this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);\n    this.metadata.setFormat('container', `EBML/${matroska.ebml.docType}`);\n\n    if (matroska.segment) {\n      const info = matroska.segment.info;\n\n      if (info) {\n        const timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;\n        const duration = info.duration * timecodeScale / 1000000000;\n        this.addTag('segment:title', info.title);\n        this.metadata.setFormat('duration', duration);\n      }\n\n      const audioTracks = matroska.segment.tracks;\n\n      if (audioTracks && audioTracks.entries) {\n        audioTracks.entries.forEach(entry => {\n          const stream = {\n            codecName: entry.codecID.replace('A_', '').replace('V_', ''),\n            codecSettings: entry.codecSettings,\n            flagDefault: entry.flagDefault,\n            flagLacing: entry.flagLacing,\n            flagEnabled: entry.flagEnabled,\n            language: entry.language,\n            name: entry.name,\n            type: entry.trackType,\n            audio: entry.audio,\n            video: entry.video\n          };\n          this.metadata.addStreamInfo(stream);\n        });\n        const audioTrack = audioTracks.entries.filter(entry => {\n          return entry.trackType === types_1.TrackType.audio.valueOf();\n        }).reduce((acc, cur) => {\n          if (!acc) {\n            return cur;\n          }\n\n          if (!acc.flagDefault && cur.flagDefault) {\n            return cur;\n          }\n\n          if (cur.trackNumber && cur.trackNumber < acc.trackNumber) {\n            return cur;\n          }\n\n          return acc;\n        }, null);\n\n        if (audioTrack) {\n          this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));\n          this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);\n          this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);\n        }\n\n        if (matroska.segment.tags) {\n          matroska.segment.tags.tag.forEach(tag => {\n            const target = tag.target;\n            const targetType = target.targetTypeValue ? types_1.TargetType[target.targetTypeValue] : target.targetType ? target.targetType : types_1.TargetType.album;\n            tag.simpleTags.forEach(simpleTag => {\n              const value = simpleTag.string ? simpleTag.string : simpleTag.binary;\n              this.addTag(`${targetType}:${simpleTag.name}`, value);\n            });\n          });\n        }\n\n        if (matroska.segment.attachments) {\n          matroska.segment.attachments.attachedFiles.filter(file => file.mimeType.startsWith('image/')).map(file => {\n            return {\n              data: file.data,\n              format: file.mimeType,\n              description: file.description,\n              name: file.name\n            };\n          }).forEach(picture => {\n            this.addTag('picture', picture);\n          });\n        }\n      }\n    }\n  }\n\n  async parseContainer(container, posDone, path) {\n    const tree = {};\n\n    while (this.tokenizer.position < posDone) {\n      let element;\n\n      try {\n        element = await this.readElement();\n      } catch (error) {\n        if (error.message === 'End-Of-Stream') {\n          break;\n        }\n\n        throw error;\n      }\n\n      const type = container[element.id];\n\n      if (type) {\n        debug(`Element: name=${type.name}, container=${!!type.container}`);\n\n        if (type.container) {\n          const res = await this.parseContainer(type.container, element.len >= 0 ? this.tokenizer.position + element.len : -1, path.concat([type.name]));\n\n          if (type.multiple) {\n            if (!tree[type.name]) {\n              tree[type.name] = [];\n            }\n\n            tree[type.name].push(res);\n          } else {\n            tree[type.name] = res;\n          }\n        } else {\n          tree[type.name] = await this.parserMap.get(type.value)(element);\n        }\n      } else {\n        switch (element.id) {\n          case 0xec:\n            // void\n            this.padding += element.len;\n            await this.tokenizer.ignore(element.len);\n            break;\n\n          default:\n            debug(`parseEbml: path=${path.join('/')}, unknown element: id=${element.id.toString(16)}`);\n            this.padding += element.len;\n            await this.tokenizer.ignore(element.len);\n        }\n      }\n    }\n\n    return tree;\n  }\n\n  async readVintData(maxLength) {\n    const msb = await this.tokenizer.peekNumber(Token.UINT8);\n    let mask = 0x80;\n    let oc = 1; // Calculate VINT_WIDTH\n\n    while ((msb & mask) === 0) {\n      if (oc > maxLength) {\n        throw new Error('VINT value exceeding maximum size');\n      }\n\n      ++oc;\n      mask >>= 1;\n    }\n\n    const id = Buffer.alloc(oc);\n    await this.tokenizer.readBuffer(id);\n    return id;\n  }\n\n  async readElement() {\n    const id = await this.readVintData(this.ebmlMaxIDLength);\n    const lenField = await this.readVintData(this.ebmlMaxSizeLength);\n    lenField[0] ^= 0x80 >> lenField.length - 1;\n    const nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer\n\n    return {\n      id: id.readUIntBE(0, id.length),\n      len: lenField.readUIntBE(lenField.length - nrLen, nrLen)\n    };\n  }\n\n  isMaxValue(vintData) {\n    if (vintData.length === this.ebmlMaxSizeLength) {\n      for (let n = 1; n < this.ebmlMaxSizeLength; ++n) {\n        if (vintData[n] !== 0xff) return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  async readFloat(e) {\n    switch (e.len) {\n      case 0:\n        return 0.0;\n\n      case 4:\n        return this.tokenizer.readNumber(Token.Float32_BE);\n\n      case 8:\n        return this.tokenizer.readNumber(Token.Float64_BE);\n\n      case 10:\n        return this.tokenizer.readNumber(Token.Float64_BE);\n\n      default:\n        throw new Error(`Invalid IEEE-754 float length: ${e.len}`);\n    }\n  }\n\n  async readFlag(e) {\n    return (await this.readUint(e)) === 1;\n  }\n\n  async readUint(e) {\n    const buf = await this.readBuffer(e);\n    const nrLen = Math.min(6, e.len); // JavaScript can max read 6 bytes integer\n\n    return buf.readUIntBE(e.len - nrLen, nrLen);\n  }\n\n  async readString(e) {\n    return this.tokenizer.readToken(new Token.StringType(e.len, 'utf-8'));\n  }\n\n  async readBuffer(e) {\n    const buf = Buffer.alloc(e.len);\n    await this.tokenizer.readBuffer(buf);\n    return buf;\n  }\n\n  addTag(tagId, value) {\n    this.metadata.addTag('matroska', tagId, value);\n  }\n\n}\n\nexports.MatroskaParser = MatroskaParser;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/matroska/MatroskaParser.js"],"names":["Object","defineProperty","exports","value","MatroskaParser","Token","require","_debug","BasicParser_1","types_1","matroskaDtd","debug","BasicParser","constructor","padding","parserMap","Map","ebmlMaxIDLength","ebmlMaxSizeLength","set","DataType","uint","e","readUint","string","readString","binary","readBuffer","uid","bool","readFlag","float","readFloat","init","metadata","tokenizer","options","parse","matroska","parseContainer","elements","fileInfo","size","setFormat","ebml","docType","segment","info","timecodeScale","duration","addTag","title","audioTracks","tracks","entries","forEach","entry","stream","codecName","codecID","replace","codecSettings","flagDefault","flagLacing","flagEnabled","language","name","type","trackType","audio","video","addStreamInfo","audioTrack","filter","TrackType","valueOf","reduce","acc","cur","trackNumber","samplingFrequency","channels","tags","tag","target","targetType","targetTypeValue","TargetType","album","simpleTags","simpleTag","attachments","attachedFiles","file","mimeType","startsWith","map","data","format","description","picture","container","posDone","path","tree","position","element","readElement","error","message","id","res","len","concat","multiple","push","get","ignore","join","toString","readVintData","maxLength","msb","peekNumber","UINT8","mask","oc","Error","Buffer","alloc","lenField","length","nrLen","Math","min","readUIntBE","isMaxValue","vintData","n","readNumber","Float32_BE","Float64_BE","buf","readToken","StringType","tagId"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MatroskaParser = void 0;\r\nconst Token = require(\"token-types\");\r\nconst _debug = require(\"debug\");\r\nconst BasicParser_1 = require(\"../common/BasicParser\");\r\nconst types_1 = require(\"./types\");\r\nconst matroskaDtd = require(\"./MatroskaDtd\");\r\nconst debug = _debug('music-metadata:parser:matroska');\r\n/**\r\n * Extensible Binary Meta Language (EBML) parser\r\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\r\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\r\n *\r\n * WEBM VP8 AUDIO FILE\r\n */\r\nclass MatroskaParser extends BasicParser_1.BasicParser {\r\n    constructor() {\r\n        super();\r\n        this.padding = 0;\r\n        this.parserMap = new Map();\r\n        this.ebmlMaxIDLength = 4;\r\n        this.ebmlMaxSizeLength = 8;\r\n        this.parserMap.set(types_1.DataType.uint, e => this.readUint(e));\r\n        this.parserMap.set(types_1.DataType.string, e => this.readString(e));\r\n        this.parserMap.set(types_1.DataType.binary, e => this.readBuffer(e));\r\n        this.parserMap.set(types_1.DataType.uid, async (e) => await this.readUint(e) === 1);\r\n        this.parserMap.set(types_1.DataType.bool, e => this.readFlag(e));\r\n        this.parserMap.set(types_1.DataType.float, e => this.readFloat(e));\r\n    }\r\n    /**\r\n     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\r\n     * @param {INativeMetadataCollector} metadata Output\r\n     * @param {ITokenizer} tokenizer Input\r\n     * @param {IOptions} options Parsing options\r\n     */\r\n    init(metadata, tokenizer, options) {\r\n        super.init(metadata, tokenizer, options);\r\n        return this;\r\n    }\r\n    async parse() {\r\n        const matroska = await this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);\r\n        this.metadata.setFormat('container', `EBML/${matroska.ebml.docType}`);\r\n        if (matroska.segment) {\r\n            const info = matroska.segment.info;\r\n            if (info) {\r\n                const timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;\r\n                const duration = info.duration * timecodeScale / 1000000000;\r\n                this.addTag('segment:title', info.title);\r\n                this.metadata.setFormat('duration', duration);\r\n            }\r\n            const audioTracks = matroska.segment.tracks;\r\n            if (audioTracks && audioTracks.entries) {\r\n                audioTracks.entries.forEach(entry => {\r\n                    const stream = {\r\n                        codecName: entry.codecID.replace('A_', '').replace('V_', ''),\r\n                        codecSettings: entry.codecSettings,\r\n                        flagDefault: entry.flagDefault,\r\n                        flagLacing: entry.flagLacing,\r\n                        flagEnabled: entry.flagEnabled,\r\n                        language: entry.language,\r\n                        name: entry.name,\r\n                        type: entry.trackType,\r\n                        audio: entry.audio,\r\n                        video: entry.video\r\n                    };\r\n                    this.metadata.addStreamInfo(stream);\r\n                });\r\n                const audioTrack = audioTracks.entries\r\n                    .filter(entry => {\r\n                    return entry.trackType === types_1.TrackType.audio.valueOf();\r\n                })\r\n                    .reduce((acc, cur) => {\r\n                    if (!acc) {\r\n                        return cur;\r\n                    }\r\n                    if (!acc.flagDefault && cur.flagDefault) {\r\n                        return cur;\r\n                    }\r\n                    if (cur.trackNumber && cur.trackNumber < acc.trackNumber) {\r\n                        return cur;\r\n                    }\r\n                    return acc;\r\n                }, null);\r\n                if (audioTrack) {\r\n                    this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));\r\n                    this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);\r\n                    this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);\r\n                }\r\n                if (matroska.segment.tags) {\r\n                    matroska.segment.tags.tag.forEach(tag => {\r\n                        const target = tag.target;\r\n                        const targetType = target.targetTypeValue ? types_1.TargetType[target.targetTypeValue] : (target.targetType ? target.targetType : types_1.TargetType.album);\r\n                        tag.simpleTags.forEach(simpleTag => {\r\n                            const value = simpleTag.string ? simpleTag.string : simpleTag.binary;\r\n                            this.addTag(`${targetType}:${simpleTag.name}`, value);\r\n                        });\r\n                    });\r\n                }\r\n                if (matroska.segment.attachments) {\r\n                    matroska.segment.attachments.attachedFiles\r\n                        .filter(file => file.mimeType.startsWith('image/'))\r\n                        .map(file => {\r\n                        return {\r\n                            data: file.data,\r\n                            format: file.mimeType,\r\n                            description: file.description,\r\n                            name: file.name\r\n                        };\r\n                    }).forEach(picture => {\r\n                        this.addTag('picture', picture);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    async parseContainer(container, posDone, path) {\r\n        const tree = {};\r\n        while (this.tokenizer.position < posDone) {\r\n            let element;\r\n            try {\r\n                element = await this.readElement();\r\n            }\r\n            catch (error) {\r\n                if (error.message === 'End-Of-Stream') {\r\n                    break;\r\n                }\r\n                throw error;\r\n            }\r\n            const type = container[element.id];\r\n            if (type) {\r\n                debug(`Element: name=${type.name}, container=${!!type.container}`);\r\n                if (type.container) {\r\n                    const res = await this.parseContainer(type.container, element.len >= 0 ? this.tokenizer.position + element.len : -1, path.concat([type.name]));\r\n                    if (type.multiple) {\r\n                        if (!tree[type.name]) {\r\n                            tree[type.name] = [];\r\n                        }\r\n                        tree[type.name].push(res);\r\n                    }\r\n                    else {\r\n                        tree[type.name] = res;\r\n                    }\r\n                }\r\n                else {\r\n                    tree[type.name] = await this.parserMap.get(type.value)(element);\r\n                }\r\n            }\r\n            else {\r\n                switch (element.id) {\r\n                    case 0xec: // void\r\n                        this.padding += element.len;\r\n                        await this.tokenizer.ignore(element.len);\r\n                        break;\r\n                    default:\r\n                        debug(`parseEbml: path=${path.join('/')}, unknown element: id=${element.id.toString(16)}`);\r\n                        this.padding += element.len;\r\n                        await this.tokenizer.ignore(element.len);\r\n                }\r\n            }\r\n        }\r\n        return tree;\r\n    }\r\n    async readVintData(maxLength) {\r\n        const msb = await this.tokenizer.peekNumber(Token.UINT8);\r\n        let mask = 0x80;\r\n        let oc = 1;\r\n        // Calculate VINT_WIDTH\r\n        while ((msb & mask) === 0) {\r\n            if (oc > maxLength) {\r\n                throw new Error('VINT value exceeding maximum size');\r\n            }\r\n            ++oc;\r\n            mask >>= 1;\r\n        }\r\n        const id = Buffer.alloc(oc);\r\n        await this.tokenizer.readBuffer(id);\r\n        return id;\r\n    }\r\n    async readElement() {\r\n        const id = await this.readVintData(this.ebmlMaxIDLength);\r\n        const lenField = await this.readVintData(this.ebmlMaxSizeLength);\r\n        lenField[0] ^= 0x80 >> (lenField.length - 1);\r\n        const nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer\r\n        return {\r\n            id: id.readUIntBE(0, id.length),\r\n            len: lenField.readUIntBE(lenField.length - nrLen, nrLen)\r\n        };\r\n    }\r\n    isMaxValue(vintData) {\r\n        if (vintData.length === this.ebmlMaxSizeLength) {\r\n            for (let n = 1; n < this.ebmlMaxSizeLength; ++n) {\r\n                if (vintData[n] !== 0xff)\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    async readFloat(e) {\r\n        switch (e.len) {\r\n            case 0:\r\n                return 0.0;\r\n            case 4:\r\n                return this.tokenizer.readNumber(Token.Float32_BE);\r\n            case 8:\r\n                return this.tokenizer.readNumber(Token.Float64_BE);\r\n            case 10:\r\n                return this.tokenizer.readNumber(Token.Float64_BE);\r\n            default:\r\n                throw new Error(`Invalid IEEE-754 float length: ${e.len}`);\r\n        }\r\n    }\r\n    async readFlag(e) {\r\n        return (await this.readUint(e)) === 1;\r\n    }\r\n    async readUint(e) {\r\n        const buf = await this.readBuffer(e);\r\n        const nrLen = Math.min(6, e.len); // JavaScript can max read 6 bytes integer\r\n        return buf.readUIntBE(e.len - nrLen, nrLen);\r\n    }\r\n    async readString(e) {\r\n        return this.tokenizer.readToken(new Token.StringType(e.len, 'utf-8'));\r\n    }\r\n    async readBuffer(e) {\r\n        const buf = Buffer.alloc(e.len);\r\n        await this.tokenizer.readBuffer(buf);\r\n        return buf;\r\n    }\r\n    addTag(tagId, value) {\r\n        this.metadata.addTag('matroska', tagId, value);\r\n    }\r\n}\r\nexports.MatroskaParser = MatroskaParser;\r\n"]},"metadata":{},"sourceType":"script"}