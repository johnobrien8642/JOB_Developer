{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toRatio = exports.dbToRatio = exports.ratioToDb = void 0;\n\nconst Windows1292Decoder_1 = require(\"./Windows1292Decoder\");\n\nclass Util {\n  /**\r\n   *\r\n   * @param buffer\r\n   * @param start\r\n   * @param end\r\n   * @param encoding // ToDo: ts.enum\r\n   * @return {number}\r\n   */\n  static findZero(buffer, start, end, encoding) {\n    let i = start;\n\n    if (encoding === 'utf16') {\n      while (buffer[i] !== 0 || buffer[i + 1] !== 0) {\n        if (i >= end) return end;\n        i += 2;\n      }\n\n      return i;\n    } else {\n      while (buffer[i] !== 0) {\n        if (i >= end) return end;\n        i++;\n      }\n\n      return i;\n    }\n  }\n\n  static trimRightNull(x) {\n    const pos0 = x.indexOf('\\0');\n    return pos0 === -1 ? x : x.substr(0, pos0);\n  }\n\n  static swapBytes(buffer) {\n    const l = buffer.length;\n    if ((l & 1) !== 0) throw new Error('Buffer length must be even');\n\n    for (let i = 0; i < l; i += 2) {\n      const a = buffer[i];\n      buffer[i] = buffer[i + 1];\n      buffer[i + 1] = a;\n    }\n\n    return buffer;\n  }\n\n  static readUTF16String(buffer) {\n    let offset = 0;\n\n    if (buffer[0] === 0xFE && buffer[1] === 0xFF) {\n      // big endian\n      buffer = Util.swapBytes(buffer);\n      offset = 2;\n    } else if (buffer[0] === 0xFF && buffer[1] === 0xFE) {\n      // little endian\n      offset = 2;\n    }\n\n    return buffer.toString('ucs2', offset);\n  }\n  /**\r\n   *\r\n   * @param buffer Decoder input data\r\n   * @param encoding 'utf16le' | 'utf16' | 'utf8' | 'iso-8859-1'\r\n   * @return {string}\r\n   */\n\n\n  static decodeString(buffer, encoding) {\n    // annoying workaround for a double BOM issue\n    // https://github.com/leetreveil/musicmetadata/issues/84\n    if (buffer[0] === 0xFF && buffer[1] === 0xFE && buffer[2] === 0xFE && buffer[3] === 0xFF) {\n      buffer = buffer.slice(2);\n    }\n\n    if (encoding === 'utf16le' || encoding === 'utf16') {\n      return Util.readUTF16String(buffer);\n    } else if (encoding === 'utf8') {\n      return buffer.toString('utf8');\n    } else if (encoding === 'iso-8859-1') {\n      return Windows1292Decoder_1.Windows1292Decoder.decode(buffer);\n    }\n\n    throw Error(encoding + ' encoding is not supported!');\n  }\n\n  static stripNulls(str) {\n    str = str.replace(/^\\x00+/g, '');\n    str = str.replace(/\\x00+$/g, '');\n    return str;\n  }\n  /**\r\n   * Read bit-aligned number start from buffer\r\n   * Total offset in bits = byteOffset * 8 + bitOffset\r\n   * @param buf Byte buffer\r\n   * @param byteOffset Starting offset in bytes\r\n   * @param bitOffset Starting offset in bits: 0 = lsb\r\n   * @param len Length of number in bits\r\n   * @return {number} decoded bit aligned number\r\n   */\n\n\n  static getBitAllignedNumber(buf, byteOffset, bitOffset, len) {\n    const byteOff = byteOffset + ~~(bitOffset / 8);\n    const bitOff = bitOffset % 8;\n    let value = buf[byteOff];\n    value &= 0xff >> bitOff;\n    const bitsRead = 8 - bitOff;\n    const bitsLeft = len - bitsRead;\n\n    if (bitsLeft < 0) {\n      value >>= 8 - bitOff - len;\n    } else if (bitsLeft > 0) {\n      value <<= bitsLeft;\n      value |= Util.getBitAllignedNumber(buf, byteOffset, bitOffset + bitsRead, bitsLeft);\n    }\n\n    return value;\n  }\n  /**\r\n   * Read bit-aligned number start from buffer\r\n   * Total offset in bits = byteOffset * 8 + bitOffset\r\n   * @param buf Byte buffer\r\n   * @param byteOffset Starting offset in bytes\r\n   * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is least significant bit\r\n   * @return {number} decoded bit aligned number\r\n   */\n\n\n  static isBitSet(buf, byteOffset, bitOffset) {\n    return Util.getBitAllignedNumber(buf, byteOffset, bitOffset, 1) === 1;\n  }\n\n  static a2hex(str) {\n    const arr = [];\n\n    for (let i = 0, l = str.length; i < l; i++) {\n      const hex = Number(str.charCodeAt(i)).toString(16);\n      arr.push(hex.length === 1 ? '0' + hex : hex);\n    }\n\n    return arr.join(' ');\n  }\n\n}\n\nexports.default = Util;\nUtil.strtokBITSET = {\n  get: (buf, off, bit) => {\n    return (buf[off] & 1 << bit) !== 0;\n  },\n  len: 1\n};\n/**\r\n * Convert power ratio to DB\r\n * ratio: [0..1]\r\n */\n\nfunction ratioToDb(ratio) {\n  return 10 * Math.log10(ratio);\n}\n\nexports.ratioToDb = ratioToDb;\n/**\r\n * Convert dB to ratio\r\n * db Decibels\r\n */\n\nfunction dbToRatio(dB) {\n  return Math.pow(10, dB / 10);\n}\n\nexports.dbToRatio = dbToRatio;\n/**\r\n * Convert replay gain to ratio and Decibel\r\n * @param value string holding a ratio like '0.034' or '-7.54 dB'\r\n */\n\nfunction toRatio(value) {\n  const ps = value.split(' ').map(p => p.trim().toLowerCase()); // @ts-ignore\n\n  if (ps.length >= 1) {\n    const v = parseFloat(ps[0]);\n\n    if (ps.length === 2 && ps[1] === 'db') {\n      return {\n        dB: v,\n        ratio: dbToRatio(v)\n      };\n    } else {\n      return {\n        dB: ratioToDb(v),\n        ratio: v\n      };\n    }\n  }\n}\n\nexports.toRatio = toRatio;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/JOB_Developer/client/node_modules/music-metadata/lib/common/Util.js"],"names":["Object","defineProperty","exports","value","toRatio","dbToRatio","ratioToDb","Windows1292Decoder_1","require","Util","findZero","buffer","start","end","encoding","i","trimRightNull","x","pos0","indexOf","substr","swapBytes","l","length","Error","a","readUTF16String","offset","toString","decodeString","slice","Windows1292Decoder","decode","stripNulls","str","replace","getBitAllignedNumber","buf","byteOffset","bitOffset","len","byteOff","bitOff","bitsRead","bitsLeft","isBitSet","a2hex","arr","hex","Number","charCodeAt","push","join","default","strtokBITSET","get","off","bit","ratio","Math","log10","dB","pow","ps","split","map","p","trim","toLowerCase","v","parseFloat"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.toRatio = exports.dbToRatio = exports.ratioToDb = void 0;\r\nconst Windows1292Decoder_1 = require(\"./Windows1292Decoder\");\r\nclass Util {\r\n    /**\r\n     *\r\n     * @param buffer\r\n     * @param start\r\n     * @param end\r\n     * @param encoding // ToDo: ts.enum\r\n     * @return {number}\r\n     */\r\n    static findZero(buffer, start, end, encoding) {\r\n        let i = start;\r\n        if (encoding === 'utf16') {\r\n            while (buffer[i] !== 0 || buffer[i + 1] !== 0) {\r\n                if (i >= end)\r\n                    return end;\r\n                i += 2;\r\n            }\r\n            return i;\r\n        }\r\n        else {\r\n            while (buffer[i] !== 0) {\r\n                if (i >= end)\r\n                    return end;\r\n                i++;\r\n            }\r\n            return i;\r\n        }\r\n    }\r\n    static trimRightNull(x) {\r\n        const pos0 = x.indexOf('\\0');\r\n        return pos0 === -1 ? x : x.substr(0, pos0);\r\n    }\r\n    static swapBytes(buffer) {\r\n        const l = buffer.length;\r\n        if ((l & 1) !== 0)\r\n            throw new Error('Buffer length must be even');\r\n        for (let i = 0; i < l; i += 2) {\r\n            const a = buffer[i];\r\n            buffer[i] = buffer[i + 1];\r\n            buffer[i + 1] = a;\r\n        }\r\n        return buffer;\r\n    }\r\n    static readUTF16String(buffer) {\r\n        let offset = 0;\r\n        if (buffer[0] === 0xFE && buffer[1] === 0xFF) { // big endian\r\n            buffer = Util.swapBytes(buffer);\r\n            offset = 2;\r\n        }\r\n        else if (buffer[0] === 0xFF && buffer[1] === 0xFE) { // little endian\r\n            offset = 2;\r\n        }\r\n        return buffer.toString('ucs2', offset);\r\n    }\r\n    /**\r\n     *\r\n     * @param buffer Decoder input data\r\n     * @param encoding 'utf16le' | 'utf16' | 'utf8' | 'iso-8859-1'\r\n     * @return {string}\r\n     */\r\n    static decodeString(buffer, encoding) {\r\n        // annoying workaround for a double BOM issue\r\n        // https://github.com/leetreveil/musicmetadata/issues/84\r\n        if (buffer[0] === 0xFF && buffer[1] === 0xFE && buffer[2] === 0xFE && buffer[3] === 0xFF) {\r\n            buffer = buffer.slice(2);\r\n        }\r\n        if (encoding === 'utf16le' || encoding === 'utf16') {\r\n            return Util.readUTF16String(buffer);\r\n        }\r\n        else if (encoding === 'utf8') {\r\n            return buffer.toString('utf8');\r\n        }\r\n        else if (encoding === 'iso-8859-1') {\r\n            return Windows1292Decoder_1.Windows1292Decoder.decode(buffer);\r\n        }\r\n        throw Error(encoding + ' encoding is not supported!');\r\n    }\r\n    static stripNulls(str) {\r\n        str = str.replace(/^\\x00+/g, '');\r\n        str = str.replace(/\\x00+$/g, '');\r\n        return str;\r\n    }\r\n    /**\r\n     * Read bit-aligned number start from buffer\r\n     * Total offset in bits = byteOffset * 8 + bitOffset\r\n     * @param buf Byte buffer\r\n     * @param byteOffset Starting offset in bytes\r\n     * @param bitOffset Starting offset in bits: 0 = lsb\r\n     * @param len Length of number in bits\r\n     * @return {number} decoded bit aligned number\r\n     */\r\n    static getBitAllignedNumber(buf, byteOffset, bitOffset, len) {\r\n        const byteOff = byteOffset + ~~(bitOffset / 8);\r\n        const bitOff = bitOffset % 8;\r\n        let value = buf[byteOff];\r\n        value &= 0xff >> bitOff;\r\n        const bitsRead = 8 - bitOff;\r\n        const bitsLeft = len - bitsRead;\r\n        if (bitsLeft < 0) {\r\n            value >>= (8 - bitOff - len);\r\n        }\r\n        else if (bitsLeft > 0) {\r\n            value <<= bitsLeft;\r\n            value |= Util.getBitAllignedNumber(buf, byteOffset, bitOffset + bitsRead, bitsLeft);\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * Read bit-aligned number start from buffer\r\n     * Total offset in bits = byteOffset * 8 + bitOffset\r\n     * @param buf Byte buffer\r\n     * @param byteOffset Starting offset in bytes\r\n     * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is least significant bit\r\n     * @return {number} decoded bit aligned number\r\n     */\r\n    static isBitSet(buf, byteOffset, bitOffset) {\r\n        return Util.getBitAllignedNumber(buf, byteOffset, bitOffset, 1) === 1;\r\n    }\r\n    static a2hex(str) {\r\n        const arr = [];\r\n        for (let i = 0, l = str.length; i < l; i++) {\r\n            const hex = Number(str.charCodeAt(i)).toString(16);\r\n            arr.push(hex.length === 1 ? '0' + hex : hex);\r\n        }\r\n        return arr.join(' ');\r\n    }\r\n}\r\nexports.default = Util;\r\nUtil.strtokBITSET = {\r\n    get: (buf, off, bit) => {\r\n        return (buf[off] & (1 << bit)) !== 0;\r\n    },\r\n    len: 1\r\n};\r\n/**\r\n * Convert power ratio to DB\r\n * ratio: [0..1]\r\n */\r\nfunction ratioToDb(ratio) {\r\n    return 10 * Math.log10(ratio);\r\n}\r\nexports.ratioToDb = ratioToDb;\r\n/**\r\n * Convert dB to ratio\r\n * db Decibels\r\n */\r\nfunction dbToRatio(dB) {\r\n    return Math.pow(10, dB / 10);\r\n}\r\nexports.dbToRatio = dbToRatio;\r\n/**\r\n * Convert replay gain to ratio and Decibel\r\n * @param value string holding a ratio like '0.034' or '-7.54 dB'\r\n */\r\nfunction toRatio(value) {\r\n    const ps = value.split(' ').map(p => p.trim().toLowerCase());\r\n    // @ts-ignore\r\n    if (ps.length >= 1) {\r\n        const v = parseFloat(ps[0]);\r\n        if (ps.length === 2 && ps[1] === 'db') {\r\n            return {\r\n                dB: v,\r\n                ratio: dbToRatio(v)\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                dB: ratioToDb(v),\r\n                ratio: v\r\n            };\r\n        }\r\n    }\r\n}\r\nexports.toRatio = toRatio;\r\n"]},"metadata":{},"sourceType":"script"}