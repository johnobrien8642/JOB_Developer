{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParserFactory = exports.parseHttpContentType = void 0;\n\nvar FileType = require(\"file-type/core\");\n\nvar ContentType = require(\"content-type\");\n\nvar MimeType = require(\"media-typer\");\n\nvar _debug = require(\"debug\");\n\nvar MetadataCollector_1 = require(\"./common/MetadataCollector\");\n\nvar AiffParser_1 = require(\"./aiff/AiffParser\");\n\nvar APEv2Parser_1 = require(\"./apev2/APEv2Parser\");\n\nvar AsfParser_1 = require(\"./asf/AsfParser\");\n\nvar FlacParser_1 = require(\"./flac/FlacParser\");\n\nvar MP4Parser_1 = require(\"./mp4/MP4Parser\");\n\nvar MpegParser_1 = require(\"./mpeg/MpegParser\");\n\nvar musepack_1 = require(\"./musepack\");\n\nvar OggParser_1 = require(\"./ogg/OggParser\");\n\nvar WaveParser_1 = require(\"./wav/WaveParser\");\n\nvar WavPackParser_1 = require(\"./wavpack/WavPackParser\");\n\nvar DsfParser_1 = require(\"./dsf/DsfParser\");\n\nvar DsdiffParser_1 = require(\"./dsdiff/DsdiffParser\");\n\nvar MatroskaParser_1 = require(\"./matroska/MatroskaParser\");\n\nvar debug = _debug('music-metadata:parser:factory');\n\nfunction parseHttpContentType(contentType) {\n  var type = ContentType.parse(contentType);\n  var mime = MimeType.parse(type.type);\n  return {\n    type: mime.type,\n    subtype: mime.subtype,\n    suffix: mime.suffix,\n    parameters: type.parameters\n  };\n}\n\nexports.parseHttpContentType = parseHttpContentType;\n\nvar ParserFactory = /*#__PURE__*/function () {\n  function ParserFactory() {\n    _classCallCheck(this, ParserFactory);\n  }\n\n  _createClass(ParserFactory, null, [{\n    key: \"parseOnContentType\",\n    value:\n    /**\r\n     * Parse metadata from tokenizer\r\n     * @param tokenizer - Tokenizer\r\n     * @param contentType - MIME-type\r\n     * @param opts - Options\r\n     * @returns Native metadata\r\n     */\n    function () {\n      var _parseOnContentType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tokenizer, opts) {\n        var _yield$tokenizer$file, mimeType, path, url, parserId;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return tokenizer.fileInfo;\n\n              case 2:\n                _yield$tokenizer$file = _context.sent;\n                mimeType = _yield$tokenizer$file.mimeType;\n                path = _yield$tokenizer$file.path;\n                url = _yield$tokenizer$file.url;\n                // Resolve parser based on MIME-type or file extension\n                parserId = ParserFactory.getParserIdForMimeType(mimeType) || ParserFactory.getParserIdForExtension(path) || ParserFactory.getParserIdForExtension(url);\n\n                if (!parserId) {\n                  debug('No parser found for MIME-type / extension: ' + mimeType);\n                }\n\n                return _context.abrupt(\"return\", this.parse(tokenizer, parserId, opts));\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function parseOnContentType(_x, _x2) {\n        return _parseOnContentType.apply(this, arguments);\n      }\n\n      return parseOnContentType;\n    }()\n  }, {\n    key: \"parse\",\n    value: function () {\n      var _parse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(tokenizer, parserId, opts) {\n        var buf, guessedType;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (parserId) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                // Parser could not be determined on MIME-type or extension\n                debug('Guess parser on content...');\n                buf = Buffer.alloc(4100);\n                _context2.next = 5;\n                return tokenizer.peekBuffer(buf, {\n                  mayBeLess: true\n                });\n\n              case 5:\n                if (tokenizer.fileInfo.path) {\n                  parserId = this.getParserIdForExtension(tokenizer.fileInfo.path);\n                }\n\n                if (parserId) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                _context2.next = 9;\n                return FileType.fromBuffer(buf);\n\n              case 9:\n                guessedType = _context2.sent;\n\n                if (guessedType) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                throw new Error('Failed to determine audio format');\n\n              case 12:\n                debug(\"Guessed file type is mime=\".concat(guessedType.mime, \", extension=\").concat(guessedType.ext));\n                parserId = ParserFactory.getParserIdForMimeType(guessedType.mime);\n\n                if (parserId) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                throw new Error('Guessed MIME-type not supported: ' + guessedType.mime);\n\n              case 16:\n                return _context2.abrupt(\"return\", this._parse(tokenizer, parserId, opts));\n\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function parse(_x3, _x4, _x5) {\n        return _parse2.apply(this, arguments);\n      }\n\n      return parse;\n    }()\n    /**\r\n     * @param filePath - Path, filename or extension to audio file\r\n     * @return Parser sub-module name\r\n     */\n\n  }, {\n    key: \"getParserIdForExtension\",\n    value: function getParserIdForExtension(filePath) {\n      if (!filePath) return;\n      var extension = this.getExtension(filePath).toLocaleLowerCase() || filePath;\n\n      switch (extension) {\n        case '.mp2':\n        case '.mp3':\n        case '.m2a':\n        case '.aac':\n          // Assume it is ADTS-container\n          return 'mpeg';\n\n        case '.ape':\n          return 'apev2';\n\n        case '.mp4':\n        case '.m4a':\n        case '.m4b':\n        case '.m4pa':\n        case '.m4v':\n        case '.m4r':\n        case '.3gp':\n          return 'mp4';\n\n        case '.wma':\n        case '.wmv':\n        case '.asf':\n          return 'asf';\n\n        case '.flac':\n          return 'flac';\n\n        case '.ogg':\n        case '.ogv':\n        case '.oga':\n        case '.ogm':\n        case '.ogx':\n        case '.opus': // recommended filename extension for Ogg Opus\n\n        case '.spx':\n          // recommended filename extension for Ogg Speex\n          return 'ogg';\n\n        case '.aif':\n        case '.aiff':\n        case '.aifc':\n          return 'aiff';\n\n        case '.wav':\n          return 'riff';\n\n        case '.wv':\n        case '.wvp':\n          return 'wavpack';\n\n        case '.mpc':\n          return 'musepack';\n\n        case '.dsf':\n          return 'dsf';\n\n        case '.dff':\n          return 'dsdiff';\n\n        case '.mka':\n        case '.mkv':\n        case '.mk3d':\n        case '.mks':\n        case '.webm':\n          return 'matroska';\n      }\n    }\n  }, {\n    key: \"loadParser\",\n    value: function () {\n      var _loadParser = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(moduleName) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.t0 = moduleName;\n                _context3.next = _context3.t0 === 'aiff' ? 3 : _context3.t0 === 'adts' ? 4 : _context3.t0 === 'mpeg' ? 4 : _context3.t0 === 'apev2' ? 5 : _context3.t0 === 'asf' ? 6 : _context3.t0 === 'dsf' ? 7 : _context3.t0 === 'dsdiff' ? 8 : _context3.t0 === 'flac' ? 9 : _context3.t0 === 'mp4' ? 10 : _context3.t0 === 'musepack' ? 11 : _context3.t0 === 'ogg' ? 12 : _context3.t0 === 'riff' ? 13 : _context3.t0 === 'wavpack' ? 14 : _context3.t0 === 'matroska' ? 15 : 16;\n                break;\n\n              case 3:\n                return _context3.abrupt(\"return\", new AiffParser_1.AIFFParser());\n\n              case 4:\n                return _context3.abrupt(\"return\", new MpegParser_1.MpegParser());\n\n              case 5:\n                return _context3.abrupt(\"return\", new APEv2Parser_1.APEv2Parser());\n\n              case 6:\n                return _context3.abrupt(\"return\", new AsfParser_1.AsfParser());\n\n              case 7:\n                return _context3.abrupt(\"return\", new DsfParser_1.DsfParser());\n\n              case 8:\n                return _context3.abrupt(\"return\", new DsdiffParser_1.DsdiffParser());\n\n              case 9:\n                return _context3.abrupt(\"return\", new FlacParser_1.FlacParser());\n\n              case 10:\n                return _context3.abrupt(\"return\", new MP4Parser_1.MP4Parser());\n\n              case 11:\n                return _context3.abrupt(\"return\", new musepack_1.default());\n\n              case 12:\n                return _context3.abrupt(\"return\", new OggParser_1.OggParser());\n\n              case 13:\n                return _context3.abrupt(\"return\", new WaveParser_1.WaveParser());\n\n              case 14:\n                return _context3.abrupt(\"return\", new WavPackParser_1.WavPackParser());\n\n              case 15:\n                return _context3.abrupt(\"return\", new MatroskaParser_1.MatroskaParser());\n\n              case 16:\n                throw new Error(\"Unknown parser type: \".concat(moduleName));\n\n              case 17:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function loadParser(_x6) {\n        return _loadParser.apply(this, arguments);\n      }\n\n      return loadParser;\n    }()\n  }, {\n    key: \"_parse\",\n    value: function () {\n      var _parse3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(tokenizer, parserId) {\n        var opts,\n            parser,\n            metadata,\n            _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n                _context4.next = 3;\n                return ParserFactory.loadParser(parserId);\n\n              case 3:\n                parser = _context4.sent;\n                metadata = new MetadataCollector_1.MetadataCollector(opts);\n                _context4.next = 7;\n                return parser.init(metadata, tokenizer, opts).parse();\n\n              case 7:\n                return _context4.abrupt(\"return\", metadata.toCommonMetadata());\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function _parse(_x7, _x8) {\n        return _parse3.apply(this, arguments);\n      }\n\n      return _parse;\n    }()\n  }, {\n    key: \"getExtension\",\n    value: function getExtension(fname) {\n      var i = fname.lastIndexOf('.');\n      return i === -1 ? '' : fname.slice(i);\n    }\n    /**\r\n     * @param httpContentType - HTTP Content-Type, extension, path or filename\r\n     * @returns Parser sub-module name\r\n     */\n\n  }, {\n    key: \"getParserIdForMimeType\",\n    value: function getParserIdForMimeType(httpContentType) {\n      var mime;\n\n      try {\n        mime = parseHttpContentType(httpContentType);\n      } catch (err) {\n        debug(\"Invalid HTTP Content-Type header value: \".concat(httpContentType));\n        return;\n      }\n\n      var subType = mime.subtype.indexOf('x-') === 0 ? mime.subtype.substring(2) : mime.subtype;\n\n      switch (mime.type) {\n        case 'audio':\n          switch (subType) {\n            case 'mp3': // Incorrect MIME-type, Chrome, in Web API File object\n\n            case 'mpeg':\n              return 'mpeg';\n\n            case 'aac':\n            case 'aacp':\n              return 'adts';\n\n            case 'flac':\n              return 'flac';\n\n            case 'ape':\n            case 'monkeys-audio':\n              return 'apev2';\n\n            case 'mp4':\n            case 'm4a':\n              return 'mp4';\n\n            case 'ogg': // RFC 7845\n\n            case 'opus': // RFC 6716\n\n            case 'speex':\n              // RFC 5574\n              return 'ogg';\n\n            case 'ms-wma':\n            case 'ms-wmv':\n            case 'ms-asf':\n              return 'asf';\n\n            case 'aiff':\n            case 'aif':\n            case 'aifc':\n              return 'aiff';\n\n            case 'vnd.wave':\n            case 'wav':\n            case 'wave':\n              return 'riff';\n\n            case 'wavpack':\n              return 'wavpack';\n\n            case 'musepack':\n              return 'musepack';\n\n            case 'matroska':\n            case 'webm':\n              return 'matroska';\n\n            case 'dsf':\n              return 'dsf';\n          }\n\n          break;\n\n        case 'video':\n          switch (subType) {\n            case 'ms-asf':\n            case 'ms-wmv':\n              return 'asf';\n\n            case 'm4v':\n            case 'mp4':\n              return 'mp4';\n\n            case 'ogg':\n              return 'ogg';\n\n            case 'matroska':\n            case 'webm':\n              return 'matroska';\n          }\n\n          break;\n\n        case 'application':\n          switch (subType) {\n            case 'vnd.ms-asf':\n              return 'asf';\n\n            case 'ogg':\n              return 'ogg';\n          }\n\n          break;\n      }\n    }\n  }]);\n\n  return ParserFactory;\n}();\n\nexports.ParserFactory = ParserFactory;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/ParserFactory.js"],"names":["Object","defineProperty","exports","value","ParserFactory","parseHttpContentType","FileType","require","ContentType","MimeType","_debug","MetadataCollector_1","AiffParser_1","APEv2Parser_1","AsfParser_1","FlacParser_1","MP4Parser_1","MpegParser_1","musepack_1","OggParser_1","WaveParser_1","WavPackParser_1","DsfParser_1","DsdiffParser_1","MatroskaParser_1","debug","contentType","type","parse","mime","subtype","suffix","parameters","tokenizer","opts","fileInfo","mimeType","path","url","parserId","getParserIdForMimeType","getParserIdForExtension","buf","Buffer","alloc","peekBuffer","mayBeLess","fromBuffer","guessedType","Error","ext","_parse","filePath","extension","getExtension","toLocaleLowerCase","moduleName","AIFFParser","MpegParser","APEv2Parser","AsfParser","DsfParser","DsdiffParser","FlacParser","MP4Parser","default","OggParser","WaveParser","WavPackParser","MatroskaParser","loadParser","parser","metadata","MetadataCollector","init","toCommonMetadata","fname","i","lastIndexOf","slice","httpContentType","err","subType","indexOf","substring"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ParserFactory = exports.parseHttpContentType = void 0;\r\nconst FileType = require(\"file-type/core\");\r\nconst ContentType = require(\"content-type\");\r\nconst MimeType = require(\"media-typer\");\r\nconst _debug = require(\"debug\");\r\nconst MetadataCollector_1 = require(\"./common/MetadataCollector\");\r\nconst AiffParser_1 = require(\"./aiff/AiffParser\");\r\nconst APEv2Parser_1 = require(\"./apev2/APEv2Parser\");\r\nconst AsfParser_1 = require(\"./asf/AsfParser\");\r\nconst FlacParser_1 = require(\"./flac/FlacParser\");\r\nconst MP4Parser_1 = require(\"./mp4/MP4Parser\");\r\nconst MpegParser_1 = require(\"./mpeg/MpegParser\");\r\nconst musepack_1 = require(\"./musepack\");\r\nconst OggParser_1 = require(\"./ogg/OggParser\");\r\nconst WaveParser_1 = require(\"./wav/WaveParser\");\r\nconst WavPackParser_1 = require(\"./wavpack/WavPackParser\");\r\nconst DsfParser_1 = require(\"./dsf/DsfParser\");\r\nconst DsdiffParser_1 = require(\"./dsdiff/DsdiffParser\");\r\nconst MatroskaParser_1 = require(\"./matroska/MatroskaParser\");\r\nconst debug = _debug('music-metadata:parser:factory');\r\nfunction parseHttpContentType(contentType) {\r\n    const type = ContentType.parse(contentType);\r\n    const mime = MimeType.parse(type.type);\r\n    return {\r\n        type: mime.type,\r\n        subtype: mime.subtype,\r\n        suffix: mime.suffix,\r\n        parameters: type.parameters\r\n    };\r\n}\r\nexports.parseHttpContentType = parseHttpContentType;\r\nclass ParserFactory {\r\n    /**\r\n     * Parse metadata from tokenizer\r\n     * @param tokenizer - Tokenizer\r\n     * @param contentType - MIME-type\r\n     * @param opts - Options\r\n     * @returns Native metadata\r\n     */\r\n    static async parseOnContentType(tokenizer, opts) {\r\n        const { mimeType, path, url } = await tokenizer.fileInfo;\r\n        // Resolve parser based on MIME-type or file extension\r\n        const parserId = ParserFactory.getParserIdForMimeType(mimeType) || ParserFactory.getParserIdForExtension(path) || ParserFactory.getParserIdForExtension(url);\r\n        if (!parserId) {\r\n            debug('No parser found for MIME-type / extension: ' + mimeType);\r\n        }\r\n        return this.parse(tokenizer, parserId, opts);\r\n    }\r\n    static async parse(tokenizer, parserId, opts) {\r\n        if (!parserId) {\r\n            // Parser could not be determined on MIME-type or extension\r\n            debug('Guess parser on content...');\r\n            const buf = Buffer.alloc(4100);\r\n            await tokenizer.peekBuffer(buf, { mayBeLess: true });\r\n            if (tokenizer.fileInfo.path) {\r\n                parserId = this.getParserIdForExtension(tokenizer.fileInfo.path);\r\n            }\r\n            if (!parserId) {\r\n                const guessedType = await FileType.fromBuffer(buf);\r\n                if (!guessedType) {\r\n                    throw new Error('Failed to determine audio format');\r\n                }\r\n                debug(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);\r\n                parserId = ParserFactory.getParserIdForMimeType(guessedType.mime);\r\n                if (!parserId) {\r\n                    throw new Error('Guessed MIME-type not supported: ' + guessedType.mime);\r\n                }\r\n            }\r\n        }\r\n        // Parser found, execute parser\r\n        return this._parse(tokenizer, parserId, opts);\r\n    }\r\n    /**\r\n     * @param filePath - Path, filename or extension to audio file\r\n     * @return Parser sub-module name\r\n     */\r\n    static getParserIdForExtension(filePath) {\r\n        if (!filePath)\r\n            return;\r\n        const extension = this.getExtension(filePath).toLocaleLowerCase() || filePath;\r\n        switch (extension) {\r\n            case '.mp2':\r\n            case '.mp3':\r\n            case '.m2a':\r\n            case '.aac': // Assume it is ADTS-container\r\n                return 'mpeg';\r\n            case '.ape':\r\n                return 'apev2';\r\n            case '.mp4':\r\n            case '.m4a':\r\n            case '.m4b':\r\n            case '.m4pa':\r\n            case '.m4v':\r\n            case '.m4r':\r\n            case '.3gp':\r\n                return 'mp4';\r\n            case '.wma':\r\n            case '.wmv':\r\n            case '.asf':\r\n                return 'asf';\r\n            case '.flac':\r\n                return 'flac';\r\n            case '.ogg':\r\n            case '.ogv':\r\n            case '.oga':\r\n            case '.ogm':\r\n            case '.ogx':\r\n            case '.opus': // recommended filename extension for Ogg Opus\r\n            case '.spx': // recommended filename extension for Ogg Speex\r\n                return 'ogg';\r\n            case '.aif':\r\n            case '.aiff':\r\n            case '.aifc':\r\n                return 'aiff';\r\n            case '.wav':\r\n                return 'riff';\r\n            case '.wv':\r\n            case '.wvp':\r\n                return 'wavpack';\r\n            case '.mpc':\r\n                return 'musepack';\r\n            case '.dsf':\r\n                return 'dsf';\r\n            case '.dff':\r\n                return 'dsdiff';\r\n            case '.mka':\r\n            case '.mkv':\r\n            case '.mk3d':\r\n            case '.mks':\r\n            case '.webm':\r\n                return 'matroska';\r\n        }\r\n    }\r\n    static async loadParser(moduleName) {\r\n        switch (moduleName) {\r\n            case 'aiff': return new AiffParser_1.AIFFParser();\r\n            case 'adts':\r\n            case 'mpeg':\r\n                return new MpegParser_1.MpegParser();\r\n            case 'apev2': return new APEv2Parser_1.APEv2Parser();\r\n            case 'asf': return new AsfParser_1.AsfParser();\r\n            case 'dsf': return new DsfParser_1.DsfParser();\r\n            case 'dsdiff': return new DsdiffParser_1.DsdiffParser();\r\n            case 'flac': return new FlacParser_1.FlacParser();\r\n            case 'mp4': return new MP4Parser_1.MP4Parser();\r\n            case 'musepack': return new musepack_1.default();\r\n            case 'ogg': return new OggParser_1.OggParser();\r\n            case 'riff': return new WaveParser_1.WaveParser();\r\n            case 'wavpack': return new WavPackParser_1.WavPackParser();\r\n            case 'matroska': return new MatroskaParser_1.MatroskaParser();\r\n            default:\r\n                throw new Error(`Unknown parser type: ${moduleName}`);\r\n        }\r\n    }\r\n    static async _parse(tokenizer, parserId, opts = {}) {\r\n        // Parser found, execute parser\r\n        const parser = await ParserFactory.loadParser(parserId);\r\n        const metadata = new MetadataCollector_1.MetadataCollector(opts);\r\n        await parser.init(metadata, tokenizer, opts).parse();\r\n        return metadata.toCommonMetadata();\r\n    }\r\n    static getExtension(fname) {\r\n        const i = fname.lastIndexOf('.');\r\n        return i === -1 ? '' : fname.slice(i);\r\n    }\r\n    /**\r\n     * @param httpContentType - HTTP Content-Type, extension, path or filename\r\n     * @returns Parser sub-module name\r\n     */\r\n    static getParserIdForMimeType(httpContentType) {\r\n        let mime;\r\n        try {\r\n            mime = parseHttpContentType(httpContentType);\r\n        }\r\n        catch (err) {\r\n            debug(`Invalid HTTP Content-Type header value: ${httpContentType}`);\r\n            return;\r\n        }\r\n        const subType = mime.subtype.indexOf('x-') === 0 ? mime.subtype.substring(2) : mime.subtype;\r\n        switch (mime.type) {\r\n            case 'audio':\r\n                switch (subType) {\r\n                    case 'mp3': // Incorrect MIME-type, Chrome, in Web API File object\r\n                    case 'mpeg':\r\n                        return 'mpeg';\r\n                    case 'aac':\r\n                    case 'aacp':\r\n                        return 'adts';\r\n                    case 'flac':\r\n                        return 'flac';\r\n                    case 'ape':\r\n                    case 'monkeys-audio':\r\n                        return 'apev2';\r\n                    case 'mp4':\r\n                    case 'm4a':\r\n                        return 'mp4';\r\n                    case 'ogg': // RFC 7845\r\n                    case 'opus': // RFC 6716\r\n                    case 'speex': // RFC 5574\r\n                        return 'ogg';\r\n                    case 'ms-wma':\r\n                    case 'ms-wmv':\r\n                    case 'ms-asf':\r\n                        return 'asf';\r\n                    case 'aiff':\r\n                    case 'aif':\r\n                    case 'aifc':\r\n                        return 'aiff';\r\n                    case 'vnd.wave':\r\n                    case 'wav':\r\n                    case 'wave':\r\n                        return 'riff';\r\n                    case 'wavpack':\r\n                        return 'wavpack';\r\n                    case 'musepack':\r\n                        return 'musepack';\r\n                    case 'matroska':\r\n                    case 'webm':\r\n                        return 'matroska';\r\n                    case 'dsf':\r\n                        return 'dsf';\r\n                }\r\n                break;\r\n            case 'video':\r\n                switch (subType) {\r\n                    case 'ms-asf':\r\n                    case 'ms-wmv':\r\n                        return 'asf';\r\n                    case 'm4v':\r\n                    case 'mp4':\r\n                        return 'mp4';\r\n                    case 'ogg':\r\n                        return 'ogg';\r\n                    case 'matroska':\r\n                    case 'webm':\r\n                        return 'matroska';\r\n                }\r\n                break;\r\n            case 'application':\r\n                switch (subType) {\r\n                    case 'vnd.ms-asf':\r\n                        return 'asf';\r\n                    case 'ogg':\r\n                        return 'ogg';\r\n                }\r\n                break;\r\n        }\r\n    }\r\n}\r\nexports.ParserFactory = ParserFactory;\r\n"]},"metadata":{},"sourceType":"script"}