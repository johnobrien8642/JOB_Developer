{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DsdiffParser = void 0;\n\nconst Token = require(\"token-types\");\n\nconst initDebug = require(\"debug\");\n\nconst FourCC_1 = require(\"../common/FourCC\");\n\nconst BasicParser_1 = require(\"../common/BasicParser\");\n\nconst DsdiffToken_1 = require(\"./DsdiffToken\");\n\nconst strtok3 = require(\"strtok3/lib/core\");\n\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\n\nconst debug = initDebug('music-metadata:parser:aiff');\n/**\r\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\r\n *\r\n * Ref:\r\n *  http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\r\n */\n\nclass DsdiffParser extends BasicParser_1.BasicParser {\n  async parse() {\n    const header = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);\n    if (header.chunkID !== 'FRM8') throw new Error('Unexpected chunk-ID');\n    const type = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n\n    switch (type) {\n      case 'DSD':\n        this.metadata.setFormat('container', `DSDIFF/${type}`);\n        this.metadata.setFormat('lossless', true);\n        return this.readFmt8Chunks(header.chunkSize - FourCC_1.FourCcToken.len);\n\n      default:\n        throw Error(`Unsupported DSDIFF type: ${type}`);\n    }\n  }\n\n  async readFmt8Chunks(remainingSize) {\n    while (remainingSize >= DsdiffToken_1.ChunkHeader.len) {\n      const chunkHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader); //  If the data is an odd number of bytes in length, a pad byte must be added at the end\n\n      debug(`Chunk id=${chunkHeader.chunkID}`);\n      await this.readData(chunkHeader);\n      remainingSize -= DsdiffToken_1.ChunkHeader.len + chunkHeader.chunkSize;\n    }\n  }\n\n  async readData(header) {\n    debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n    const p0 = this.tokenizer.position;\n\n    switch (header.chunkID.trim()) {\n      case 'FVER':\n        // 3.1 FORMAT VERSION CHUNK\n        const version = await this.tokenizer.readToken(Token.UINT32_LE);\n        debug(`DSDIFF version=${version}`);\n        break;\n\n      case 'PROP':\n        // 3.2 PROPERTY CHUNK\n        const propType = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        if (propType !== 'SND ') throw new Error('Unexpected PROP-chunk ID');\n        await this.handleSoundPropertyChunks(header.chunkSize - FourCC_1.FourCcToken.len);\n        break;\n\n      case 'ID3':\n        // Unofficial ID3 tag support\n        const id3_data = await this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\n        const rst = strtok3.fromBuffer(id3_data);\n        await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n        break;\n\n      default:\n        debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n        break;\n\n      case 'DSD':\n        this.metadata.setFormat('numberOfSamples', header.chunkSize * 8 / this.metadata.format.numberOfChannels);\n        this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n        break;\n    }\n\n    const remaining = header.chunkSize - (this.tokenizer.position - p0);\n\n    if (remaining > 0) {\n      debug(`After Parsing chunk, remaining ${remaining} bytes`);\n      await this.tokenizer.ignore(remaining);\n    }\n  }\n\n  async handleSoundPropertyChunks(remainingSize) {\n    debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n\n    while (remainingSize > 0) {\n      const sndPropHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);\n      debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n      const p0 = this.tokenizer.position;\n\n      switch (sndPropHeader.chunkID.trim()) {\n        case 'FS':\n          // 3.2.1 Sample Rate Chunk\n          const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\n          this.metadata.setFormat('sampleRate', sampleRate);\n          break;\n\n        case 'CHNL':\n          // 3.2.2 Channels Chunk\n          const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\n          this.metadata.setFormat('numberOfChannels', numChannels);\n          await this.handleChannelChunks(sndPropHeader.chunkSize - Token.UINT16_BE.len);\n          break;\n\n        case 'CMPR':\n          // 3.2.3 Compression Type Chunk\n          const compressionIdCode = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n          const count = await this.tokenizer.readToken(Token.UINT8);\n          const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\n\n          if (compressionIdCode === 'DSD') {\n            this.metadata.setFormat('lossless', true);\n            this.metadata.setFormat('bitsPerSample', 1);\n          }\n\n          this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);\n          break;\n\n        case 'ABSS':\n          // 3.2.4 Absolute Start Time Chunk\n          const hours = await this.tokenizer.readToken(Token.UINT16_BE);\n          const minutes = await this.tokenizer.readToken(Token.UINT8);\n          const seconds = await this.tokenizer.readToken(Token.UINT8);\n          const samples = await this.tokenizer.readToken(Token.UINT32_BE);\n          debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);\n          break;\n\n        case 'LSCO':\n          // 3.2.5 Loudspeaker Configuration Chunk\n          const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\n          debug(`LSCO lsConfig=${lsConfig}`);\n          break;\n\n        case 'COMT':\n        default:\n          debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n          await this.tokenizer.ignore(sndPropHeader.chunkSize);\n      }\n\n      const remaining = sndPropHeader.chunkSize - (this.tokenizer.position - p0);\n\n      if (remaining > 0) {\n        debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);\n        await this.tokenizer.ignore(remaining);\n      }\n\n      remainingSize -= DsdiffToken_1.ChunkHeader.len + sndPropHeader.chunkSize;\n      debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n    }\n\n    if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\n      const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\n      this.metadata.setFormat('bitrate', bitrate);\n    }\n  }\n\n  async handleChannelChunks(remainingSize) {\n    debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);\n    const channels = [];\n\n    while (remainingSize >= FourCC_1.FourCcToken.len) {\n      const channelId = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n      debug(`Channel[ID=${channelId}]`);\n      channels.push(channelId);\n      remainingSize -= FourCC_1.FourCcToken.len;\n    }\n\n    debug(`Channels: ${channels.join(', ')}`);\n    return channels;\n  }\n\n}\n\nexports.DsdiffParser = DsdiffParser;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/JOB_Developer/client/node_modules/music-metadata/lib/dsdiff/DsdiffParser.js"],"names":["Object","defineProperty","exports","value","DsdiffParser","Token","require","initDebug","FourCC_1","BasicParser_1","DsdiffToken_1","strtok3","ID3v2Parser_1","debug","BasicParser","parse","header","tokenizer","readToken","ChunkHeader","chunkID","Error","type","FourCcToken","trim","metadata","setFormat","readFmt8Chunks","chunkSize","len","remainingSize","chunkHeader","readData","p0","position","version","UINT32_LE","propType","handleSoundPropertyChunks","id3_data","BufferType","rst","fromBuffer","ID3v2Parser","options","format","numberOfChannels","numberOfSamples","sampleRate","remaining","ignore","sndPropHeader","UINT32_BE","numChannels","UINT16_BE","handleChannelChunks","compressionIdCode","count","UINT8","compressionName","StringType","hours","minutes","seconds","samples","lsConfig","lossless","bitsPerSample","bitrate","channels","channelId","push","join"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DsdiffParser = void 0;\r\nconst Token = require(\"token-types\");\r\nconst initDebug = require(\"debug\");\r\nconst FourCC_1 = require(\"../common/FourCC\");\r\nconst BasicParser_1 = require(\"../common/BasicParser\");\r\nconst DsdiffToken_1 = require(\"./DsdiffToken\");\r\nconst strtok3 = require(\"strtok3/lib/core\");\r\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\r\nconst debug = initDebug('music-metadata:parser:aiff');\r\n/**\r\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\r\n *\r\n * Ref:\r\n *  http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\r\n */\r\nclass DsdiffParser extends BasicParser_1.BasicParser {\r\n    async parse() {\r\n        const header = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);\r\n        if (header.chunkID !== 'FRM8')\r\n            throw new Error('Unexpected chunk-ID');\r\n        const type = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\r\n        switch (type) {\r\n            case 'DSD':\r\n                this.metadata.setFormat('container', `DSDIFF/${type}`);\r\n                this.metadata.setFormat('lossless', true);\r\n                return this.readFmt8Chunks(header.chunkSize - FourCC_1.FourCcToken.len);\r\n            default:\r\n                throw Error(`Unsupported DSDIFF type: ${type}`);\r\n        }\r\n    }\r\n    async readFmt8Chunks(remainingSize) {\r\n        while (remainingSize >= DsdiffToken_1.ChunkHeader.len) {\r\n            const chunkHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);\r\n            //  If the data is an odd number of bytes in length, a pad byte must be added at the end\r\n            debug(`Chunk id=${chunkHeader.chunkID}`);\r\n            await this.readData(chunkHeader);\r\n            remainingSize -= (DsdiffToken_1.ChunkHeader.len + chunkHeader.chunkSize);\r\n        }\r\n    }\r\n    async readData(header) {\r\n        debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\r\n        const p0 = this.tokenizer.position;\r\n        switch (header.chunkID.trim()) {\r\n            case 'FVER': // 3.1 FORMAT VERSION CHUNK\r\n                const version = await this.tokenizer.readToken(Token.UINT32_LE);\r\n                debug(`DSDIFF version=${version}`);\r\n                break;\r\n            case 'PROP': // 3.2 PROPERTY CHUNK\r\n                const propType = await this.tokenizer.readToken(FourCC_1.FourCcToken);\r\n                if (propType !== 'SND ')\r\n                    throw new Error('Unexpected PROP-chunk ID');\r\n                await this.handleSoundPropertyChunks(header.chunkSize - FourCC_1.FourCcToken.len);\r\n                break;\r\n            case 'ID3': // Unofficial ID3 tag support\r\n                const id3_data = await this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\r\n                const rst = strtok3.fromBuffer(id3_data);\r\n                await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\r\n                break;\r\n            default:\r\n                debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\r\n                break;\r\n            case 'DSD':\r\n                this.metadata.setFormat('numberOfSamples', header.chunkSize * 8 / this.metadata.format.numberOfChannels);\r\n                this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\r\n                break;\r\n        }\r\n        const remaining = header.chunkSize - (this.tokenizer.position - p0);\r\n        if (remaining > 0) {\r\n            debug(`After Parsing chunk, remaining ${remaining} bytes`);\r\n            await this.tokenizer.ignore(remaining);\r\n        }\r\n    }\r\n    async handleSoundPropertyChunks(remainingSize) {\r\n        debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\r\n        while (remainingSize > 0) {\r\n            const sndPropHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);\r\n            debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\r\n            const p0 = this.tokenizer.position;\r\n            switch (sndPropHeader.chunkID.trim()) {\r\n                case 'FS': // 3.2.1 Sample Rate Chunk\r\n                    const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\r\n                    this.metadata.setFormat('sampleRate', sampleRate);\r\n                    break;\r\n                case 'CHNL': // 3.2.2 Channels Chunk\r\n                    const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\r\n                    this.metadata.setFormat('numberOfChannels', numChannels);\r\n                    await this.handleChannelChunks(sndPropHeader.chunkSize - Token.UINT16_BE.len);\r\n                    break;\r\n                case 'CMPR': // 3.2.3 Compression Type Chunk\r\n                    const compressionIdCode = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\r\n                    const count = await this.tokenizer.readToken(Token.UINT8);\r\n                    const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\r\n                    if (compressionIdCode === 'DSD') {\r\n                        this.metadata.setFormat('lossless', true);\r\n                        this.metadata.setFormat('bitsPerSample', 1);\r\n                    }\r\n                    this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);\r\n                    break;\r\n                case 'ABSS': // 3.2.4 Absolute Start Time Chunk\r\n                    const hours = await this.tokenizer.readToken(Token.UINT16_BE);\r\n                    const minutes = await this.tokenizer.readToken(Token.UINT8);\r\n                    const seconds = await this.tokenizer.readToken(Token.UINT8);\r\n                    const samples = await this.tokenizer.readToken(Token.UINT32_BE);\r\n                    debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);\r\n                    break;\r\n                case 'LSCO': // 3.2.5 Loudspeaker Configuration Chunk\r\n                    const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\r\n                    debug(`LSCO lsConfig=${lsConfig}`);\r\n                    break;\r\n                case 'COMT':\r\n                default:\r\n                    debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\r\n                    await this.tokenizer.ignore(sndPropHeader.chunkSize);\r\n            }\r\n            const remaining = sndPropHeader.chunkSize - (this.tokenizer.position - p0);\r\n            if (remaining > 0) {\r\n                debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);\r\n                await this.tokenizer.ignore(remaining);\r\n            }\r\n            remainingSize -= DsdiffToken_1.ChunkHeader.len + sndPropHeader.chunkSize;\r\n            debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\r\n        }\r\n        if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\r\n            const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\r\n            this.metadata.setFormat('bitrate', bitrate);\r\n        }\r\n    }\r\n    async handleChannelChunks(remainingSize) {\r\n        debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);\r\n        const channels = [];\r\n        while (remainingSize >= FourCC_1.FourCcToken.len) {\r\n            const channelId = await this.tokenizer.readToken(FourCC_1.FourCcToken);\r\n            debug(`Channel[ID=${channelId}]`);\r\n            channels.push(channelId);\r\n            remainingSize -= FourCC_1.FourCcToken.len;\r\n        }\r\n        debug(`Channels: ${channels.join(', ')}`);\r\n        return channels;\r\n    }\r\n}\r\nexports.DsdiffParser = DsdiffParser;\r\n"]},"metadata":{},"sourceType":"script"}