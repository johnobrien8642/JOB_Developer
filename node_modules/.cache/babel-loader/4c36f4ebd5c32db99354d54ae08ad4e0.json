{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.joinArtists = exports.MetadataCollector = void 0;\n\nconst type_1 = require(\"../type\");\n\nconst _debug = require(\"debug\");\n\nconst GenericTagTypes_1 = require(\"./GenericTagTypes\");\n\nconst CombinedTagMapper_1 = require(\"./CombinedTagMapper\");\n\nconst GenericTagMapper_1 = require(\"./GenericTagMapper\");\n\nconst Util_1 = require(\"./Util\");\n\nconst FileType = require(\"file-type/core\");\n\nconst debug = _debug('music-metadata:collector');\n\nconst TagPriority = ['matroska', 'APEv2', 'vorbis', 'ID3v2.4', 'ID3v2.3', 'ID3v2.2', 'exif', 'asf', 'iTunes', 'ID3v1'];\n/**\r\n * Provided to the parser to uodate the metadata result.\r\n * Responsible for triggering async updates\r\n */\n\nclass MetadataCollector {\n  constructor(opts) {\n    this.opts = opts;\n    this.format = {\n      tagTypes: [],\n      trackInfo: []\n    };\n    this.native = {};\n    this.common = {\n      track: {\n        no: null,\n        of: null\n      },\n      disk: {\n        no: null,\n        of: null\n      },\n      movementIndex: {}\n    };\n    this.quality = {\n      warnings: []\n    };\n    /**\r\n     * Keeps track of origin priority for each mapped id\r\n     */\n\n    this.commonOrigin = {};\n    /**\r\n     * Maps a tag type to a priority\r\n     */\n\n    this.originPriority = {};\n    this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();\n    let priority = 1;\n\n    for (const tagType of TagPriority) {\n      this.originPriority[tagType] = priority++;\n    }\n\n    this.originPriority.artificial = 500; // Filled using alternative tags\n\n    this.originPriority.id3v1 = 600; // Consider worst due to field length limit\n  }\n  /**\r\n   * @returns {boolean} true if one or more tags have been found\r\n   */\n\n\n  hasAny() {\n    return Object.keys(this.native).length > 0;\n  }\n\n  addStreamInfo(streamInfo) {\n    debug(`streamInfo: type=${type_1.TrackType[streamInfo.type]}, codec=${streamInfo.codecName}`);\n    this.format.trackInfo.push(streamInfo);\n  }\n\n  setFormat(key, value) {\n    debug(`format: ${key} = ${value}`);\n    this.format[key] = value; // as any to override readonly\n\n    if (this.opts.observer) {\n      this.opts.observer({\n        metadata: this,\n        tag: {\n          type: 'format',\n          id: key,\n          value\n        }\n      });\n    }\n  }\n\n  addTag(tagType, tagId, value) {\n    debug(`tag ${tagType}.${tagId} = ${value}`);\n\n    if (!this.native[tagType]) {\n      this.format.tagTypes.push(tagType);\n      this.native[tagType] = [];\n    }\n\n    this.native[tagType].push({\n      id: tagId,\n      value\n    });\n    this.toCommon(tagType, tagId, value);\n  }\n\n  addWarning(warning) {\n    this.quality.warnings.push({\n      message: warning\n    });\n  }\n\n  postMap(tagType, tag) {\n    // Common tag (alias) found\n    // check if we need to do something special with common tag\n    // if the event has been aliased then we need to clean it before\n    // it is emitted to the user. e.g. genre (20) -> Electronic\n    switch (tag.id) {\n      case 'artist':\n        if (this.commonOrigin.artist === this.originPriority[tagType]) {\n          // Assume the artist field is used as artists\n          return this.postMap('artificial', {\n            id: 'artists',\n            value: tag.value\n          });\n        }\n\n        if (!this.common.artists) {\n          // Fill artists using artist source\n          this.setGenericTag('artificial', {\n            id: 'artists',\n            value: tag.value\n          });\n        }\n\n        break;\n\n      case 'artists':\n        if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {\n          if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {\n            // Fill artist using artists source\n            const artists = (this.common.artists || []).concat([tag.value]);\n            const value = joinArtists(artists);\n            const artistTag = {\n              id: 'artist',\n              value\n            };\n            this.setGenericTag('artificial', artistTag);\n          }\n        }\n\n        break;\n\n      case 'picture':\n        this.postFixPicture(tag.value).then(picture => {\n          if (picture !== null) {\n            tag.value = picture;\n            this.setGenericTag(tagType, tag);\n          }\n        });\n        return;\n\n      case 'totaltracks':\n        this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n        return;\n\n      case 'totaldiscs':\n        this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n        return;\n\n      case 'movementTotal':\n        this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n        return;\n\n      case 'track':\n      case 'disk':\n      case 'movementIndex':\n        const of = this.common[tag.id].of; // store of value, maybe maybe overwritten\n\n        this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);\n        this.common[tag.id].of = of != null ? of : this.common[tag.id].of;\n        return;\n\n      case 'year':\n      case 'originalyear':\n        tag.value = parseInt(tag.value, 10);\n        break;\n\n      case 'date':\n        // ToDo: be more strict on 'YYYY...'\n        const year = parseInt(tag.value.substr(0, 4), 10);\n\n        if (!isNaN(year)) {\n          this.common.year = year;\n        }\n\n        break;\n\n      case 'discogs_label_id':\n      case 'discogs_release_id':\n      case 'discogs_master_release_id':\n      case 'discogs_artist_id':\n      case 'discogs_votes':\n        tag.value = typeof tag.value === 'string' ? parseInt(tag.value, 10) : tag.value;\n        break;\n\n      case 'replaygain_track_gain':\n      case 'replaygain_track_peak':\n      case 'replaygain_album_gain':\n      case 'replaygain_album_peak':\n        tag.value = Util_1.toRatio(tag.value);\n        break;\n\n      case 'replaygain_track_minmax':\n        tag.value = tag.value.split(',').map(v => parseInt(v, 10));\n        break;\n\n      case 'replaygain_undo':\n        const minMix = tag.value.split(',').map(v => parseInt(v, 10));\n        tag.value = {\n          leftChannel: minMix[0],\n          rightChannel: minMix[1]\n        };\n        break;\n\n      case 'gapless': // iTunes gap-less flag\n\n      case 'compilation':\n      case 'podcast':\n      case 'showMovement':\n        tag.value = tag.value === '1' || tag.value === 1; // boolean\n\n        break;\n\n      case 'isrc':\n        // Only keep unique values\n        if (this.common[tag.id] && this.common[tag.id].indexOf(tag.value) !== -1) return;\n        break;\n\n      default: // nothing to do\n\n    }\n\n    if (tag.value !== null) {\n      this.setGenericTag(tagType, tag);\n    }\n  }\n  /**\r\n   * Convert native tags to common tags\r\n   * @returns {IAudioMetadata} Native + common tags\r\n   */\n\n\n  toCommonMetadata() {\n    return {\n      format: this.format,\n      native: this.native,\n      quality: this.quality,\n      common: this.common\n    };\n  }\n  /**\r\n   * Fix some common issues with picture object\r\n   * @param pictureType\r\n   */\n\n\n  async postFixPicture(picture) {\n    if (picture.data && picture.data.length > 0) {\n      if (!picture.format) {\n        const fileType = await FileType.fromBuffer(picture.data);\n\n        if (fileType) {\n          picture.format = fileType.mime;\n        } else {\n          return null;\n        }\n      }\n\n      picture.format = picture.format.toLocaleLowerCase();\n\n      switch (picture.format) {\n        case 'image/jpg':\n          picture.format = 'image/jpeg';\n        // ToDo: register warning\n      }\n\n      return picture;\n    }\n\n    this.addWarning(`Empty picture tag found`);\n    return null;\n  }\n  /**\r\n   * Convert native tag to common tags\r\n   */\n\n\n  toCommon(tagType, tagId, value) {\n    const tag = {\n      id: tagId,\n      value\n    };\n    const genericTag = this.tagMapper.mapTag(tagType, tag, this);\n\n    if (genericTag) {\n      this.postMap(tagType, genericTag);\n    }\n  }\n  /**\r\n   * Set generic tag\r\n   */\n\n\n  setGenericTag(tagType, tag) {\n    debug(`common.${tag.id} = ${tag.value}`);\n    const prio0 = this.commonOrigin[tag.id] || 1000;\n    const prio1 = this.originPriority[tagType];\n\n    if (GenericTagTypes_1.isSingleton(tag.id)) {\n      if (prio1 <= prio0) {\n        this.common[tag.id] = tag.value;\n        this.commonOrigin[tag.id] = prio1;\n      } else {\n        return debug(`Ignore native tag (singleton): ${tagType}.${tag.id} = ${tag.value}`);\n      }\n    } else {\n      if (prio1 === prio0) {\n        if (!GenericTagTypes_1.isUnique(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {\n          this.common[tag.id].push(tag.value);\n        } else {\n          debug(`Ignore duplicate value: ${tagType}.${tag.id} = ${tag.value}`);\n        } // no effect? this.commonOrigin[tag.id] = prio1;\n\n      } else if (prio1 < prio0) {\n        this.common[tag.id] = [tag.value];\n        this.commonOrigin[tag.id] = prio1;\n      } else {\n        return debug(`Ignore native tag (list): ${tagType}.${tag.id} = ${tag.value}`);\n      }\n    }\n\n    if (this.opts.observer) {\n      this.opts.observer({\n        metadata: this,\n        tag: {\n          type: 'common',\n          id: tag.id,\n          value: tag.value\n        }\n      });\n    } // ToDo: trigger metadata event\n\n  }\n\n}\n\nexports.MetadataCollector = MetadataCollector;\n\nfunction joinArtists(artists) {\n  if (artists.length > 2) {\n    return artists.slice(0, artists.length - 1).join(', ') + ' & ' + artists[artists.length - 1];\n  }\n\n  return artists.join(' & ');\n}\n\nexports.joinArtists = joinArtists;","map":{"version":3,"sources":["/Users/johnobrien/Desktop/Rumblr_PROD/client/node_modules/music-metadata/lib/common/MetadataCollector.js"],"names":["Object","defineProperty","exports","value","joinArtists","MetadataCollector","type_1","require","_debug","GenericTagTypes_1","CombinedTagMapper_1","GenericTagMapper_1","Util_1","FileType","debug","TagPriority","constructor","opts","format","tagTypes","trackInfo","native","common","track","no","of","disk","movementIndex","quality","warnings","commonOrigin","originPriority","tagMapper","CombinedTagMapper","priority","tagType","artificial","id3v1","hasAny","keys","length","addStreamInfo","streamInfo","TrackType","type","codecName","push","setFormat","key","observer","metadata","tag","id","addTag","tagId","toCommon","addWarning","warning","message","postMap","artist","artists","setGenericTag","indexOf","concat","artistTag","postFixPicture","then","picture","CommonTagMapper","toIntOrNull","normalizeTrack","parseInt","year","substr","isNaN","toRatio","split","map","v","minMix","leftChannel","rightChannel","toCommonMetadata","data","fileType","fromBuffer","mime","toLocaleLowerCase","genericTag","mapTag","prio0","prio1","isSingleton","isUnique","slice","join"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.joinArtists = exports.MetadataCollector = void 0;\r\nconst type_1 = require(\"../type\");\r\nconst _debug = require(\"debug\");\r\nconst GenericTagTypes_1 = require(\"./GenericTagTypes\");\r\nconst CombinedTagMapper_1 = require(\"./CombinedTagMapper\");\r\nconst GenericTagMapper_1 = require(\"./GenericTagMapper\");\r\nconst Util_1 = require(\"./Util\");\r\nconst FileType = require(\"file-type/core\");\r\nconst debug = _debug('music-metadata:collector');\r\nconst TagPriority = ['matroska', 'APEv2', 'vorbis', 'ID3v2.4', 'ID3v2.3', 'ID3v2.2', 'exif', 'asf', 'iTunes', 'ID3v1'];\r\n/**\r\n * Provided to the parser to uodate the metadata result.\r\n * Responsible for triggering async updates\r\n */\r\nclass MetadataCollector {\r\n    constructor(opts) {\r\n        this.opts = opts;\r\n        this.format = {\r\n            tagTypes: [],\r\n            trackInfo: []\r\n        };\r\n        this.native = {};\r\n        this.common = {\r\n            track: { no: null, of: null },\r\n            disk: { no: null, of: null },\r\n            movementIndex: {}\r\n        };\r\n        this.quality = {\r\n            warnings: []\r\n        };\r\n        /**\r\n         * Keeps track of origin priority for each mapped id\r\n         */\r\n        this.commonOrigin = {};\r\n        /**\r\n         * Maps a tag type to a priority\r\n         */\r\n        this.originPriority = {};\r\n        this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();\r\n        let priority = 1;\r\n        for (const tagType of TagPriority) {\r\n            this.originPriority[tagType] = priority++;\r\n        }\r\n        this.originPriority.artificial = 500; // Filled using alternative tags\r\n        this.originPriority.id3v1 = 600; // Consider worst due to field length limit\r\n    }\r\n    /**\r\n     * @returns {boolean} true if one or more tags have been found\r\n     */\r\n    hasAny() {\r\n        return Object.keys(this.native).length > 0;\r\n    }\r\n    addStreamInfo(streamInfo) {\r\n        debug(`streamInfo: type=${type_1.TrackType[streamInfo.type]}, codec=${streamInfo.codecName}`);\r\n        this.format.trackInfo.push(streamInfo);\r\n    }\r\n    setFormat(key, value) {\r\n        debug(`format: ${key} = ${value}`);\r\n        this.format[key] = value; // as any to override readonly\r\n        if (this.opts.observer) {\r\n            this.opts.observer({ metadata: this, tag: { type: 'format', id: key, value } });\r\n        }\r\n    }\r\n    addTag(tagType, tagId, value) {\r\n        debug(`tag ${tagType}.${tagId} = ${value}`);\r\n        if (!this.native[tagType]) {\r\n            this.format.tagTypes.push(tagType);\r\n            this.native[tagType] = [];\r\n        }\r\n        this.native[tagType].push({ id: tagId, value });\r\n        this.toCommon(tagType, tagId, value);\r\n    }\r\n    addWarning(warning) {\r\n        this.quality.warnings.push({ message: warning });\r\n    }\r\n    postMap(tagType, tag) {\r\n        // Common tag (alias) found\r\n        // check if we need to do something special with common tag\r\n        // if the event has been aliased then we need to clean it before\r\n        // it is emitted to the user. e.g. genre (20) -> Electronic\r\n        switch (tag.id) {\r\n            case 'artist':\r\n                if (this.commonOrigin.artist === this.originPriority[tagType]) {\r\n                    // Assume the artist field is used as artists\r\n                    return this.postMap('artificial', { id: 'artists', value: tag.value });\r\n                }\r\n                if (!this.common.artists) {\r\n                    // Fill artists using artist source\r\n                    this.setGenericTag('artificial', { id: 'artists', value: tag.value });\r\n                }\r\n                break;\r\n            case 'artists':\r\n                if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {\r\n                    if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {\r\n                        // Fill artist using artists source\r\n                        const artists = (this.common.artists || []).concat([tag.value]);\r\n                        const value = joinArtists(artists);\r\n                        const artistTag = { id: 'artist', value };\r\n                        this.setGenericTag('artificial', artistTag);\r\n                    }\r\n                }\r\n                break;\r\n            case 'picture':\r\n                this.postFixPicture(tag.value).then(picture => {\r\n                    if (picture !== null) {\r\n                        tag.value = picture;\r\n                        this.setGenericTag(tagType, tag);\r\n                    }\r\n                });\r\n                return;\r\n            case 'totaltracks':\r\n                this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\r\n                return;\r\n            case 'totaldiscs':\r\n                this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\r\n                return;\r\n            case 'movementTotal':\r\n                this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\r\n                return;\r\n            case 'track':\r\n            case 'disk':\r\n            case 'movementIndex':\r\n                const of = this.common[tag.id].of; // store of value, maybe maybe overwritten\r\n                this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);\r\n                this.common[tag.id].of = of != null ? of : this.common[tag.id].of;\r\n                return;\r\n            case 'year':\r\n            case 'originalyear':\r\n                tag.value = parseInt(tag.value, 10);\r\n                break;\r\n            case 'date':\r\n                // ToDo: be more strict on 'YYYY...'\r\n                const year = parseInt(tag.value.substr(0, 4), 10);\r\n                if (!isNaN(year)) {\r\n                    this.common.year = year;\r\n                }\r\n                break;\r\n            case 'discogs_label_id':\r\n            case 'discogs_release_id':\r\n            case 'discogs_master_release_id':\r\n            case 'discogs_artist_id':\r\n            case 'discogs_votes':\r\n                tag.value = typeof tag.value === 'string' ? parseInt(tag.value, 10) : tag.value;\r\n                break;\r\n            case 'replaygain_track_gain':\r\n            case 'replaygain_track_peak':\r\n            case 'replaygain_album_gain':\r\n            case 'replaygain_album_peak':\r\n                tag.value = Util_1.toRatio(tag.value);\r\n                break;\r\n            case 'replaygain_track_minmax':\r\n                tag.value = tag.value.split(',').map(v => parseInt(v, 10));\r\n                break;\r\n            case 'replaygain_undo':\r\n                const minMix = tag.value.split(',').map(v => parseInt(v, 10));\r\n                tag.value = {\r\n                    leftChannel: minMix[0],\r\n                    rightChannel: minMix[1]\r\n                };\r\n                break;\r\n            case 'gapless': // iTunes gap-less flag\r\n            case 'compilation':\r\n            case 'podcast':\r\n            case 'showMovement':\r\n                tag.value = tag.value === '1' || tag.value === 1; // boolean\r\n                break;\r\n            case 'isrc': // Only keep unique values\r\n                if (this.common[tag.id] && this.common[tag.id].indexOf(tag.value) !== -1)\r\n                    return;\r\n                break;\r\n            default:\r\n            // nothing to do\r\n        }\r\n        if (tag.value !== null) {\r\n            this.setGenericTag(tagType, tag);\r\n        }\r\n    }\r\n    /**\r\n     * Convert native tags to common tags\r\n     * @returns {IAudioMetadata} Native + common tags\r\n     */\r\n    toCommonMetadata() {\r\n        return {\r\n            format: this.format,\r\n            native: this.native,\r\n            quality: this.quality,\r\n            common: this.common\r\n        };\r\n    }\r\n    /**\r\n     * Fix some common issues with picture object\r\n     * @param pictureType\r\n     */\r\n    async postFixPicture(picture) {\r\n        if (picture.data && picture.data.length > 0) {\r\n            if (!picture.format) {\r\n                const fileType = await FileType.fromBuffer(picture.data);\r\n                if (fileType) {\r\n                    picture.format = fileType.mime;\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n            picture.format = picture.format.toLocaleLowerCase();\r\n            switch (picture.format) {\r\n                case 'image/jpg':\r\n                    picture.format = 'image/jpeg'; // ToDo: register warning\r\n            }\r\n            return picture;\r\n        }\r\n        this.addWarning(`Empty picture tag found`);\r\n        return null;\r\n    }\r\n    /**\r\n     * Convert native tag to common tags\r\n     */\r\n    toCommon(tagType, tagId, value) {\r\n        const tag = { id: tagId, value };\r\n        const genericTag = this.tagMapper.mapTag(tagType, tag, this);\r\n        if (genericTag) {\r\n            this.postMap(tagType, genericTag);\r\n        }\r\n    }\r\n    /**\r\n     * Set generic tag\r\n     */\r\n    setGenericTag(tagType, tag) {\r\n        debug(`common.${tag.id} = ${tag.value}`);\r\n        const prio0 = this.commonOrigin[tag.id] || 1000;\r\n        const prio1 = this.originPriority[tagType];\r\n        if (GenericTagTypes_1.isSingleton(tag.id)) {\r\n            if (prio1 <= prio0) {\r\n                this.common[tag.id] = tag.value;\r\n                this.commonOrigin[tag.id] = prio1;\r\n            }\r\n            else {\r\n                return debug(`Ignore native tag (singleton): ${tagType}.${tag.id} = ${tag.value}`);\r\n            }\r\n        }\r\n        else {\r\n            if (prio1 === prio0) {\r\n                if (!GenericTagTypes_1.isUnique(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {\r\n                    this.common[tag.id].push(tag.value);\r\n                }\r\n                else {\r\n                    debug(`Ignore duplicate value: ${tagType}.${tag.id} = ${tag.value}`);\r\n                }\r\n                // no effect? this.commonOrigin[tag.id] = prio1;\r\n            }\r\n            else if (prio1 < prio0) {\r\n                this.common[tag.id] = [tag.value];\r\n                this.commonOrigin[tag.id] = prio1;\r\n            }\r\n            else {\r\n                return debug(`Ignore native tag (list): ${tagType}.${tag.id} = ${tag.value}`);\r\n            }\r\n        }\r\n        if (this.opts.observer) {\r\n            this.opts.observer({ metadata: this, tag: { type: 'common', id: tag.id, value: tag.value } });\r\n        }\r\n        // ToDo: trigger metadata event\r\n    }\r\n}\r\nexports.MetadataCollector = MetadataCollector;\r\nfunction joinArtists(artists) {\r\n    if (artists.length > 2) {\r\n        return artists.slice(0, artists.length - 1).join(', ') + ' & ' + artists[artists.length - 1];\r\n    }\r\n    return artists.join(' & ');\r\n}\r\nexports.joinArtists = joinArtists;\r\n"]},"metadata":{},"sourceType":"script"}